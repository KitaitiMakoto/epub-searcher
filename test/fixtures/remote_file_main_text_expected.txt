
  

  
    

    Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification

    2011-06-07 W3C 勧告（Recommendation）

    This version:

      http://www.w3.org/TR/2011/REC-CSS2-20110607

      Latest version:

      http://www.w3.org/TR/CSS2

      Previous versions:

      http://www.w3.org/TR/2011/PR-CSS2-20110412

      http://www.w3.org/TR/2008/REC-CSS2-20080411/

      Editors:

      Bert Bos <bert @w3.org>

      Tantek Çelik <tantek @cs.stanford.edu>

      Ian Hickson <ian @hixie.ch>

      Håkon Wium Lie <howcome @opera.com>
    この文書のエラッタも参照されたい。

    この文書は、次の非標準的な形式でも読むことができる: plain text, gzip'ed tar file, zip file, gzip'ed PostScript, PDF。翻訳も参照されたい。【*訳注：この文書は非公式翻訳です】

    Copyright © 2011 W3C® (MIT, ERCIM, Keio), All Rights Reserved. W3C liability, trademark and document use rules apply.
  

  訳者まえがき

  このたびは『CSS2.1仕様 日本語訳 EPUB版』をダウンロードしていただき、ありがとうございます。

  題名のとおり、この本はW3C勧告であるCSS2.1仕様の日本語訳のEPUBバージョン（以下、EPUB版）です。もとの日本語訳（以下、web版）は http://momdo.s35.xrea.com/web-html-test/spec/CSS21/にて公開しています。このEPUB版は、EPUB化にするに当たって編集上の不都合な点を除き、内容を変更することなく公開しているものです。

  訳者はIT業界の人間というわけでもなく、また英語の能力が特段に秀でているというわけでもありません。それでも、今日のwebの基礎であるCSS2.1の日本語訳が私の知る限り存在しなかったことから、拙い訳ではありますが公開に踏み切ることにしました。

  本書が、読者のCSS2.1仕様への理解の手助けになることはもちろんのこと、web標準への興味やCSS3仕様の理解の足がかりになれば幸いです。

  2012年7月吉日
  訳者記す

  注意事項

  本書はW3Cが2011-06-07に公開した"Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification"の日本語訳です。W3Cの勧告は英語版のみが正規の仕様です。日本語訳は参考情報であって、公式な文書ではありません。

  また、翻訳は誤りを含んでいます。内容に誤りが無いように心がけてはいますが、翻訳の正確性を保証しません。ご自身の責任でご利用ください。

  ただし、誤字・脱字などのケアレスミス、誤訳、訳文が日本語になっていない、訳者の知識不足から来る誤りなどの、ご指摘・ご意見などは歓迎します。内容を検討した上で、可能な範囲で修正の努力をします。訳者への連絡は電子メール<xmomdo@gmail.com>またはtwitterアカウント@momdo_までお願いいたします。

  著作権について

  原著作権はW3Cが保有し、二次著作権は訳者である中村主水（momdo）が保有します。訳者の持つ二次的著作権については、MIT Licenseに準じるものとしますが、W3C Document Licenseと矛盾が生じる場合は、W3C Document Licenseが優先されます。

  謝辞

  web版の翻訳作成時にtwitter上でリプライ等を通じての励ましがなければ、EPUB版として電子出版されることもありませんでした。とりわけ@m61kさんや@Xenophiasさんは大きな励みになりました。

  また、@SouthendさんのアドバイスからEPUB化を思いつき、達人出版会から『ケヴィン・ケリー著作選集　１』を堺屋七左衛門氏が出版されていることが、web版をEPUB化にしてもらうよう依頼する直接のきっかけとなりました。

  最後に達人出版会の高橋征義氏の力添え無くして、EPUB版が出版されることはありませんでした。 この場を借りてお礼申し上げます。

  はじめに

  概要

  本仕様はCascading Style Sheets, level 2 revision 1 (CSS 2.1)を定義する。CSS 2.1は著者およびユーザーが構造化文書（たとえば、HTML文書やXMLアプリケーション）にスタイル（たとえば、フォントや文字間隔）を付加することのできるスタイルシート言語である。文書の内容から表示スタイルを分離することで、CSS 2.1はWeb制作およびサイトの保守・管理を簡素化する。

  CSS 2.1は、CSS1[CSS1]を基礎とするCSS2[CSS2]を強化したものである。CSS 2.1は、メディア固有のスタイルシートをサポートしており、著者は、視覚ブラウザ、聴覚装置、プリンタ、点字デバイス、携帯端末などへの文書のスタイルを調整することができる。また、コンテンツの配置、テーブルのレイアウト、国際化のための機能とユーザインターフェイスに関連するプロパティをサポートしている。

  CSS 2.1はCSS2のいくらかの誤り（最も重要なのは、絶対配置要素の高さと幅の新しい定義、HTMLの"style"属性と"clip"プロパティの新しい計算による多くの影響）を修正し、すでに広く実装されている少数の高度に要求された機能を追加する。しかし、ことにCSS 2.1は、CSSの慣例の"スナップショット"を説明する。すべてのCSSの機能は、勧告の公開日に相互運用可能に実装されているもので構成される。

  CSS 2.1はCSS2から派生しており、CSS2の置換を意図する。CSS2の一部は、CSS 2.1においても不変である。一部は変更されており、そして削除されている。CSS2から削除された部分は、将来のCSS3仕様で使用されるかもしれない。将来の仕様はCSS 2.1を参照すべきである（ただし、CSS 2.1で削除されたCSS2の機能を必要とし、その上でそれらの機能のためにCSS2を参照する必要がある場合、つまり、削除された機能を含むCSS3モジュールの機能を参照する場合を除く）。

  この文書の位置付け

  この節は、公開時点におけるこの文書のステータスについて説明する。他の文書がこの文書に取って代わるかもしれない。W3Cが現在公開しているリストとテクニカルレポートの最新版は、W3C technical reports index at http://www.w3.org/TR/で見つけることができる。

  この文書はW3Cメンバー、ソフトウェア開発者、そしてその他のW3Cグループや関係者によって評価が行われ、ディレクターによってW3C勧告として承認された。この文書は安定しており、参考資料として用いたり、他の文書から引用してよい。仕様の勧告においてW3Cの果たす役割とは、仕様に関心を集め、幅広く仕様の普及を促進することである。これにより、Webの機能と相互運用性の向上が期待できる。

  この文書に関する議論は、公開メーリングリストwww-style@w3.org（アーカイブ、参加の手引きを参照）上で行うことが望ましい。メールを送信する際には、“CSS21”をsubjectに含めてもらいたい。できればこのように: “[CSS21]…コメントの要約…”

  この文書は（Style Activityの一部である）CSS Working Groupによって作成された。

  この文書は2004年2月6日のW3C特許ポリシーの下で活動するグループによって作成された。W3Cは、グループの成果物に関するあらゆる開示特許の公開リストを管理する。ここには、特許開示にあたっての指示も含まれている。特許について十分に知識のある人物が、仕様にEssential Claim(s)が認められると判断した場合は、W3C特許ポリシーの第6章に従い情報を開示する必要がある。

  ワーキンググループはテストスイートと実装レポートを作成している。

  これまでのWorking Draft、Candidate RecommendationとRecommendation以降のすべての変更は付録 Cに記載している。

  
    目次

    クイック目次

    1 CSS 2.1仕様について

      2 CSS 2.1の手引き

      3 適合性: 必要条件と推奨事項

      4 構文と基本データ型

      5 セレクタ

      6 プロパティ値とカスケーディング、継承の割り当て

      7 メディアタイプ

      8 ボックスモデル

      9 視覚整形モデル

      10 視覚整形モデル詳細

      11 視覚効果

      12 生成内容、自動番号付け、リスト

      13 ページメディア

      14 色と背景

      15 フォント

      16 テキスト

      17 テーブル

      18 ユーザーインタフェース

      付録 A. 聴覚スタイルシート

      付録 B. 参考文献一覧

      付録 C. 変更点

      付録 D. HTML 4のためのデフォルトスタイルシート

      付録 E. スタックコンテキストの詳説

      付録 F. 全プロパティ表

      付録 G. CSS2.1の文法

      付録 I. 索引
    

  
    完全な目次

    
        1 CSS 2.1仕様について

        1.1 CSS 2.1 vs CSS 2

          1.2 仕様を読むにあたって

          1.3 仕様の構成

          
            1.4 表記法

            1.4.1 文書言語の要素と属性

              
                1.4.2 CSSプロパティの定義

                1.4.2.1 値

                  1.4.2.2 初期値

                  1.4.2.3 適用対象

                  1.4.2.4 継承性

                  1.4.2.5 パーセント値

                  1.4.2.6 メディアグループ

                  1.4.2.7 算出値
                

              1.4.3 簡略プロパティ

              1.4.4 注記と実例

              1.4.5 画像と説明文
            

          1.5 謝辞
        

      
        2 CSS 2.1の手引き

        2.1 HTMLのための簡潔なチュートリアル

          2.2 XMLのための簡潔なチュートリアル

          
            2.3 CSS 2.1の処理モデル

            2.3.1 キャンバス

              2.3.2 CSS 2.1アドレス指定モデル
            

          2.4 CSS設計原則
        

      
        3 適合性: 必要条件と推奨事項

        3.1 定義

          3.2 ユーザエージェントの適合性

          3.3 エラーの処理方法

          3.4 text/css content-type
        

      
        4 構文と基本データ型

        
            4.1 構文

            4.1.1 トークン化

              
                4.1.2 キーワード

                4.1.2.1 ベンダー固有の拡張

                  4.1.2.2 参考情報の歴史的なノート
                

              4.1.3 文字と活字ケース

              4.1.4 文

              4.1.5 @規則

              4.1.6 ブロック

              4.1.7 規則集合、宣言ブロック、セレクタ

              4.1.8 宣言とプロパティ

              4.1.9 コメント
            

          4.2 構文解析エラーの処理規定

          
            4.3 値

            4.3.1 整数値と実数値

              4.3.2 長さ

              4.3.3 パーセント値

              4.3.4 URLおよびURI

              4.3.5 カウンタ

              4.3.6 色

              4.3.7 文字列

              4.3.8 サポートしない値
            

          
            4.4 CSSスタイルシートの表現

            4.4.1 文字符号化で表現できない文字を参照する
            
        

      
        5 セレクタ

        5.1 パターンマッチ

          
            5.2 セレクタの構文

            5.2.1 グループ化
            

          5.3 全称セレクタ

          5.4 型セレクタ

          5.5 子孫セレクタ

          5.6 子セレクタ

          5.7 隣接セレクタ

          
            5.8 属性セレクタ

            5.8.1 属性および属性値のマッチング

              5.8.2 DTDにおける属性の規定値

              5.8.3 クラスセレクタ
            

          5.9 IDセレクタ

          5.10 擬似要素と擬似クラス

          
            5.11 擬似クラス

            5.11.1 :first-child 擬似クラス

              5.11.2 リンク擬似クラス: :linkと:visited

              5.11.3 動的擬似クラス: :hover、:active、:focus

              5.11.4 言語擬似クラス: :lang
            

          
            5.12 擬似要素

            5.12.1 :first-line擬似要素

              5.12.2 :first-letter疑似要素

              5.12.3 :beforeと:after疑似要素
            
        

      
        6 プロパティ値とカスケーディング、継承の割り当て

        
            6.1 指定値、算出値、実効値

            6.1.1 指定値

              6.1.2 算出値

              6.1.3 使用値

              6.1.4 実効値
            

          
            6.2 継承

            6.2.1 'inherit'値
            

          6.3 @import規則

          
            6.4 カスケード処理

            6.4.1 カスケード処理の順序

              6.4.2 !important規則

              6.4.3 セレクタの詳細度の計算

              6.4.4 非CSSの見栄えヒントの優先順位
            
        

      
        7 メディアタイプ

        7.1メディアタイプの手引き

          
            7.2メディア依存なスタイルシートの指定

            7.2.1 @media規則
            

          
            7.3認識されるメディアタイプ

            7.3.1メディアグループ
            
        

      
        8 ボックスモデル

        8.1 ボックスの寸法

          8.2 マージン、パディング、ボーダーの例

          
            8.3 マージンのプロパティ: 'margin-top'、'margin-right'、'margin-bottom'、'margin-left'、'margin'

            8.3.1 マージンの相殺
            

          8.4 パディングのプロパティ: 'padding-top'、'padding-right'、'padding-bottom'、'padding-left'、'padding'

          
            8.5 ボーダーのプロパティ

            8.5.1 ボーダーの幅: 'border-top-width'、'border-right-width'、'border-bottom-width'、'border-left-width'、'border-width'

              8.5.2 ボーダーの色: 'border-top-color'、'border-right-color'、'border-bottom-color'、'border-left-color'、'border-color'

              8.5.3 ボーダーの種類: 'border-top-style'、'border-right-style'、'border-bottom-style'、'border-left-style'、'border-style'

              8.5.4 ボーダーの簡略化プロパティ: 'border-top'、'border-bottom'、'border-right'、'border-left'、'border'
            

          8.6 双方向コンテキスト内のインライン要素のボックスモデル
        

      
        9 視覚整形モデル

        
            9.1 視覚整形モデルの導入

            9.1.1 ビューポート

              9.1.2 包含ブロック
            

          
            9.2 ボックスの生成を制御する

            
                9.2.1 ブロックレベル要素とブロックボックス

                9.2.1.1匿名ブロックボックス
                

              
                9.2.2インラインレベル要素とインラインボックス

                9.2.2.1 匿名インラインボックス
                

              9.2.3 ランインボックス

              9.2.4 'display'プロパティ
            

          
            9.3 位置決め方式

            9.3.1 位置決め方式の選択: 'position'プロパティ

              9.3.2 ボックスのオフセット: 'top'、'right'、'bottom'、'left'
            

          
            9.4 通常フロー

            9.4.1 ブロック整形コンテキスト

              9.4.2 インライン整形コンテキスト

              9.4.3 相対配置
            

          
            9.5 浮動

            9.5.1 浮動体の配置: 'float'プロパティ

              9.5.2 浮動体に隣接するフローの制御: 'clear'プロパティ
            

          
            9.6 絶対配置

            9.6.1 固定配置
            

          9.7 'display'、'position'、'float'の関係

          
            9.8 通常フロー、浮動、絶対配置の比較

            9.8.1 通常フロー

              9.8.2 相対配置

              9.8.3 ボックスの浮動

              9.8.4 絶対配置
            

          
            9.9 レイヤーの表現

            9.9.1 スタックレベルの指定: 'z-index'プロパティ
            

          9.10 書字方向: 'direction'、'unicode-bidi'プロパティ
        

      
        10 視覚整形モデル詳細

        10.1 "包含ブロック"の定義

          10.2 内容の幅: 'width'プロパティ

          
            10.3 幅とマージンの計算

            10.3.1 非置換インライン要素の場合

              10.3.2 置換インライン要素の場合

              10.3.3 通常フローでの非置換ブロック要素の場合

              10.3.4 通常フローでの置換ブロック要素の場合

              10.3.5 非置換浮動要素の場合

              10.3.6 置換浮動要素の場合

              10.3.7 絶対配置の非置換要素の場合

              10.3.8 絶対配置の置換要素の場合

              10.3.9 通常フローでの非置換インラインブロック要素の場合

              10.3.10 通常フローでの置換インラインブロック要素の場合
            

          10.4 幅の最大値と最小値: 'min-width'および'max-width'

          10.5 内容の高さ: 'height'プロパティ

          
            10.6 高さとマージンの計算

            10.6.1 非置換インライン要素の場合

              10.6.2 置換インライン要素、通常フローでの置換ブロックレベルおよび置換インラインレベル要素、置換浮動要素の場合

              10.6.3 'overflow'が'visible'時の通常フローでの非置換ブロックレベル要素の場合

              10.6.4 絶対配置の非置換要素の場合

              10.6.5 絶対配置の置換要素の場合

              10.6.6 複雑な事例

              10.6.7 ブロック整形コンテキストルートの'auto'高さ
            

          10.7 高さの最大値と最小値: 'min-height'、'max-height'

          
            10.8 行の高さの計算: 'line-height'、'vertical-align'プロパティ

            10.8.1 行間と半行間
            
        

      
        11 視覚効果

        
            11.1 はみ出しと切り抜き

            11.1.1 はみ出し: 'overflow'プロパティ

              11.1.2 切り抜き: 'clip'プロパティ
            

          11.2 可視性: 'visibility'プロパティ
        

      
        12 生成内容、自動番号付け、リスト

        12.1 :beforeと:after疑似要素

          12.2 'content'プロパティ

          
            12.3 引用符

            12.3.1 'quotes'プロパティで引用符を指定

              12.3.2 'content'プロパティで引用符を挿入
            

          
            12.4 自動カウンタと番号付け

            12.4.1 カウンタの入れ子と範囲

              12.4.2 カウンタの形式

              12.4.3 'display: none'の要素でのカウンタ
            

          
            12.5 リスト

            12.5.1 リスト: 'list-style-type'、'list-style-image'、'list-style-position'、'list-style'プロパティ
            
        

      
        13 ページメディア

        13.1 ページメディア概論

          
            13.2 ページボックス: @page規則

            13.2.1 ページのマージン

              13.2.2 ページセレクタ: 左右と最初のページの選択

              13.2.3 ページボックスの外側の内容
            

          
            13.3 改ページ

            13.3.1 改ページプロパティ: 'page-break-before'、'page-break-after'、 'page-break-inside'

              13.3.2 要素の内側での改ページ: 'orphans'、'widows'

              13.3.3 改ページの許可

              13.3.4 強制改ページ

              13.3.5 最適な改ページ
            

          13.4 ページコンテキストにおけるカスケード処理
        

      
        14 色と背景

        14.1 前景色: 'color'プロパティ

          
            14.2 背景

            14.2.1 背景のプロパティ: 'background-color'、'background-image'、'background-repeat'、'background-attachment'、'background-position'、'background'
            
        

      
        15 フォント

        15.1 概論

          15.2 フォントのマッチングアルゴリズム

          
            15.3 フォントファミリ: 'font-family'プロパティ

            
                15.3.1 総称フォントファミリ

                15.3.1.1 serif

                  15.3.1.2 sans-serif

                  15.3.1.3 cursive

                  15.3.1.4 fantasy

                  15.3.1.5 monospace
                
            

          15.4 フォントスタイル: 'font-style'プロパティ

          15.5 スモールキャップ: 'font-variant'プロパティ

          15.6 フォントの太さ: 'font-weight'プロパティ

          15.7 フォントの大きさ: 'font-size'プロパティ

          15.8 フォントの簡略プロパティ: 'font'プロパティ
        

      
        16 テキスト

        16.1 インデント: 'text-indent'プロパティ

          16.2 配置: 'text-align'プロパティ

          
            16.3 装飾

            16.3.1 下線、上線、打ち消し線、点滅: 'text-decoration'プロパティ
            

          16.4 文字と単語の間隔: 'letter-spacing'、'word-spacing'プロパティ

          16.5 大文字化: 'text-transform'プロパティ

          
            16.6 空白: 'white-space'プロパティ

            16.6.1 'white-space'処理モデル

              16.6.2 双方向での空白の相殺の例

              16.6.3 制御文字と合成文字の詳細
            
        

      
        17 テーブル

        17.1 テーブル概論

          
            17.2 CSSテーブルモデル

            17.2.1 匿名テーブルオブジェクト
            

          17.3 列

          
            17.4 視覚整形モデルにおけるテーブルの扱い

            17.4.1 キャプションの位置と端揃え
            

          
            17.5 テーブルの内容の視覚レイアウト

            17.5.1 テーブルのレイヤーとその透過性

              
                17.5.2 テーブルの幅のアルゴリズム: 'table-layout'プロパティ

                17.5.2.1 固定テーブルレイアウト

                  17.5.2.2 自動テーブルレイアウト
                

              17.5.3 テーブルの高さのアルゴリズム

              17.5.4 列での水平位置揃え

              17.5.5 行や列の動的効果
            

          
            17.6 ボーダー

            
                17.6.1 分離ボーダーモデル

                17.6.1.1 空セル周りのボーダーと背景: 'empty-cells'プロパティ
                

              
                17.6.2 結合ボーダーモデル

                17.6.2.1 ボーダーの競合の解決
                

              17.6.3 ボーダーの種類
            
        

      
        18 ユーザーインタフェース

        18.1 カーソル: 'cursor'プロパティ

          18.2 システム色

          18.3 フォントのユーザー優先権

          
            18.4 動的アウトライン: 'outline'プロパティ

            18.4.1 アウトラインとフォーカス
            

          18.5 拡大表示
        

      
        付録 A. 聴覚スタイルシート

        A.1 メディアタイプ'aural'および'speech'

          
            A.2 聴覚スタイルシートの手引き

            A.2.1 角度

              A.2.2 時間

              A.2.3 周波数
            

          A.3 音量プロパティ: 'volume'

          A.4 声のプロパティ: 'speak'

          A.5 区切りプロパティ: 'pause-before'、'pause-after'、'pause'

          A.6 合図のプロパティ: 'cue-before'、'cue-after'、'cue'

          A.7 ミキシングプロパティ: 'play-during'

          A.8 空間プロパティ: 'azimuth'、'elevation'

          A.9 音声特性プロパティ: 'speech-rate'、'voice-family'、'pitch'、'pitch-range'、'stress'、'richness'

          A.10 話法プロパティ: 'speak-punctuation'、'speak-numeral'

          
            A.11 テーブルの音声レンダリング

            A.11.1 ヘッダの話法: 'speak-header'プロパティ
            

          A.12 HTMLのサンプルスタイルシート

          A.13 Emacspeak
        

      
        付録 B. 参考文献一覧

        B.1 標準情報

          B.2 参考情報
        

      
        付録 C. 変更点

        
            C.1 Additional property values

            C.1.1 Section 4.3.6 Colors

              C.1.2 Section 9.2.4 The 'display' property

              C.1.3 Section 12.2 The 'content' property

              C.1.4 Section 16.6 White space: the 'white-space' property

              C.1.5 Section 18.1 Cursors: the 'cursor' property
            

          
            C.2 Changes

            C.2.1 Section 1.1 CSS 2.1 vs CSS 2

              C.2.2 Section 1.2 Reading the specification

              C.2.3 Section 1.3 How the specification is organized

              C.2.4 Section 1.4.2.1 Value

              C.2.5 Section 1.4.2.6 Media groups

              C.2.6 Section 1.4.2.7 Computed value

              C.2.7 Section 1.4.4 Notes and examples

              C.2.8 Section 1.5 Acknowledgments

              C.2.9 Section 3.2 Conformance

              C.2.10 Section 3.3 Error Conditions

              C.2.11 Section 4.1.1 Tokenization

              C.2.12 Section 4.1.3 Characters and case

              C.2.13 Section 4.2 Rules for handling parsing errors

              C.2.14 Section 4.3 Values

              C.2.15 Section 4.3.2 Lengths

              C.2.16 Section 4.3.4 URLs and URIs

              C.2.17 Section 4.3.5 Counters

              C.2.18 Section 4.3.6 Colors

              C.2.19 Section 4.3.8 Unsupported Values

              C.2.20 Section 4.4 CSS style sheet representation

              C.2.21 Section 5.8.1 Matching attributes and attribute values

              C.2.22 Section 5.8.3 Class selectors

              C.2.23 Section 5.9 ID selectors

              C.2.24 Section 5.10 Pseudo-elements and pseudo-classes

              C.2.25 Section 5.11.2 The link pseudo-classes: :link and :visited

              C.2.26 Section 5.11.4 The language pseudo-class: :lang

              C.2.27 Section 5.12.1 The :first-line pseudo-element

              C.2.28 Section 5.12.2 The :first-letter pseudo-element

              C.2.29 Section 6.1 Specified, computed, and actual values

              C.2.30 Section 6.4.1 Cascading order

              C.2.31 Section 6.4.3 Calculating a selector's specificity

              C.2.32 Section 6.4.4 Precedence of non-CSS presentational hints

              C.2.33 Section 7.3 Recognized Media Types

              C.2.34 Section 7.3.1 Media Groups

              C.2.35 Section 8.3 Margin properties

              C.2.36 Section 8.3.1 Collapsing margins

              C.2.37 Section 8.4 Padding properties

              C.2.38 Section 8.5.2 Border color

              C.2.39 Section 8.5.3 Border style

              C.2.40 Section 8.6 The box model for inline elements in bidirectional context

              C.2.41 Section 9.1.2 Containing blocks

              C.2.42 Section 9.2.1.1 Anonymous block boxes

              C.2.43 Section 9.2.2.1 Anonymous inline boxes

              C.2.44 Section 9.2.3 Run-in boxes

              C.2.45 Section 9.2.4 The 'display' property

              C.2.46 Section 9.3.1 Choosing a positioning scheme

              C.2.47 Section 9.3.2 Box offsets

              C.2.48 Section 9.4.1 Block formatting contexts

              C.2.49 Section 9.4.2 Inline formatting context

              C.2.50 Section 9.4.3 Relative positioning

              C.2.51 Section 9.5 Floats

              C.2.52 Section 9.5.1 Positioning the float

              C.2.53 Section 9.5.2 Controlling flow next to floats

              C.2.54 Section 9.7 Relationships between 'display', 'position', and 'float'

              C.2.55 Section 9.9 Layered presentation

              C.2.56 Section 9.10 Text direction

              C.2.57 Chapter 10 Visual formatting model details

              C.2.58 Section 10.1 Definition of "containing block"

              C.2.59 Section 10.2 Content width

              C.2.60 Section 10.3 Calculating widths and margins

              C.2.61 Section 10.3.2 Inline, replaced elements

              C.2.62 Section 10.3.3 Block-level, non-replaced elements in normal flow

              C.2.63 Section 10.3.4 Block-level, replaced elements in normal flow

              C.2.64 Section 10.3.5 Floating, non-replaced elements

              C.2.65 Section 10.3.6 Floating, replaced elements

              C.2.66 Section 10.3.7 Absolutely positioned, non-replaced elements

              C.2.67 Section 10.3.8 Absolutely positioned, replaced elements

              C.2.68 Section 10.4 Minimum and maximum widths

              C.2.69 Section 10.5 Content height

              C.2.70 Section 10.6 Calculating heights and margins

              C.2.71 Section 10.6.1 Inline, non-replaced elements

              C.2.72 Section 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, 'inline-block' replaced elements in normal flow and floating replaced elements

              C.2.73 Section 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'

              C.2.74 Section 10.6.4 Absolutely positioned, non-replaced elements

              C.2.75 Section 10.6.5 Absolutely positioned, replaced elements

              C.2.76 Section 10.7 Minimum and maximum heights

              C.2.77 Section 10.8 Line height calculations

              C.2.78 Section 10.8.1 Leading and half-leading

              C.2.79 Section 11.1 Overflow and clipping

              C.2.80 Section 11.1.1 Overflow

              C.2.81 Section 11.1.2 Clipping: the 'clip' property

              C.2.82 Section 11.2 Visibility

              C.2.83 Chapter 12 Generated content, automatic numbering, and lists

              C.2.84 Section 12.1 The :before and :after pseudo-elements

              C.2.85 Section 12.2 The 'content' property

              C.2.86 Section 12.3.2 Inserting quotes with the 'content' property

              C.2.87 Section 12.4 Automatic counters and numbering

              C.2.88 Section 12.4.1 Nested counters and scope

              C.2.89 Section 12.5 Lists

              C.2.90 Section 12.5.1 Lists

              C.2.91 Chapter 13 Paged media

              C.2.92 Section 13.2.2 Page selectors

              C.2.93 Section 13.3.1 Page break properties

              C.2.94 Section 13.3.3 Allowed page breaks

              C.2.95 Section 14.2.1 Background properties

              C.2.96 Section 14.3 Gamma correction

              C.2.97 Chapter 15 Fonts

              C.2.98 Section 15.2 Font matching algorithm

              C.2.99 Section 15.2.2 Font family

              C.2.100 Section 15.5 Small-caps

              C.2.101 Section 15.6 Font boldness

              C.2.102 Section 15.7 Font size

              C.2.103 Chapter 16 Text

              C.2.104 Section 16.2 Alignment

              C.2.105 Section 16.3.1 Underlining, over lining, striking, and blinking

              C.2.106 Section 16.4 Letter and word spacing

              C.2.107 Section 16.5 Capitalization

              C.2.108 Section 16.6 White space

              C.2.109 Chapter 17 Tables

              C.2.110 Section 17.2 The CSS table model

              C.2.111 Section 17.2.1 Anonymous table objects

              C.2.112 Section 17.4 Tables in the visual formatting model

              C.2.113 Section 17.4.1 Caption position and alignment

              C.2.114 Section 17.5 Visual layout of table contents

              C.2.115 Section 17.5.1 Table layers and transparency

              C.2.116 Section 17.5.2.1 Fixed table layout

              C.2.117 Section 17.5.2.2 Automatic table layout

              C.2.118 Section 17.5.3 Table height algorithms

              C.2.119 Section 17.5.4 Horizontal alignment in a column

              C.2.120 Section 17.6 Borders

              C.2.121 Section 17.6.1 The separated borders model

              C.2.122 Section 17.6.1.1 Borders and Backgrounds around empty cells

              C.2.123 Section 17.6.2 The collapsing border model

              C.2.124 Section 17.6.2.1 Border conflict resolution

              C.2.125 Section 18.1 Cursors: the 'cursor' property

              C.2.126 Section 18.4 Dynamic outlines

              C.2.127 Chapter 12 Generated content, automatic numbering, and lists

              C.2.128 Appendix A. Aural style sheets

              C.2.129 Appendix A Section 5 Pause properties

              C.2.130 Appendix A Section 6 Cue properties

              C.2.131 Appendix A Section 7 Mixing properties

              C.2.132 Appendix B Bibliography

              C.2.133 Other
            

          
            C.3 Errors

            C.3.1 Shorthand properties

              C.3.2 Applies to

              C.3.3 Section 4.1.1 (and G2)

              C.3.4 Section 4.1.3 Characters and case

              C.3.5 Section 4.3 (Double sign problem)

              C.3.6 Section 4.3.2 Lengths

              C.3.7 Section 4.3.3 Percentages

              C.3.8 Section 4.3.4 URLs and URIs

              C.3.9 Section 4.3.5 Counters

              C.3.10 Section 4.3.6 Colors

              C.3.11 Section 4.3.7 Strings

              C.3.12 Section 5.10 Pseudo-elements and pseudo-classes

              C.3.13 Section 6.4 The cascade

              C.3.14 Section 8.1 Box Dimensions

              C.3.15 Section 8.2 Example of margins, padding, and borders

              C.3.16 Section 8.5.4 Border shorthand properties

              C.3.17 Section 9.2.1 Block-level elements and block boxes

              C.3.18 Section 9.3.1 Choosing a positioning scheme

              C.3.19 Section 9.3.2 Box offsets

              C.3.20 Section 9.4.1 Block formatting contexts

              C.3.21 Section 9.4.2 Inline formatting context

              C.3.22 Section 9.4.3 Relative positioning

              C.3.23 Section 9.5 Floats

              C.3.24 Section 9.5.1 Positioning the float

              C.3.25 Section 9.5.2 Controlling flow next to floats

              C.3.26 Section 9.6 Absolute positioning

              C.3.27 Section 9.7 Relationships between 'display', 'position', and 'float'

              C.3.28 Section 9.10 Text direction

              C.3.29 Section 10.1 Definition of "containing block"

              C.3.30 Section 10.3.3 Block-level, non-replaced elements in normal flow

              C.3.31 Section 10.4 Minimum and maximum widths

              C.3.32 Section 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'

              C.3.33 Section 10.7 Minimum and maximum heights

              C.3.34 Section 11.1.1 Overflow

              C.3.35 Section 11.1.2 Clipping: the 'clip' property

              C.3.36 Section 11.2 Visibility

              C.3.37 Section 12.4.2 Counter styles

              C.3.38 Section 12.6.2 Lists

              C.3.39 Section 14.2 The background

              C.3.40 Section 14.2.1 Background properties

              C.3.41 Section 15.2 Font matching algorithm

              C.3.42 Section 15.7 Font size

              C.3.43 Section 16.1 Indentation

              C.3.44 Section 16.2 Alignment

              C.3.45 Section 17.2 The CSS table model

              C.3.46 Section 17.2.1 Anonymous table objects

              C.3.47 Section 17.4 Tables in the visual formatting model

              C.3.48 Section 17.5 Visual layout of table contents

              C.3.49 Section 17.5.1 Table layers and transparency

              C.3.50 Section 17.6.1 The separated borders model

              C.3.51 Section 18.2 System Colors

              C.3.52 Section E.2 Painting order
            

          
            C.4 Clarifications

            C.4.1 Section 2.1 A brief CSS 2.1 tutorial for HTML

              C.4.2 Section 2.2 A brief CSS 2.1 tutorial for XML

              C.4.3 Section 2.3 The CSS 2.1 processing model

              C.4.4 Section 3.1 Definitions

              C.4.5 Section 4.1 Syntax

              C.4.6 Section 4.1.1 Tokenization

              C.4.7 Section 4.1.3 Characters and case

              C.4.8 Section 4.1.7 Rule sets, declaration blocks, and selectors

              C.4.9 Section 4.2 Rules for handling parsing errors

              C.4.10 Section 4.3.1 Integers and real numbers

              C.4.11 Section 4.3.2 Lengths

              C.4.12 Section 4.3.4 URLs and URIs

              C.4.13 Section 5.1 Pattern matching

              C.4.14 Section 5.7 Adjacent sibling selectors

              C.4.15 Section 5.8.1 Matching attributes and attribute values

              C.4.16 Section 5.8.2 Default attribute values in DTDs

              C.4.17 Section 5.9 ID selectors

              C.4.18 Section 5.11.3 The dynamic pseudo-classes: :hover, :active, and :focus

              C.4.19 Section 5.11.4 The language pseudo-class: :lang

              C.4.20 Section 5.12.2 The :first-letter pseudo-element

              C.4.21 Section 6.2 Inheritance

              C.4.22 Section 6.2.1 The 'inherit' value

              C.4.23 Section 6.3 The @import rule

              C.4.24 Section 6.4 The Cascade

              C.4.25 Section 6.4.1 Cascading order

              C.4.26 Section 6.4.3 Calculating a selector's specificity

              C.4.27 Section 7.2.1 The @media rule

              C.4.28 Section 7.3 Recognized media types

              C.4.29 Section 7.3.1 Media groups

              C.4.30 Section 8.1 Box dimensions

              C.4.31 Section 8.3 Margin properties

              C.4.32 Section 8.3.1 Collapsing margins

              C.4.33 Section 8.5.3 Border style

              C.4.34 Section 9.1.1 The viewport

              C.4.35 Section 9.2.4 The 'display' property

              C.4.36 Section 9.3.1 Choosing a positioning scheme

              C.4.37 Section 9.3.2 Box offsets

              C.4.38 Section 9.4.2 Inline formatting context

              C.4.39 Section 9.4.3 Relative positioning

              C.4.40 Section 9.5 Floats

              C.4.41 Section 9.5.1 Positioning the float

              C.4.42 Section 9.5.2 Controlling flow next to floats

              C.4.43 Section 9.8 Comparison of normal flow, floats, and absolute positioning

              C.4.44 Section 10.1 Definition of "containing block"

              C.4.45 Section 10.2 Content width

              C.4.46 Section 10.3.3 Block-level, non-replaced elements in normal flow

              C.4.47 Section 10.3.8 Absolutely positioning, replaced elements

              C.4.48 Section 10.4 Minimum and maximum widths

              C.4.49 Section 10.6 Calculating heights and margins

              C.4.50 Section 10.7 Minimum and maximum heights

              C.4.51 Section 10.8 Line height calculations

              C.4.52 Section 10.8.1 Leading and half-leading

              C.4.53 Section 11.1 Overflow and clipping

              C.4.54 Section 11.1.1 Overflow

              C.4.55 Section 11.1.2 Clipping

              C.4.56 Section 11.2 Visibility

              C.4.57 Section 12.1 The :before and :after pseudo-elements

              C.4.58 Section 12.2 The 'content' property

              C.4.59 Section 12.3.2 Inserting quotes with the 'content' property

              C.4.60 Section 12.4 Automatic counters and numbering

              C.4.61 Section 12.4.3 Counters in elements with 'display: none'

              C.4.62 Section 14.2 The background

              C.4.63 Section 15.1 Fonts Introduction

              C.4.64 Section 15.2 Font matching algorithm

              C.4.65 Section 15.2.2 Font family

              C.4.66 Section 15.3.1 Generic font families

              C.4.67 Section 15.4 Font styling

              C.4.68 Section 15.5 Small-caps

              C.4.69 Section 15.6 Font boldness

              C.4.70 Section 15.7 Font size

              C.4.71 Section 16.1 Indentation

              C.4.72 Section 16.2 Alignment

              C.4.73 Section 16.3.1 Underlining, over lining, striking, and blinking

              C.4.74 Section 16.5 Capitalization

              C.4.75 Section 16.6 White space

              C.4.76 Section 17.1 Introduction to tables

              C.4.77 Section 17.2 The CSS table model

              C.4.78 Section 17.2.1 Anonymous table objects

              C.4.79 Section 17.4 Tables in the visual formatting model

              C.4.80 Section 17.5 Visual layout of table contents

              C.4.81 Section 17.5.1 Table layers and transparency

              C.4.82 Section 17.5.2 Table width algorithms

              C.4.83 Section 17.5.2.1 Fixed table layout

              C.4.84 Section 17.5.2.2 Automatic table layout

              C.4.85 Section 17.5.4 Horizontal alignment in a column

              C.4.86 Section 17.5.5 Dynamic row and column effects

              C.4.87 Section 17.6.1 The separated borders model

              C.4.88 Section 17.6.2 The collapsing borders model

              C.4.89 Section 18.2 System Colors

              C.4.90 Section 18.4 Dynamic outlines

              C.4.91 Section 18.4.1 Outlines and the focus

              C.4.92 Appendix D Default style sheet for HTML 4
            

          
            C.5 Errata since the Candidate Recommendation of July 2007

            C.5.1 Section 1.4.2.1 Value

              C.5.2 Section 2.3 The CSS 2.1 processing model

              C.5.3 Section 3.1 Definitions

              C.5.4 Section 4.1.1 Tokenization

              C.5.5 Section 4.1.2.2 Informative Historical Notes

              C.5.6 Section 4.1.3 Characters and case

              C.5.7 Section 4.1.3 Characters and case

              C.5.8 Section 4.1.3 Characters and case

              C.5.9 Section 4.1.3 Characters and case

              C.5.10 Section 4.1.5 At-rules

              C.5.11 Section 4.1.7 Rule sets, declaration blocks, and selectors

              C.5.12 Section 4.2 Rules for handling parsing errors

              C.5.13 Section 4.2 Rules for handling parsing errors

              C.5.14 Section 4.3.2 Lengths

              C.5.15 Section 4.3.5 Counters

              C.5.16 Section 5.8.1 Matching attributes and attribute values

              C.5.17 Section 5.8.2 Default attribute values in DTDs

              C.5.18 Section 5.11.4 The language pseudo-class: :lang

              C.5.19 Section 5.12.3 The :before and :after pseudo-elements

              C.5.20 Section 6.3 The @import rule

              C.5.21 Section 6.3 The @import rule

              C.5.22 Section 6.4.1 Cascading order

              C.5.23 Section 6.4.1 Cascading order

              C.5.24 Section 7.2.1 The @media rule

              C.5.25 Section 8.3.1 Collapsing margins

              C.5.26 Section 8.3.1 Collapsing margins

              C.5.27 Section 8.3.1 Collapsing margins

              C.5.28 Section 9.2.2 Inline-level elements and inline boxes

              C.5.29 Section 9.2.4 The 'display' property

              C.5.30 Section 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

              C.5.31 Section 9.5 Floats

              C.5.32 Section 9.5 Floats

              C.5.33 Section 9.5.2 Controlling flow next to floats: the 'clear' property

              C.5.34 Section 9.6.1 Fixed positioning

              C.5.35 Section 9.9.1 Specifying the stack level: the 'z-index' property

              C.5.36 Section 10.1 Definition of "containing block"

              C.5.37 Section 10.3 Calculating widths and margins

              C.5.38 Section 10.3.1 Inline, non-replaced elements

              C.5.39 Section 10.3.2 Inline, replaced elements

              C.5.40 Section 10.3.2 Inline, replaced elements

              C.5.41 Section 10.3.3 Block-level, non-replaced elements in normal flow

              C.5.42 Section 10.3.7 Absolutely positioned, non-replaced elements

              C.5.43 Section 10.3.7 Absolutely positioned, non-replaced elements

              C.5.44 Section 10.3.8 Absolutely positioned, replaced elements

              C.5.45 Section 10.3.8 Absolutely positioned, replaced elements

              C.5.46 Section 10.3.8 Absolutely positioned, replaced elements

              C.5.47 Section 10.5 Content height: the 'height' property

              C.5.48 Section 10.6.2 Inline replaced elements […]

              C.5.49 Section 10.6.4 Absolutely positioned, non-replaced elements

              C.5.50 Section 10.6.5 Absolutely positioned, replaced elements

              C.5.51 Section 10.8.1 Leading and half-leading

              C.5.52 Section 11.1.1 Overflow: the 'overflow' property

              C.5.53 Section 11.1.2 Clipping: the 'clip' property

              C.5.54 Section 12.2 The 'content' property

              C.5.55 Section 12.4.2 Counter styles

              C.5.56 Section 12.5 Lists

              C.5.57 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.5.58 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.5.59 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.5.60 Section 13.2 Page boxes: the @page rule

              C.5.61 Section 13.2.1.1 Rendering page boxes that do not fit a target sheet

              C.5.62 Section 13.2.3 Content outside the page box

              C.5.63 Section 13.3.1 Page break properties: 'page-break-before', 'page-break-after', 'page-break-inside'

              C.5.64 Section 13.3.1 Page break properties: 'page-break-before', 'page-break-after', 'page-break-inside'

              C.5.65 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

              C.5.66 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

              C.5.67 Section 13.3.3 Allowed page breaks

              C.5.68 Section 13.3.3 Allowed page breaks

              C.5.69 Section 13.3.3 Allowed page breaks

              C.5.70 Section 13.3.5 "Best" page breaks

              C.5.71 Section 14.2 The background

              C.5.72 Section 14.2 The background

              C.5.73 Section 14.2.1 Background properties: 'background-color', 'background-image', 'background-repeat', 'background-attachment', 'background-position', and 'background'

              C.5.74 Section 15.6 Font boldness: the 'font-weight' property

              C.5.75 Section 16.6 Whitespace: the 'white-space' property

              C.5.76 Section 16.6.1 The 'white-space' processing model

              C.5.77 Section 17.2.1 Anonymous table objects

              C.5.78 Section 17.2.1 Anonymous table objects

              C.5.79 Section 17.4 Tables in the visual formatting model

              C.5.80 Section 17.5.4 Horizontal alignment in a column

              C.5.81 Section 18.1 Cursors: the 'cursor' property

              C.5.82 Section B.2 Informative references

              C.5.83 Appendix D. Default style sheet for HTML 4

              C.5.84 Appendix D. Default style sheet for HTML 4

              C.5.85 Section E.2 Painting order

              C.5.86 Appendix G. Grammar of CSS 2.1

              C.5.87 Section G.1 Grammar

              C.5.88 Section G.2 Lexical scanner

              C.5.89 Section G.2 Lexical scanner

              C.5.90 Section G.2 Lexical scanner

              C.5.91 Section G.2 Lexical scanner

              C.5.92 Appendix I. Index
            

          
            C.6 Errata since the Candidate Recommendation of April 2009

            C.6.1 Section 4.2 Rules for handling parsing errors

              C.6.2 Section 13.3.3 Allowed page breaks

              C.6.3 Section 15.3 Font family: the 'font-family' property

              C.6.4 Section 15.3.1.1 serif

              C.6.5 Section 15.7 Font size: the 'font-size' property

              C.6.6 Section 17.5.2.1 Fixed table layout

              C.6.7 Section 17.5.3 Table height layout

              C.6.8 Appendix G. Grammar of CSS 2.1
            

          
            C.7 Errata since the Candidate Recommendation of September 2009

            C.7.1 Section 1.4.2.1 Value

              C.7.2 Section 3.1 Definitions

              C.7.3 Section 4.1.1 Tokenization

              C.7.4 Section 4.1.1 Tokenization

              C.7.5 Section 4.1.1 Tokenization

              C.7.6 Section 4.1.1 Tokenization

              C.7.7 Section 4.1.2.2 Informative Historical Notes

              C.7.8 Section 4.1.3 Characters and case

              C.7.9 Section 4.1.3 Characters and case

              C.7.10 Section 4.1.8 Declarations and properties

              C.7.11 Section 4.2 Rules for handling parsing errors

              C.7.12 Section 4.3.2 Lengths

              C.7.13 Section 4.3.2 Lengths

              C.7.14 Section 4.3.4 URLs and URIs

              C.7.15 Section 4.3.4 URLs and URIs

              C.7.16 Section 5.8.2 Default attribute values in DTDs

              C.7.17 Section 5.11.4 The language pseudo-class: :lang

              C.7.18 Section 5.12 Pseudo-elements

              C.7.19 Section 5.12.1 The :first-line pseudo-element

              C.7.20 Section 5.12.2 The :first-letter pseudo-element

              C.7.21 Section 6.2 Inheritance

              C.7.22 Section 6.4.4 Precedence of non-CSS presentational hints

              C.7.23 Section 7.3 Recognized media types

              C.7.24 Section 8.3.1 Collapsing margins

              C.7.25 Section 8.3.1 Collapsing margins

              C.7.26 Section 9.2.1 Block-level elements and block boxes

              C.7.27 Section 9.2.1.1 Anonymous block boxes

              C.7.28 Section 9.2.1.1 Anonymous block boxes

              C.7.29 Section 9.2.1.1 Anonymous block boxes

              C.7.30 Section 9.2.1.1 Anonymous block boxes

              C.7.31 Section 9.2.2 Inline-level elements and inline boxes

              C.7.32 Section 9.2.3 Run-in boxes

              C.7.33 Section 9.2.4 The 'display' property

              C.7.34 Section 9.2.4 The 'display' property

              C.7.35 Section 9.3 Positioning schemes

              C.7.36 Section 9.4 Normal flow

              C.7.37 Section 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

              C.7.38 Section 9.5 Floats

              C.7.39 Section 9.5 Floats

              C.7.40 Section 9.5.2 Controlling flow next to floats: the 'clear' property

              C.7.41 Section 9.5.2 Controlling flow next to floats: the 'clear' property

              C.7.42 Section 9.5.2 Controlling flow next to floats: the 'clear' property

              C.7.43 Section 9.5.2 Controlling flow next to floats: the 'clear' property

              C.7.44 Section 14.2.1 Background properties

              C.7.45 Section 9.9.1 Specifying the stack level: the 'z-index' property

              C.7.46 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

              C.7.47 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

              C.7.48 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

              C.7.49 Section 10.1 Definition of "containing block"

              C.7.50 Section 10.2 Content width: the 'width' property

              C.7.51 Section 10.2 Content width: the 'width' property

              C.7.52 Section 10.2 Content width: the 'width' property

              C.7.53 Section 10.5 Content height: the 'height' property

              C.7.54 Section 10.5 Content height: the 'height' property

              C.7.55 Section 10.6.7 'Auto' heights for block formatting context roots

              C.7.56 Section 10.7 Minimum and maximum heights: 'min-height' and 'max-height'

              C.7.57 Section 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

              C.7.58 Section 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

              C.7.59 Section 10.8.1 Leading and half-leading

              C.7.60 Section 10.8.1 Leading and half-leading

              C.7.61 Section 10.8.1 Leading and half-leading

              C.7.62 Section 11.1 Overflow and clipping

              C.7.63 Section 11.1.1 Overflow: the 'overflow' property

              C.7.64 Section 11.1.1 Overflow: the 'overflow' property

              C.7.65 Section 11.1.1 Overflow: the 'overflow' property

              C.7.66 Section 11.1.2 Clipping: the 'clip' property

              C.7.67 Section 12.5 Lists

              C.7.68 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.7.69 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.7.70 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.7.71 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.7.72 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.7.73 Section 13.2 Page boxes: the @page rule

              C.7.74 Section 13.2.2 Page selectors: selecting left, right, and first pages

              C.7.75 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

              C.7.76 Section 13.3.3 Allowed page breaks

              C.7.77 Section 15.3 Font family: the 'font-family' property

              C.7.78 Section 15.3.1 Generic font families

              C.7.79 Section 15.6 Font boldness: the 'font-weight' property

              C.7.80 Section 15.6 Font boldness: the 'font-weight' property

              C.7.81 Section 15.7 Font size: the 'font-size' property

              C.7.82 Section 16.1 Indentation: the 'text-indent' property

              C.7.83 Section 16.1 Indentation: the 'text-indent' property

              C.7.84 Section 16.2 Alignment: the 'text-align' property

              C.7.85 Section 16.2 Alignment: the 'text-align' property

              C.7.86 Section 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

              C.7.87 Section 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

              C.7.88 Section 16.4 Letter and word spacing: the 'letter-spacing' and 'word-spacing' properties

              C.7.89 Section 16.6 White space: the 'white-space' property

              C.7.90 Section 16.6.1 The 'white-space' processing model

              C.7.91 Section 16.6.1 The 'white-space' processing model

              C.7.92 Section 16.6.1 The 'white-space' processing model

              C.7.93 Section 17.2 The CSS table model

              C.7.94 Section 17.2.1 Anonymous table objects

              C.7.95 Section 17.2.1 Anonymous table objects

              C.7.96 Section 17.4 Tables in the visual formatting model

              C.7.97 Section 17.4 Tables in the visual formatting model

              C.7.98 Section 17.5.2.2 Automatic table layout

              C.7.99 Section 17.5.3 Table height algorithms

              C.7.100 Section 17.5.4 Horizontal alignment in a column

              C.7.101 Section B.2 Informative references

              C.7.102 Section D. Default style sheet for HTML 4

              C.7.103 Section E.2 Painting order

              C.7.104 Appendix G Grammar of CSS 2.1
            

          
            C.8 Changes since the working draft of 7 December 2010

            C.8.1 8.3.1 Collapsing margins

              C.8.2 10.8.1 Leading and half-leading

              C.8.3 10.3 Calculating widths and margins

              C.8.4 14.3 Gamma correction

              C.8.5 11.1.2 Clipping: the 'clip' property

              C.8.6 9.4.2 Inline formatting contexts

              C.8.7 10.3.2 Inline, replaced elements

              C.8.8 10.1 Definition of "containing block"

              C.8.9 13.2.2 Page selectors: selecting left, right, and first pages

              C.8.10 8.3.1 Collapsing margins

              C.8.11 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

              C.8.12 10.8.1 Leading and half-leading

              C.8.13 10.6.1 Inline, non-replaced elements

              C.8.14 9.5.1 Positioning the float: the 'float' property

              C.8.15 9.2.1.1 Anonymous block boxes

              C.8.16 5.12.1 The :first-line pseudo-element

              C.8.17 16.6 White space: the 'white-space' property

              C.8.18 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.8.19 9.7 Relationships between 'display', 'position', and 'float'

              C.8.20 9.4.2 Inline formatting contexts

              C.8.21 4.1.9 Comments

              C.8.22 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

              C.8.23 9.5.1 Positioning the float: the 'float' property

              C.8.24 9.3 Positioning schemes

              C.8.25 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

              C.8.26 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

              C.8.27 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

              C.8.28 10.4 Minimum and maximum widths: 'min-width' and 'max-width'

              C.8.29 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

              C.8.30 9.2.1.1 Anonymous block boxes

              C.8.31 17.4 Tables in the visual formatting model

              C.8.32 11.1.2 Clipping: the 'clip' property

              C.8.33 13.2 Page boxes: the @page rule

              C.8.34 4.1.1 Tokenization

              C.8.35 4.2 Rules for handling parsing errors

              C.8.36 3.1 Definitions

              C.8.37 4.3.4 URLs and URIs

              C.8.38 9.5 Floats

              C.8.39 11.1.1 Overflow: the 'overflow' property

              C.8.40 9.2.1.1 Anonymous block boxes

              C.8.41 16.2 Alignment: the 'text-align' property

              C.8.42 9.5 Floats

              C.8.43 9.4.2 Inline formatting contexts

              C.8.44 5.12 Pseudo-elements

              C.8.45 9.5 Floats

              C.8.46 9.5 Floats

              C.8.47 14.2.1 Background properties: 'background-color', 'background-image', 'background-repeat', 'background-attachment', 'background-position', and 'background'

              C.8.48 9.2.4 The 'display' property

              C.8.49 6.1.2 Computed values

              C.8.50 10.3.2 Inline, replaced elements

              C.8.51 Section 9.5.2 Controlling flow next to floats: the 'clear' property

              C.8.52 G.2 Lexical scanner

              C.8.53 Section 9.5.2 Controlling flow next to floats: the 'clear' property

              C.8.54 9.5 Floats

              C.8.55 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'
            
        

      付録 D. HTML 4のためのデフォルトスタイルシート

      
        付録 E. スタックコンテキストの詳説

        E.1 定義

          E.2 描画順序

          E.3 ノート
        

      付録 F. 全プロパティ表

      
        付録 G. CSS2.1の文法

        G.1 文法

          G.2 語彙スキャナ

          G.3 CSS2.1とCSS1のトークン化の比較

          G.4 実装ノート
        

      付録 I. 索引
    

  1 CSS 2.1仕様について

  
    目次

    1.1 CSS 2.1 vs CSS 2

      1.2 仕様を読むにあたって

      1.3 仕様の構成

      
        1.4 表記法

        1.4.1 文書言語の要素と属性

          
            1.4.2 CSSプロパティの定義

            1.4.2.1 値

              1.4.2.2 初期値

              1.4.2.3 適用対象

              1.4.2.4 継承性

              1.4.2.5 パーセント値

              1.4.2.6 メディアグループ

              1.4.2.7 算出値
            

          1.4.3 簡略プロパティ

          1.4.4 注記と実例

          1.4.5 画像と説明文
        

      1.5 謝辞
    

  1.1 CSS 2.1 vs CSS 2

  CSSコミュニティはCSS2が1998年に勧告となって以来、CSS2仕様とともに意味のある経験を得ている。CSS2仕様においての誤りは、その後さまざまなエラッタの発行によって修正されたが、経験に基づいて仕様を変更する機会がこれまでになかった。

  これらの問題の多くは今後のCSS3仕様によって対処される一方で、現状では、CSS2の実装と相互運用性を妨げている。CSS 2.1仕様は、この状況への対処を以下によって試みている:

  広く受け入れられ、実装されているCSS2との互換性を維持すること。

    発行されたすべてのCSS2のエラッタを組み込むこと。

    実装においてCSS2仕様と圧倒的に異なる箇所は、一般に受け入れられた慣行に従うよう仕様を変更すること。

    実装されていないという理由でCSSのコミュニティによって認められていないCSS2の機能を削除すること。CSS 2.1は、CSSの機能が無理なく広範囲にわたってHTMLやXML言語一般に（特定のXML言語だけのためでもなく、HTMLだけのためでもなく）実装されているものを反映することを目標とすること。

    CSS3によって廃止されるCSS2の機能を削除し、提案されたCSS3の機能の採用を奨励すること。

    CSS2を実装するために必要なプロパティ値が実装経験から明らかになったために、（ごく）少数の新しいプロパティ値を追加すること。
  このように、CSS2スタイルシートが必ずしもCSS 2.1と前方互換性があるとは限らないことが事実である一方、今日の適合したユーザエージェントを満足させつつ、将来にわたって前方互換性を維持する可能性が高くなることも事実である。前方互換性を破棄することが好ましいことではないものの、我々はCSS 2.1での改訂が価値ある強みをもつと信じる。

  CSS 2.1はCSS2から派生しており、CSS2の置換を意図する。CSS2の一部は、CSS 2.1においても不変である。一部は変更されており、そして削除されている。CSS2から削除された部分は、将来のCSS3仕様で使用されるかもしれない。将来の仕様はCSS 2.1を参照すべきである（ただし、CSS 2.1で削除されたCSS2の機能を必要とし、その上でそれらの機能のためにCSS2を参照する必要がある場合、つまり、削除された機能を含むCSS3モジュールの機能を参照する場合を除く）。

  1.2 仕様を読むにあたって

  この節は非規範的である。

  本仕様は2種類の読者を念頭においている。CSS著者とCSS実装者である。我々は、著者に対してCSSの実装の詳細が過度に登場することなく、効率的で魅力的、そしてアクセシブルなCSS文書を書くために必要なツールを著者に提供されることを本仕様において望んでいる。しかし、実装者は適合ユーザエージェントを作成するために必要なすべてを見出だすべきである。本仕様では、CSSの一般的な説明から始まり、読みすすめるにしたがって技術的かつ具体的な内容へと進んでいく。情報へのすばやいアクセスのために、電子版と印刷版の両方に、総目次、各章の冒頭での目次、そして索引による簡単なナビゲーションを提供している。

  本仕様は電子版と印刷版という2つの表現方法を念頭において執筆されている。電子版と印刷版が似たものであることは疑いないだろうが、読者は多少の相違点を見つけるだろう。たとえば、印刷版ではリンクは（いうまでもなく）動作せず、電子版ではページ番号は表示されない。食い違いがある場合は、電子版を文書の正式なバージョンとみなす。

  1.3 仕様の構成

  この節は非規範的である。

  本仕様は以下の章で構成される:

  2章: CSS 2.1の手引き

    この手引きは、CSS 2.1の簡潔なチュートリアルと、CSS 2.1の背後にある設計原則の考察を収録している。

    3-18章: CSS 2.1 リファレンスマニュアル

    リファレンスマニュアルの大部分は、CSS 2.1言語リファレンスで構成されている。このリファレンスでは、CSS 2.1スタイルシート（構文、プロパティ、プロパティ値）に何を入れることができるか、またユーザエージェントが適合要求するためにスタイルシートをどのように解釈しなければならないかを定義する。

    付録:

    付録は、聴覚スタイルシート（非規範的）、HTML 4のためのスタイルシート例、CSS2からの変更点、CSS2.1の文法、標準と情報を提供する参考文献の一覧、プロパティ表と総索引のふたつの索引に関する情報を含む。
  1.4 表記法

  1.4.1 文書言語の要素と属性

  CSSのプロパティおよび疑似クラス名はシングルクオートで区切る。

    CSSの値はシングルクオートで区切る。

    文書言語の属性名は小文字で記述し、ダブルクオートで区切る。
  1.4.2 CSSプロパティの定義

  各CSSプロパティの定義は、下記の主要情報の要約で始まる:

  
    'プロパティ名'

      
        値:  

              正当な値とその構文
            初期値:  

              初期値
            適用対象:  

              そのプロパティが適用される要素
            継承:  

              プロパティが継承されるかどうか
            パーセンテージ:  

              どのようにパーセント値を解釈するか
            メディア:  

              プロパティが適用されるメディアグループ
            算出値:  

              算出値を計算する方法
            
    

  1.4.2.1 値

  このパートは、名前が'プロパティ名'のプロパティに対して妥当な値の集合を規定する。プロパティ値は、1つ以上のコンポーネントを持つことができる。コンポーネント値の型は、いくつかの方法で指定される:

  キーワード値（たとえば、auto、discなど）。

    "<"と">"の間に出現する基本データ型（たとえば、<length>、<percentage>など）。電子版では、基本データ型の例は、各基本データ型の定義にリンクしている。

    同じ名前（たとえば<'border-width'>、<'background-attachment'>など）を持つプロパティと同じ値の範囲を持っている型。この場合、型名は"<"と">"の間に（引用符付きの完全な）プロパティ名となる（たとえば、<'border-width'>）。このような型は、値'inherit'を含まない。電子版では、非終端なこの型の例は対応するプロパティの定義にリンクしてある。

    非終端はプロパティと同じ名前を共有しない。この場合、非端末名は<border-width>のように、"<"と">"の間に出現する。<border-width>と<'border-width'>の間の差異に注意する。後者は前者の用語で定義されている。非終端の定義は、仕様中に非終端が最初に出現した近くに位置する。電子版では、この型の例は対応する値の定義にリンクしてある。
  これらの定義においてその他の単語は、引用符なしで（たとえばred）、文字通り現れなければならないキーワードである。スラッシュ（/）やコンマ（,）なども文字通りに出現しなければならない。

  コンポーネントの値は、次のようにプロパティ値に配置してよい:

  並置の語は、すべてが指定通りの順序で出現しなければならない。

    縦線（|）は2つ以上の選択肢を区切る: 厳密にそのうちの1つが出現しなければならない。

    二重縦線（||）は2つ以上の選択肢を区切る: 少なくとも1つ以上が任意の順序で出現しなければならない。

    二重アンパサンド（&&）は2つ以上のコンポーネントを区切る。すべてが指定通りの順序で出現しなければならない。

    角括弧（[]）はグループ化を示す。
  並置は二重アンパサンドよりも強く、二重アンパサンドは二重縦線よりも強く、二重縦線は縦線よりも強い。したがって次の2行は等価である:
  
    a b   |   c ||   d &&   e f
  [ a b ] | [ c || [ d && [ e f ]]]


  すべての型、キーワード、角括弧グループは、次の量指定子を付けてよい:

  アスタリスク（*）は、直前の型、ワード、グループの0回以上の出現を示す。

    正符号（+）は、直前の型、ワード、グループの1回以上の出現を示す。

    疑問符（?）は、直前のデータ型、ワード、グループの0回もしくは1回の出現を示す。

    波括弧内の数字の組（{A,B}）は、直前のデータ型、ワード、グループのA回以上B回以下の繰り返しを示す。
  次の例はさまざまな値の型を示す:

  
    値: N | NW | NE値: [ <length> | thick | thin ]{1,4}値: [<family-name> , ]* <family-name>値: <uri>?<color> [ / <color> ]?値: <uri> || <color>値: inset?&& [ <length>{2,4} && <color>?]
  

  付録G.2節で説明するように、コンポーネントの値はトークン単位で指定される。expr（訳注：Unix系OSのコマンド）製作物のコンポーネントにおいてトークン間の空白を許可するように、空白はプロパティ値のトークン間に出現してよい。

  注: 多くの場合、空白は実際にはトークン同士を区別するために、トークン間に必要とされるだろう。たとえば、値'1em2em'は、数字'1'と無効な単位識別子'em2em'とともに、単一のDIMENトークンとして構文解析されるだろう。この場合、2つの長さ'1em'と'2em'として構文解析されるよう空白は'2'の前に必要になるだろう。

  1.4.2.2 初期値

  この部分はプロパティの初期値を規定する。スタイルシートの指定値、継承値、初期値の相互関係についての情報はカスケードの節を参照のこと。

  1.4.2.3 適用対象

  この部分は、プロパティが適用される要素を示す。すべての要素は、全プロパティを所有しているとみなされるが、一部のプロパティはある要素のタイプでレンダリングの効果はない。たとえば、'clear'プロパティはブロックレベル要素にのみ作用する。

  1.4.2.4 継承性

  この部分はプロパティ値が先祖要素から継承されるかどうかを示す。スタイルシートの指定値、継承値、初期値の相互関係についての情報はカスケードの節を参照のこと。

  1.4.2.5 パーセント値

  この部分は、プロパティにパーセント値が現れた場合、どのように解釈すべきかを示す。ここに"利用不可"が登場する場合、プロパティはパーセント値を受け入れないことを意味する。

  1.4.2.6 メディアグループ

  この部分はプロパティが適用されるメディアグループを示す。メディアグループに関する情報は非規範的である。

  1.4.2.7 算出値

  この部分はプロパティの算出値を説明する。この定義がどのように使われるかについては算出値の節を参照のこと。

  1.4.3 簡略プロパティ

  プロパティの一部には簡略プロパティが存在する。これは、著者が複数のプロパティ値を1つのプロパティで指定できることを意味する。

  たとえば、'font'プロパティは'font-style'、'font-variant'、'font-weight'、'font-size'、'line-height'、'font-family'を一度にそろって設定できる簡略プロパティである。

  値が簡略プロパティから省略された場合、各"不足"プロパティは初期値が割り当てられる（カスケードの節を参照）。

  
    例:

    この例の複数のスタイル規則は:
    
h1 { 
  font-weight: bold; 
  font-size: 12pt;
  line-height: 14pt; 
  font-family: Helvetica; 
  font-variant: normal;
  font-style: normal;
}


    1つの簡略プロパティで書いてもよい:
    
h1 { font: bold 12pt/14pt Helvetica }


    この例では、'font-variant'と'font-style'は初期値を取る。
  

  1.4.4 注記と実例

  不正な使用法を説明する例はすべて、明確に"ILLEGAL EXAMPLE"とマークされている。

  DOCTYPE宣言のないHTMLはHTML 4.01 Strict DTDに適合するSGML文書の断片である[HTML4]。他のHTMLの例は、例で指定されたDTDに適合している。

  すべての注は参考情報にすぎない。

  例と注は仕様とCSSユーザエージェントのためにHTMLソースでマークされており、これらを特別な形で表示するだろう。

  1.4.5 画像と説明文

  電子版の仕様書でのほとんどの画像は、画像が何を表しているかの"長い説明"を添付している。長い説明へのリンクは画像のあとに"[説明]"を用いて示す。

  画像および長い説明は参考情報にすぎない。

  1.5 謝辞

  この節は非規範的である。

  CSS 2.1 is based on CSS2. See the acknowledgments section of CSS2 for the people that contributed to CSS2.

  We would like to thank the following people who, through their input and feedback on the www-style mailing list, have helped us with the creation of this specification: Andrew Clover, Bernd Mielke, C. Bottelier, Christian Roth, Christoph Päper, Claus Färber, Coises, Craig Saila, Darren Ferguson, Dylan Schiemann, Etan Wexler, George Lund, James Craig, Jan Eirik Olufsen, Jan Roland Eriksson, Joris Huizer, Joshua Prowse, Kai Lahmann, Kevin Smith, Lachlan Cannon, Lars Knoll, Lauri Raittila, Mark Gallagher, Michael Day, Peter Sheerin, Rijk van Geijtenbeek, Robin Berjon, Scott Montgomery, Shelby Moore, Stuart Ballard, Tom Gilder, Vadim Plessky, Peter Moulder, Anton Prowse, Gérard Talbot, Ingo Chao, Bruno Fassino, Justin Rogers, Boris Zbarsky, Garrett Smith, Zack Weinberg, Bjoern Hoehrmann, and the Open eBook Publication Structure Working Group Editors. We would also like to thank Gary Schnabl, Glenn Adams and Susan Lesch who helped proofread earlier versions of this document.

  In addition, we would like to extend special thanks to Elika J. Etemad, Ada Chan and Boris Zbarsky who have contributed significant time to CSS 2.1, and to Kimberly Blessing for help with the editing.

  Many thanks also to the following people for their help with the test suite: Robert Stam, Aharon Lanin, Alan Gresley, Alan Harder, Alexander Dawson, Arron Eicholz, Bernd Mielke, Bert Bos, Boris Zbarsky, Bruno Fassino, Daniel Schattenkirchner, David Hammond, David Hyatt, Eira Monstad, Elika J. Etemad, Gérard Talbot, Gabriele Romanato, Germain Garand, Hilbrand Edskes, Ian Hickson, James Hopkins, Justin Boss, L. David Baron, Lachlan Hunt, Magne Andersson, Marc Pacheco, Mark McKenzie-Bell, Matt Bradley, Melinda Grant, Michael Turnwall, Ray Kiddy, Richard Ishida, Robert O'Callahan, Simon Montagu, Tom Clancy, Vasil Dinkov, … and all the contributors to the CSS1 test suite.

  Working Group members active during the development of this specification: César Acebal (Universidad de Oviedo), Tab Atkins Jr. (Google, Inc.), L. David Baron (Mozilla Foundation), Bert Bos (W3C/ERCIM), Tantek Çelik (W3C Invited Experts), Cathy Chan (Nokia), Giorgi Chavchanidze (Opera Software), John Daggett (Mozilla Foundation), Beth Dakin (Apple, Inc.), Arron Eicholz (Microsoft Corp.), Elika J. Etemad (W3C Invited Experts), Simon Fraser (Apple, Inc.), Sylvain Galineau (Microsoft Corp.), Daniel Glazman (Disruptive Innovations), Molly Holzschlag (Opera Software), David Hyatt (Apple, Inc.), Richard Ishida (W3C/ERCIM), John Jansen (Microsoft Corp.), Brad Kemper (W3C Invited Experts), Håkon Wium Lie (Opera Software), Chris Lilley (W3C/ERCIM), Peter Linss (HP), Markus Mielke (Microsoft Corp.), Alex Mogilevsky (Microsoft Corp.), David Singer (Apple Inc.), Anne van Kesteren (Opera Software), Steve Zilles (Adobe Systems Inc.), Ian Hickson (Google, Inc.), Melinda Grant (HP), Øyvind Stenhaug (Opera Software), and Paul Nelson (Microsoft Corp.).

  2 CSS 2.1の手引き

  
    目次

    2.1 HTMLのための簡潔なチュートリアル

      2.2 XMLのための簡潔なチュートリアル

      
        2.3 CSS 2.1の処理モデル

        2.3.1 キャンバス

          2.3.2 CSS 2.1アドレス指定モデル
        

      2.4 CSS設計原則
    

  2.1 HTMLのための簡潔なチュートリアル

  この節は非規範的である。

  このチュートリアルでは、単純なスタイルシートの設計がいかに容易であるかを示す。このチュートリアルに関しては、わずかなHTML[HTML4]と基本的なDTP用語についての知識が必要である。

  小さなHTML文書から始める:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
  <TITLE>Bach's home page</TITLE>
  </HEAD>
  <BODY>
    <H1>Bach's home page</H1>
    <P>Johann Sebastian Bach was a prolific composer.
  </BODY>
</HTML>


  H1要素のテキストの色を赤に設定するには、次のCSS規則を記述するとよい:
  
  h1 { color: red }


  CSS規則は、セレクタ（'h1'）および宣言（'color:red'）という2つの主要部分から構成される。HTMLでは、要素名は大文字と小文字を区別しないため、'h1'は'H1'とまったく同じ働きをする。宣言は2つの要素、プロパティ名（'color'）とプロパティ値（'red'）を持つ。上の例は、HTML文書のレンダリングに必要なプロパティのたった1つに対して制御を試したにすぎないとはいえ、それだけでスタイルシートだと言える。他のスタイルシートと組み合わせることで（CSSの基本的な機能の1つは、スタイルシートを組み合わせることにある）、最終的な見栄えが決定される。

  HTML 4仕様は、スタイルシート規則をHTML文書内に、または外部スタイルシートを経由して指定する方法を定義する。スタイルシートを文書に埋め込むには、STYLE要素を使用する:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
  <TITLE>Bach's home page</TITLE>
  <STYLE type="text/css">
    h1 { color: red }
  </STYLE>
  </HEAD>
  <BODY>
    <H1>Bach's home page</H1>
    <P>Johann Sebastian Bach was a prolific composer.
  </BODY>
</HTML>


  柔軟性を最大限に高めるために、文書作成者は外部スタイルシートを指定することを推奨する。外部スタイルシートは、HTML文書ソースを修正することなくスタイルシートを変更することができ、また複数の文書間でスタイルシートを共有することができる。外部スタイルシートにリンクするには、LINK要素を使用する:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
  <TITLE>Bach's home page</TITLE>
  <LINK rel="stylesheet" href="bach.css" type="text/css">
  </HEAD>
  <BODY>
    <H1>Bach's home page</H1>
    <P>Johann Sebastian Bach was a prolific composer.
  </BODY>
</HTML>


  LINK要素は次の事項を指定する:

  リンクの種類が"stylesheet"であること。

    スタイルシートの位置が"href"属性を経由すること。

    リンクされたスタイルシートのタイプが"text/css"であること。
  スタイルシートと構造化マークアップの間の密接な関係を示すために、このチュートリアルではSTYLE要素を使用しつづける。より多くの色を追加してみよう:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
  <TITLE>Bach's home page</TITLE>
  <STYLE type="text/css">
    body { color: black; background: white }
    h1 { color: red; background: white }
  </STYLE>
  </HEAD>
  <BODY>
    <H1>Bach's home page</H1>
    <P>Johann Sebastian Bach was a prolific composer.
  </BODY>
</HTML>


  今、スタイルシートは4つの規則を含んでいる: 最初の2つは、BODY要素の色と背景を設定する（テキストの色と背景色を同時に設定することはよいアイデアといえる）と同時に、最後の2つはH1要素の色と背景を設定している。P要素には色が設定されていないので、親要素、つまりBODY要素から色を継承することになる。H1要素もまたBODY要素の子要素であるが、2番目の規則が継承値を上書きする。CSSでは、異なる値の間でこのような衝突がたびたびあるが、本仕様はそれらを解決する方法を説明する。

  CSS 2.1は、'color'を含む90以上のプロパティがある。その他のプロパティも見てみよう:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
  <TITLE>Bach's home page</TITLE>
  <STYLE type="text/css">
    body { 
      font-family: "Gill Sans", sans-serif;
      font-size: 12pt;
      margin: 3em; 
    }
  </STYLE>
  </HEAD>
  <BODY>
    <H1>Bach's home page</H1>
    <P>Johann Sebastian Bach was a prolific composer.
  </BODY>
</HTML>


  最初に気づくことは、複数の宣言が波括弧で囲まれたブロック内でグループ化され（{...}）、セミコロンで区切られていることだろう。しかし、最後の宣言はセミコロンがついてもよい。

  BODY要素の最初の宣言は、"Gill Sans"フォントファミリを設定している。このフォントが利用できない場合、ユーザーエージェント（たいてい"ブラウザ"と呼ばれる）は'sans-serif'フォントファミリを使用するだろう。これは5つある総称フォントファミリのうちの1つで、すべてのユーザーエージェントが認識するものである。BODY要素の子要素は、'font-family'プロパティの値を継承する。

  2番目の宣言は、BODY要素のフォントサイズを12ポイントに設定している。"ポイント"という単位は、一般にフォントサイズやその他の長さの値を示すために、印刷をもとにした組版において用いられる。 これは絶対単位の例であり、絶対単位とは環境に依存しない尺度である。

  3番目の宣言は相対単位を用いている。これは、環境に依存する単位である。"em"という単位は要素のフォントサイズを参照する。この場合、BODY要素の周囲のマージンはフォントサイズの3倍幅のある数値となる。

  2.2 XMLのための簡潔なチュートリアル

  この節は非規範的である。

  CSSは、たとえば拡張可能なマークアップ言語[XML10]のアプリケーションといった、いかなる構造化文書形式でも利用できる。実際、著者はユーザーエージェントが表示する方法を知らないXML要素をマークアップすることができるので、XMLはHTML以上にスタイルシートに依存する。

  ここに簡単なXMLの断片がある:
  
<ARTICLE>
  <HEADLINE>Fredrick the Great meets Bach</HEADLINE>
  <AUTHOR>Johann Nikolaus Forkel</AUTHOR>
  <PARA>
    One evening, just as he was getting his 
    <INSTRUMENT>flute</INSTRUMENT> ready and his
    musicians were assembled, an officer brought him a list of
    the strangers who had arrived.
  </PARA>
</ARTICLE>


  この断片を文書に適したスタイルで表示させるために、要素がインラインレベル（すなわち改行をさせない）であるか、ブロックレベル（すなわち改行をさせる）であるかを最初に宣言しなければならない。
  
INSTRUMENT { display: inline }
ARTICLE, HEADLINE, AUTHOR, PARA { display: block }


  最初の規則でINSTRUMENTがインラインであると宣言し、コンマで区切られたセレクタの羅列である2番目の規則は、他のすべての要素がブロックレベルであると宣言している。XMLでの要素名は大文字と小文字を区別する。そのため、小文字で書かれたセレクタ（たとえば、'instrument'）と大文字で書かれたもの（たとえば、'INSTRUMENT'）は異なるものとなる。

  XML文書にスタイルシートをリンクさせる1つの方法は、処理命令を使用することである:
  
<?xml version="1.0" encoding="UTF-8"?>
<ARTICLE>
  <HEADLINE>Fredrick the Great meets Bach</HEADLINE>
  <AUTHOR>Johann Nikolaus Forkel</AUTHOR>
  <PARA>
    One evening, just as he was getting his 
    <INSTRUMENT>flute</INSTRUMENT> ready and his
    musicians were assembled, an officer brought him a list of
    the strangers who had arrived.
  </PARA>
</ARTICLE>


  視覚ユーザーエージェントは上記の例を次のように書式を設定する:

  
       [説明]
  

  単語"flute"は段落内にとどまっていることに注目する。これは、インライン要素INSTRUMENTの内容のためである。

  まだ、テキストは意図したとおりには整形されてない。たとえば、見出しは残りのテキストよりも大きなフォントサイズにすべきだろうし、著者の名前をイタリック体で表示させたいだろう:
  
INSTRUMENT { display: inline }
ARTICLE, HEADLINE, AUTHOR, PARA { display: block }
HEADLINE { font-size: 1.3em }
AUTHOR { font-style: italic }
ARTICLE, HEADLINE, AUTHOR, PARA { margin: 0.5em }


  視覚ユーザーエージェントは上記の例を次のように書式を設定する:

  
       [説明]
  

  スタイルシートにより多くの規則を追加することで、文書の表現をより向上させることができるだろう。

  2.3 CSS 2.1の処理モデル

  この節は小節も含めて非規範的である。

  この節は、ユーザーエージェントがCSSをサポートする動作方法として可能な1つのモデルを提示する。これは抽象的なモデルにすぎない。実際の実装は異なってよい。

  このモデルでは、ユーザーエージェントは以下の操作によってソースを処理する:

  ソース文書を構文解析し、文書ツリーを作成する。

    ターゲットメディアタイプを識別する。

    ターゲットメディアタイプに指定された文書に関連する、すべてのスタイルシート取り出す。

    ターゲットメディアタイプに適用可能なすべてのプロパティに単一の値を割り当てることにより、文書ツリーのすべての要素に注釈を付ける。プロパティはカスケーディングと継承の節で説明する手順にしたがって値を割り当てられる。

      値の計算の一部は、ターゲットメディアタイプに適切な整形アルゴリズムに依存する。たとえば、ターゲットメディアが画面であれば、ユーザエージェントは視覚整形モデルを適用する。
    

    注釈付きの文書ツリーから、整形構造を生成する。整形構造は文書ツリーとしばしば酷似するが、特に著者が擬似要素または生成内容を使用した場合、著しく異なることもある。まず、整形構造は少しも"ツリー状"である必要はない―構造の特性は実装に依存する。 次に、整形構造は文書ツリー以上または以下の情報を含んでもよい。たとえば、文書ツリー内のある要素が'display'プロパティに'none'の値を持つ場合、その要素は整形構造には何も生成しないだろう。一方リスト要素は、整形構造ではより多くの情報を生成することができる:リスト要素の内容とリストスタイルの情報（たとえば、黒丸の画像）。

      CSSユーザーエージェントはこの段階で文書ツリーを改変しないことに注意されたい。とくに、スタイルシートに起因する内容生成は、文書言語プロセッサにフィードバックされることはない（たとえば、再解析のために）。
    

    整形構造をターゲットメディアに転送する（たとえば、結果を印刷する、画面上に表示する、音声として表現する、など）。
  2.3.1 キャンバス

  すべてのメディアに対して、用語キャンバスは"整形構造がレンダリングされる空間"を表す。キャンバスは各次元について無限空間であるが、一般的にレンダリングは、ターゲットメディアによって設置されたキャンバスの有限範囲で行われる。たとえば、画面表示をするユーザーエージェントは、一般的に最小幅を設け、ビューポートの寸法に基づく初期幅を選択する。ページ出力をするユーザーエージェントは一般的に幅と高さに制限を設ける。聴覚ユーザーエージェントは音声空間に関する制限がされても、時間の制限はされないだろう。

  2.3.2 CSS 2.1アドレス指定モデル

  CSS 2.1セレクタおよびプロパティは、文書またはユーザーエージェントの以下の部分の参照をスタイルシートに割り当てる:

  文書ツリーの要素と要素間にある関係（セレクタの節を参照）。

    文書ツリー内の要素の属性と属性値（属性セレクタの節を参照）。

    要素内容の一部（:first-lineおよび:first-letter擬似要素を参照）。

    特定の状態にある文書ツリーの要素（擬似クラスの節を参照）。

    文書がレンダリングされるキャンバスの外観。

    いくつかのシステム情報（ユーザーインターフェイスの節を参照）。
  2.4 CSS設計原則

  この節は非規範的である。

  以前のCSS2およびCSS1と同様に、CSS2.1は一連の設計原則に基づいている:

  
      前方および後方互換性。CSS 2.1のユーザーエージェントはスタイルシートを解釈できるだろう。CSS1ユーザーエージェントはCSS 2.1スタイルシートを読み、解釈できない部分は破棄するだろう。また、CSSをサポートしないユーザーエージェントでも、スタイルの拡張された文書を表示できるだろう。もちろん、CSSによって可能となったスタイルの機能強化はレンダリングされないが、すべての内容は表示されるだろう。
    

    
      構造化文書の補完。スタイルシートは、マークアップテキストにスタイル情報を与えることで、構造化文書（たとえば、HTMLやXMLアプリケーション）を補完する。マークアップに影響を与えることなくスタイルシートを容易に変更できるはずである。
    

    
      ベンダー、プラットフォーム、デバイスからの独立。スタイルシートは、ベンダー、プラットフォーム、デバイスからの独立を保つ文書を可能にする。スタイルシート自身もまたベンダーやプラットフォームから独立しているが、CSS 2.1はある種のデバイス（たとえば、プリンタ）を対象にしたスタイルシートを認めている。
    

    
      保全性。文書からスタイルシートを指定することによって、ウェブマスターがサイトのメンテナンスを簡素化し、サイトのいたるところで一貫した外観を保持する。たとえば、背景色を変更する場合、ただ1つのファイルを変更するだけでよい。
    

    
      容易性。CSSは簡潔な人間が読み書き可能なスタイル言語である。CSSプロパティは可能な限り最大の範囲で相互に独立するよう保持され、通常、ある効果を達成する唯一の方法が存在する。
    

    
      ネットワークの性能。CSSは内容を表示するための簡素なエンコーディングを提供する。レンダリング効果を得るためによく用いられる画像や音声ファイルと比べて、スタイルシートは内容量を最も減少させる。また、より少ないネットワーク接続は、さらなるネットワークパフォーマンスの増加をもたらす。
    

    
      柔軟性。CSSはさまざまな方法で内容に適用できる。キーポイントとなる特徴は、（ユーザーエージェントの）デフォルトスタイルシート、ユーザースタイルシート、リンクされたスタイルシート、文書のヘッダ、文書の本体にある要素の属性、といった方法で指定されたスタイル情報をカスケードする機能である。
    

    
      豊かさ。レンダリング効果の豊富な設定を著者に提供することで、表現メディアとしてのWebの豊かさが向上する。デザイナーは、DTPやスライドショー・アプリケーションに共通して見られるような機能性を待ち望んでいる。要求された一部のレンダリング効果はデバイスの独立性と矛盾するが、CSS 2.1はデザイナーの要求を容認するのに大きな役割を果たす。
    

    
      他言語との結びつき。本仕様に記述された一連のCSSプロパティは、視覚および聴覚表現のための一貫性のある整形モデルを構成する。この整形モデルはCSS言語を通してアクセスされるが、他の言語に結びつけることも可能である。たとえば、JavaScriptプログラムは、ある要素の'color'プロパティの値を動的に変化させることができる。
    

    
      アクセシビリティ。いくつものCSSの機能は、障碍を持つユーザーをWebによりアクセスしやすくする。

      フォントの外観を制御するプロパティは、著者がアクセスできないビットマップのテキスト画像を排除することを可能にする。

        位置調整プロパティは、レイアウトを押し込むためのマークアップトリック（たとえば、見えない画像）を排除することを可能にする。

        !important規則は特定の見栄え要件のためにユーザーが著者のスタイルシートを上書きできることを意味する。

        すべてのプロパティにとって'inherit'値はカスケーディングの一般性を向上させ、より容易で一貫性のあるスタイル調整を可能にする。

        braille、embossed、ttyメディアグループなどの改良されたメディアサポートは、ユーザや著者にページやデバイスの調整を可能にする。
      
        注。 CSSやHTMLを使用するアクセシブルな文書の設計についてのより詳しい情報は、[WCAG20]を参照のこと。
      
    
  
  3 適合性: 必要条件と推奨事項

  
    目次

    3.1 定義

      3.2 ユーザエージェントの適合性

      3.3 エラーの処理方法

      3.4 text/css content-type
    

  3.1 定義

  本文書での"MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"、"OPTIONAL"のキーワードはRFC 2119に示されたとおりに解釈される（[RFC2119]参照）。しかし、読みやすさのために、これらの単語は本仕様で大文字のみで出現しない。

  折に触れて、本仕様は著者やユーザーエージェントにとっての都合のよい事例を推奨する。これらの推奨事項は規範的なものではなく、推奨事項の実現をせずとも本仕様に適合する。これらの推奨事項は、"推奨する…"、"本仕様は…推奨する"といった、もしくはそれに準じる表現を含む。

  機能がdeprecated（廃止）としてマークされているもの（具体的には'aural'キーワード）やCSS3で廃止予定とされているもの（具体的にはシステム色）は、適合性に影響することはない。（たとえば、'aural'は非規範的としてマークされているので、ユーザーエージェントはサポートする必要がない。システム色は規範的であり、ユーザーエージェントはサポートする必要がある。）

  付録も含めた本仕様のすべての節は、特に断りのない限り規範的である。

  例と注は規範的ではない。

  
    例:

    例は、常に単語"例"が文頭近くにあり（"例:"、"以下の例は…"、"たとえば"など） この段落のように栗色（マルーン）で表示する。
  

  
    注は、単語"注"で始まり、この段落のように字下げした緑色で表示する。
  

  図は説明のためだけのものにすぎない。明示的に指定しない限り、規範的なレンダリングではない。

  スタイルシート

    
      文書の見栄えを指定した一連の文。

      スタイルシートは、著者、ユーザー、ユーザーエージェントの3つの異なる出自を持つことができる。これらの相互作用は、カスケーディングと継承の節で説明される。
    

    妥当なスタイルシート

    
      スタイルシートの妥当性は、スタイルシートに用いるCSSのレベルに依存する。すべての妥当なCSS1スタイルシートはCSS 2.1スタイルシートとして妥当だが、いくつかCSS1からの変更は、少数のCSS1スタイルシートがCSS 2.1においてやや異なる意味を持つことがある。CSS2のいくつかの機能はCSS 2.1の一部でなく、その結果、すべてのCSS2スタイルシートが妥当なCSS 2.1スタイルシートとは限らない。

      妥当なCSS 2.1スタイルシートはCSS 2.1の文法に従って記述されなければならない。さらに、@規則とプロパティ名およびプロパティ値は本仕様で定義されたもののみを含まなければならない。不正な（妥当でない）@規則、プロパティ名、プロパティ値が1つでも存在すれば妥当ではない。
    

    ソース文書

    1つ以上のスタイルシートが参照する文書のこと。文書は、要素のツリーとして表現される言語でエンコードされている。各要素は、要素の種類、任意な多数の属性および（場合によって空の）内容を識別する名前で構成される。たとえば、ソース文書はXMLまたはSGMLが考えられる。

    文書言語

    ソース文書（たとえば、HTMLやXHTML、SVG）の符号化言語。CSSは文書言語の見栄えに使われ、CSSは文書言語の根本的な意味を変更しない。

    要素

    （SGML用語。[ISO8879]を参照。）文書言語の主要な構成要素。ほとんどのCSSスタイルシートの規則は、要素のレンダリングされるべき方法を指定するために、これら要素の名前（たとえば、HTMLでのP、TABLE、OLなど）を使用する。

    置換要素

    
      要素の内容がCSS整形モデルの範囲外であるもの。たとえば画像や埋め込み文書、アプレットなど。たとえば、HTMLのIMG要素の内容は多くの場合"src"属性が指定する画像に置換される。置換要素は多くの場合、固有の長さ、固有の高さ、固有の比率といった固有の次元をもつ。たとえば、ビットマップの画像は絶対単位（固有の比率を明確に規定できることから）で指定された固有の幅と高さを持つ。 一方、他の文書は固有の寸法（たとえば、何も書いていないHTML文書）を持つとは限らない。

      ユーザーエージェントは、これらの寸法がサードパーティに機密情報を漏洩してると考えられる場合、固有の寸法を1つも持たない置換要素を検討してよい。たとえば、HTML文書がユーザーの銀行残高に応じて固有の大きさを変更する場合、ユーザーエージェントはリソースの固有の寸法を持たなかったかのように振る舞うことを望む。

      置換要素の内容は、CSSレンダリングモデルでは考慮されない。
    

    固有の寸法

    要素自身によって定義された幅と高さで、周囲に影響されないもの。CSSは固有の寸法を発見する方法を定義しない。CSS 2.1では、置換要素のみが固有の寸法を伴うと考える。信頼性のある解像度情報を持たないラスタ画像の場合、画像ソースピクセルあたり1ピクセル単位であると仮定しなければならない。

    属性

    要素と名前で構成され、そして（テキストの）値に関連付けられた値。

    内容

    内容は、ソース文書内の要素と関連付けられる。空と呼ばれる場合のいくつかの要素は内容を持たない。要素の内容は、それらの下位要素の親と要素が呼ばれる場合に、テキストや多数の下位要素を含むことができる。

    無視する

    この用語は、本仕様で2つの若干異なる意味を持つ。第一に、CSSパーサがスタイルシート内で未知または不正な構文を検出した場合、CSSパーサは特定の規則に従う必要がある。その後、パーサはスタイルシートの特定の部分を無視する必要がある。宣言とプロパティ、構文解析エラー規則、サポートしない値の節で説明される、一部の厳密な規則は無視しなければならない。また用語"ignore"が出現するテキスト内で説明されることがある。第二に、構文が正当であっても、ユーザーエージェントは、スタイルシート内であるプロパティや値を無視してよい（場合によっては、しなければならない）。たとえば、テーブルの列要素は列のフォントに影響を与えることができず、その結果フォントプロパティは無視しなければならない。

    レンダリング内容

    関連するスタイルシートにしたがって要素に適用された、レンダリング後の要素の内容。どのように置換要素の内容がレンダリングされるかは、本仕様で定義しない。レンダリング内容は要素の代替テキスト（たとえば、XHTMLの"alt"属性値）であってもよく、黒丸や番号付けなどのスタイルシートによって暗黙的または明示的に挿入された項目を含んでよい。

    文書ツリー

    ソース文書でエンコードされた文書のツリー。ツリーの各要素は、ルート要素を除き、必ず1つのみの親を持つ。

    子

    BがAの親である場合に限り、ある要素Aは要素Bの子であるという。

    子孫

    (1)AがBの子である、または(2)Aが、Bの子孫である要素Cの子、のいずれかであるとき、ある要素Aは、要素Bの子孫という。

    祖先

    BがAの子孫である場合に限り、ある要素Aは要素Bの祖先という。

    兄弟

    BとAが同一の親要素を共有する場合に限って、ある要素Aは要素Bの兄弟という。文書ツリーでBの前に現れる場合、要素Aは兄という。文書ツリーでAの前に現れる場合、要素Bは弟という。

    先行要素

    (1)AがBの祖先であるか、または(2)Bの兄に当てはまる場合にのみ、ある要素Aは要素Bの先行要素という。

    後行要素

    BがAの先行要素である場合に限り、要素Aは要素Bの後行要素という。

    著者

    著者とは、文書および関連するスタイルシートを記述する人である。オーサリングツールとは、スタイルシートを生成するユーザーエージェントである。

    ユーザー

    ユーザーとは、文書および文書のスタイルシートを見る、聞く、別の方法で使用するユーザーエージェントと情報をやりとりする人のことである。ユーザーは、自分好みにエンコードした個人のスタイルシートを用意してよい。

    ユーザーエージェント（UA）

    ユーザーエージェントは、文書言語で記述された文書を解釈し、本仕様書の用語に従って関連するスタイルシートを適用する任意のプログラムである。ユーザーエージェントは、文書を表示したり、音声読み上げしたり、印刷したり、別のファイル形式に変換したりしてよい。

    HTMLユーザーエージェントは、1つ以上のHTML仕様をサポートするものである。HTMLではなくXHTML[XHTML]をサポートするユーザーエージェントは、本仕様に適合する意味でHTMLユーザーエージェントとはみなさない。

    プロパティ

    CSSは、プロパティと呼ばれる有限集合のパラメータを定義する。プロパティは、文書のレンダリングを割り当てるものである。各プロパティは名前（たとえば、'color'、'font'、'border'）と値（たとえば、'red'、'12pt Times'、'dotted'）を持つ。プロパティは、特異性、カスケーディング、継承の仕組み（プロパティ値とカスケーディング、継承の割り当ての節を参照）によって、表示される文書のさまざまな部分および文書上のページに付属している。
  
    HTMLで記述されたソース文書の例を以下に示す:
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>   
  <TITLE>My home page</TITLE>
  <BODY>
    <H1>My home page</H1>
    <P>Welcome to my home page! Let me tell you about my favorite
        composers:
    <UL>
      <LI> Elvis Costello
      <LI> Johannes Brahms
      <LI> Georges Brassens
    </UL>
  </BODY>
</HTML>


    これは下記のツリーに帰着する:

    
         [説明]
    

    HTML 4の定義によれば、たとえ"head"タグが文書ソース中に存在しなくても、HEAD要素は構文解析中に推定され、文書ツリーの一部となる。同様に、</p>や</li>タグがソース中に存在しないにもかかわらず、どこでP要素やLI要素が終了するかをパーサは認識する。

    XHTML（および他のXMLベースの言語）で記述された文書は異なる動作をする: 推定される要素は一切存在せず、すべての要素は終了タグを持たなければならない。
  

  3.2 ユーザエージェントの適合性

  この節では、CSS 2.1仕様に限定した適合性を定義する。将来におけるCSSの他のレベルは、異なる機能集合に準拠することをユーザーエージェントに対して実装するよう要求してよい。

  一般に、本仕様に適合を主張するユーザエージェントは、以下の項目は遵守しなければならない。

  1つ以上のCSS 2.1のメディアタイプを認識しなければならない。

    各ソース文書について、認識されたメディアタイプに適切なすべての関連するスタイルシートの取得を試みなければならない。すべての関連するスタイルシートを取得できない（たとえば、ネットワークのエラーのために）場合は、取得できたスタイルシートを用いて文書を表示しなければならない。

    本仕様に従ってスタイルシートを解析しなければならない。特に、すべての@規則、ブロック、宣言、およびセレクタを認識しなければならない（CSS 2.1の文法を参照）。ユーザーエージェントがサポートするメディアタイプに有効なプロパティを検出した場合、ユーザエージェントはプロパティの定義に従って値を解析しなければならない。これは、ユーザエージェントがすべての妥当な値を引き受けなければならず、また不正な値を持つ宣言を無視しなければならないことを意味する。ユーザーエージェントは、サポートしないメディアタイプに適用される規則を無視しなければならない。

    文書ツリー内の各要素に対して、ユーザーエージェントはプロパティの定義とカスケードと継承の規則に従って、すべてのプロパティの値を割り当てなければならない。

    ソース文書に代替スタイルシートの指定（たとえば、HTML 4[HTML4]の"alternate"キーワードなど）が付属している場合、ユーザーエージェントは、ユーザーにスタイルシートについての設定の選択を許可しなければならない。

    ユーザーエージェントは、ユーザーが著者スタイルシートの影響を切ることができるようにしなければならない。
  しかし、すべてのユーザエージェントが全項目を順守しなければならないということではない:

  任意のコンテンツをレンダリングすることなく、スタイルシートを読み込むアプリケーション（たとえば、CSS 2.1バリデータ）は項目1-3を順守しなければならない。

    オーサリングツールは妥当なスタイルシートの出力のみが要求される。

    関連するスタイルシートで文書をレンダリングするユーザエージェントは、項目1-6を順守し、本仕様書に記載されているメディア固有の要件に従って文書をレンダリングしなければならない。ユーザエージェントによって要求された場合、値を近似してよい。
  特定のデバイスの制限のために本仕様の一部を実装することができないユーザエージェント（たとえば、ユーザエージェントはモノクロのモニタやページで色をレンダリングすることはできない）は、不適合を意味しない。

  ユーザーエージェントは、ユーザーにユーザースタイルシートを含むファイルを指定できるようにしなければならない。ファイルの書き込みまたは指定の手段を持たない任意のデバイスで実行するユーザーエージェントは、この要件から免除される。さらに、ユーザーエージェントはユーザー設定を指定するために他の手段を提供することができる。たとえばGUIを介するなど。

  CSS 2.1は、プロパティがフォームコントロールおよびフレームに適用されるかどうか、またどのようにCSSがスタイルに使用されるかを定義しない。ユーザエージェントは、これらの要素にCSSプロパティを適用してよい。著者は実験的なサポートとして扱うことが推奨される。CSSの将来のレベルはさらにこれを規定する可能性がある。

  3.3 エラーの処理方法

  一般に、本文書は仕様全体でのエラーの処理方法の動作を明確に規定する。例として、構文解析エラーの処理規定を参照のこと。

  3.4 text/css content-type

  別々のファイルに存在するCSSスタイルシートは、インターネットを通して、符号化情報を伴ったバイト列として送信される。メッセージ実体と呼ばれる伝送構造は、RFC 2045およびRFC 2616で定義される（[RFC2045]および[RFC2616]を参照）。"text/css"のcontent-typeと一体になってメッセージ実体は独立したCSS文書を意味する。"text/css"content-typeはRFC 2318に登録されている（[RFC2318]）。

  4 構文と基本データ型

  
    目次

    
        4.1 構文

        4.1.1 トークン化

          
            4.1.2 キーワード

            4.1.2.1 ベンダー固有の拡張

              4.1.2.2 参考情報の歴史的なノート
            

          4.1.3 文字と活字ケース

          4.1.4 文

          4.1.5 @規則

          4.1.6 ブロック

          4.1.7 規則集合、宣言ブロック、セレクタ

          4.1.8 宣言とプロパティ

          4.1.9 コメント
        

      4.2 構文解析エラーの処理規定

      
        4.3 値

        4.3.1 整数値と実数値

          4.3.2 長さ

          4.3.3 パーセント値

          4.3.4 URLおよびURI

          4.3.5 カウンタ

          4.3.6 色

          4.3.7 文字列

          4.3.8 サポートしない値
        

      
        4.4 CSSスタイルシートの表現

        4.4.1 文字符号化で表現できない文字を参照する
        
    

  4.1 構文

  この章では、（CSS 2.1を含む）CSSの全レベルに共通の文法（および、前方互換な構文解析規則）を説明する。CSSの将来の改訂は、さらなる構文上の制約を追加するかもしれないが、このコア構文に忠実だろう。

  次に述べる説明は規範的である。また、付録Gに示す規範的な文法規則により補完される。

  本仕様では、式の"直前"または"直後"は、空白やコメントが間に入らないことを意味する。

  4.1.1 トークン化

  CSSの全レベル―レベル1、レベル2、将来のレベル―は、同じコア構文を使用する。これにより、ユーザーエージェントは、作成された当時に存在しなかったCSSのレベルで記述されたスタイルシートを（完全に理解できないものの）解析することができる。デザイナーは、CSSの最新レベルが持つ可能性を行使しつつ、古いユーザーエージェントで動作するスタイルシートを作成することができる。

  字句レベルでは、CSSスタイルシートはトークンの文字列で構成されている。CSSのトークンのリストは以下のとおりである。定義は、Lexスタイルの正規表現を使用した。8進コードは、ISO 10646（[ISO10646]）への参照である。複数の一致がある場合には、Lexのように最長一致のトークンを決定する。

  トークン

        定義
      
          
      IDENT

        {ident}
      ATKEYWORD

        @{ident}
      STRING

        {string}
      BAD_STRING

        {badstring}
      BAD_URI

        {baduri}
      BAD_COMMENT

        {badcomment}
      HASH

        #{name}
      NUMBER

        {num}
      PERCENTAGE

        {num}%
      DIMENSION

        {num}{ident}
      URI

        url\({w}{string}{w}\)
        |url\({w}([!#$%&*-\[\]-~]|{nonascii}|{escape})*{w}\)
      UNICODE-RANGE

        u\+[0-9a-f?]{1,6}(-[0-9a-f]{1,6})?
      CDO

        <!--
      CDC

        -->
      :

        :
      ;

        ;
      {

        \{
      }

        \}
      (

        \(
      )

        \)
      [

        \[
      ]

        \]
      S

        [ \t\r\n\f]+
      COMMENT

        \/\*[^*]*\*+([^/*][^*]*\*+)*\/
      FUNCTION

        {ident}\(
      INCLUDES

        ~=
      DASHMATCH

        |=
      DELIM

        上の規則にマッチしなかったすべての他の文字で、単一引用符でも二重引用符でもくくられていないもの
      上記の波括弧（{}）内のマクロは、以下のように定義される。

  マクロ

        定義
      
          
      ident

        [-]?{nmstart}{nmchar}*
      name

        {nmchar}+
      nmstart

        [_a-z]|{nonascii}|{escape}
      nonascii

        [^\0-\237]
      unicode

        \\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
      escape

        {unicode}|\\[^\n\r\f0-9a-f]
      nmchar

        [_a-z0-9-]|{nonascii}|{escape}
      num

        [0-9]+|[0-9]*\.[0-9]+
      string

        {string1}|{string2}
      string1

        \"([^\n\r\f\\"]|\\{nl}|{escape})*\"
      string2

        \'([^\n\r\f\\']|\\{nl}|{escape})*\'
      badstring

        {badstring1}|{badstring2}
      badstring1

        \"([^\n\r\f\\"]|\\{nl}|{escape})*\\?
      badstring2

        \'([^\n\r\f\\']|\\{nl}|{escape})*\\?
      badcomment

        {badcomment1}|{badcomment2}
      badcomment1

        \/\*[^*]*\*+([^/*][^*]*\*+)*
      badcomment2

        \/\*[^*]*(\*+[^/*][^*]*)*
      baduri

        {baduri1}|{baduri2}|{baduri3}
      baduri1

        url\({w}([!#$%&*-~]|{nonascii}|{escape})*{w}
      baduri2

        url\({w}{string}{w}
      baduri3

        url\({w}{badstring}
      nl

        \n|\r\n|\r|\f
      w

        [ \t\r\n\f]*
      
    例:

    たとえば、最長一致の規則は、"red-->"がIDENTに続くCDCとしてではなく、IDENT"red--"の後にDELIM">"としてトークン化されることを意味する。
  

  以下はCSSのコア構文である。以降の節では、構文を使用する方法について説明する。付録Gでは、より限定的な文法を説明する。これはCSS レベル 2言語により近い。付録Gの文法に従わない文法により解析されたスタイルシートの部分は、構文解析エラーの処理規則に従って無視される部分となる。
  
stylesheet  : [ CDO | CDC | S | statement ]*;
statement   : ruleset | at-rule;
at-rule     : ATKEYWORD S* any* [ block | ';' S* ];
block       : '{' S* [ any | block | ATKEYWORD S* | ';' S* ]* '}' S*;
ruleset     : selector? '{' S* declaration? [ ';' S* declaration? ]* '}' S*;
selector    : any+;
declaration : property S* ':' S* value;
property    : IDENT;
value       : [ any | block | ATKEYWORD S* ]+;
any         : [ IDENT | NUMBER | PERCENTAGE | DIMENSION | STRING
              | DELIM | URI | HASH | UNICODE-RANGE | INCLUDES
              | DASHMATCH | ':' | FUNCTION S* [any|unused]* ')'
              | '(' S* [any|unused]* ')' | '[' S* [any|unused]* ']'
              ] S*;
unused      : block | ATKEYWORD S* | ';' S* | CDO S* | CDC S*;


  "unused"の提示は、CSSでは使用されず、かつ将来のいかなる拡張でも使用されない。エラー処理を助けるためだけにここに含まれている。（4.2節"構文解析エラーの処理規定"参照。）

  文法においてCOMMENTトークンは（読みやすさのために）出現しないが、このトークンは他のトークンの外側であれば任意の場所でいくらでも出現してよい。（ただし、@charse規則の前または内側のコメントは、@charsetが無効になることに注意する。）

  上記の文法におけるトークンSは空白を表す。文字"スペース"（U+0020）、"タブ"（U+0009）、"改行"（U+000A）、"復帰"（U+000D）、"書式送り"（U+000C）のみが空白として出現する。"emスペース"（U+2003）や"全角スペース"（U+3000）のような他のスペースに似た文字は、決して空白の一部ではない。

  トークン化または解析できないデータの意味は、CSS 2.1で未定義である。

  4.1.2 キーワ－ド

  キーワードは、識別子の形式である。キーワードは引用符("..."または'...')の間に配置されてはならない。つまり、
  
red


  これはキーワードだが、
  
"red"


  これはキーワードではない。（これは文字列である。）その他の不正な例:

  
    不正な例:
    
width: "auto";
border: "none";
background: "red";

  

  4.1.2.1 ベンダー固有の拡張

  CSSにおいて識別子は、'-'（ダッシュ）または'_'（アンダースコア）から始めてよい。'-'または'_'で始まるキーワードとプロパティ名は、ベンダー固有の拡張用に予約されている。このようなベンダー固有の拡張は、以下の形式のいずれかを持つべきである:
  
'-' + ベンダー識別子 + '-' + 有意な名前
'_' + ベンダー識別子 + '-' + 有意な名前


  
    例:

    たとえば、組織XYZがディスプレイの東側のボーダー色を記述するプロパティを追加した場合、-xyz-border-east-colorとして呼び出すだろう。

    その他の既知の例:
    
-moz-box-sizing
-moz-border-radius
-wap-accesskey

  

  最初のダッシュまたはアンダースコアは、CSSの現在または将来のレベルにおいて、プロパティもしくはキーワードで決して使用されないことが保証されている。よって、典型的なCSSの実装はそのようなプロパティを認識しなくてよく、構文解析エラーの処理規則に従って、それらを無視してよい。ただし、最初のダッシュまたはアンダースコアは文法の一部であるため、任意のベンダー固有の拡張をサポートしているかどうかに関係なく、CSS 2.1実装は常にCSS準拠のパーサを使用可能にするべきである。

  著者は、ベンダー固有の拡張を避けるべきである。

  4.1.2.2 参考情報の歴史なノート

  この節は参考情報である。

  執筆時点では、以下の接頭辞の存在が知られている:

  接頭辞

        団体
      -ms-, mso-

        Microsoft
      -moz-

        Mozilla
      -o-, -xv-

        Opera ソフトウェア
      -atsc-

        先進型テレビジョン方式委員会
      -wap-

        WAPフォーラム（訳注:現OMA）
      -khtml-

        KDE
      -webkit-

        Apple
      prince-

        YesLogic
      -ah-

        アンテナハウス
      -hp-

        Hewlett Packard
      -ro-

        Real Objects
      -rim-

        Research In Motion（訳注:BlackBerryのメーカー）
      -tc-

        TallComponents
      4.1.3 文字と活字ケース

  以下の規則は常に有効である:

  すべてのCSSの構文は、ASCIIの範囲内で大文字と小文字の区別をしない（つまり、[a-z]と[A-Z]は等価である）。ただし、CSSの制御下にない部分は除く。たとえば、HTMLの属性値"id"と"class"、フォント名、およびURIの大文字と小文字の区別は、本仕様の範囲外である。とくに、HTMLでの要素名は大文字と小文字の区別はされないが、XMLでの大文字と小文字の区別はされることに注意する。

    CSSでは、（要素名、クラス、およびセレクタ内のIDを含む）識別子は、文字[a-zA-Z0-9]およびISO 10646でU+00A0以上の文字、またハイフン（-）およびアンダースコア（_）のみを含むことができる。識別子は、数字、2つのハイフン、ハイフンの直後の数字で開始できない。また、識別子は、エスケープされた文字および数字コードとして任意のISO 10646文字を含めることができる（次項を参照）。たとえば、識別子"B&W?"は"B\&W\?"または"B\26 W\3F"として記述してよい。

      UnicodeとISO 10646は、コードごとに1対1対応であることに注意する（[UNICODE]および[ISO10646]参照）。
    

    CSS 2.1においてバックスラッシュ（\）文字は、3種類の文字エスケープのいずれかを示す。CSSのコメント内ではバックスラッシュそのものを表し、また、バックスラッシュがスタイルシートの直後に末尾が続く場合もバックスラッシュそのものを表す（すなわち、DELIMトークン）。

      最初に、文字列の中で、改行が続くバックスラッシュは無視される（すなわち、文字列はバックスラッシュや改行のいずれも含まれていないとみなす）。文字列の外に、改行が続くバックスラッシュはバックスラッシュそのものを表す（すなわち、改行が続くDELIM）。

      第二に、バックスラッシュは特殊なCSS文字の意味を相殺する。（16進数字、改行、復帰、書式送りを除く）任意の文字は、特別な意味を除去するためにバックスラッシュでエスケープすることができる。たとえば、"\""は、1つの二重引用符からなる文字列である。スタイルシートの意味を変更することになるため、スタイルシートのプリプロセッサはスタイルシートからこれらのバックスラッシュを削除してはならない。

      第三に、バックスラッシュエスケープは、著者が容易に文書内に挿入できない文字の参照を可能にする。この場合、バックスラッシュの後に最大で6桁の16進数（0..9A..F）を続ける。この数字は0でないISO 10646（[ISO10646]）文字を表さなければならない。（スタイルシートがUnicodeのコードポイントでのゼロの文字を含む場合に何が起こるか、CSS 2.1では未定義である。）範囲内の文字[0-9a-fA-F]は16進数が後に続く場合、数値の末尾は明確にする必要がある。これには二つの方法がある:

      スペース（または他の空白文字）を伴う: "\26 B"（"&B"）。この場合、ユーザエージェントは、"CR/LF"のペア（U+000D/U+000A）を単独の空白文字として処理すべきである。

        厳密に6桁の16進数を与える: "\000026B"（"&B"）
      実際には、これら二つの方法を組み合わせてもよい。16進エスケープの後では、1つの空白文字だけが無視される。この手段は、エスケープシーケンスの後に"本物"の空白文字を二重にしなければならないことに注意する。

      Unicodeで許容された範囲外にある数（たとえば、"\110000" は現在のUnicodeで許される最大の10FFFFを超えている）の場合、ユーザーエージェントは"replacement character"（U+FFFD）によってエスケープを置換してよい。文字が表示される場合、ユーザーエージェントはそのような"欠落文字"のグリフとして、明確な記号を表示すべきである（15.2節の項目5を参照）。
    

    注: バックスラッシュエスケープは、常に識別子または文字列の一部であると考えられる（すなわち、"{"は句読点であるけれども"\7B"は句読点でなく、また"2"はクラス名の先頭に許可されないが"\32"は許可される）。

      識別子"te\st"は、厳密に"test"と同一の識別子である。
    
  4.1.4 文

  CSSの全レベルにおいて、CSSスタイルシートは、文のリストで構成される（上記の文法を参照）。文には2つの種類:@規則と規則集合がある。文の前後には空白が存在してよい。

  4.1.5 @規則

  @キーワードで始まる@規則は、'@'文字の直後に続く識別子である（たとえば、'@import'、'@page'）。

  @規則は、次のセミコロン（;）または次のブロックのいずれか早い方の終端まで含めたすべてで構成される。

  CSS 2.1ユーザエージェントは、ブロック内部に出現するすべての'@import'規則、@charset以外の後のすべての無視されない文、または@import規則を無視しなければならない。

  
    不正な例:

    たとえば、CSS 2.1パーサが次のスタイルシートに遭遇すると仮定する:
    
@import "subs.css";
h1 { color: blue }
@import "list.css";


    2番目の'@import'はCSS 2.1に従うと不正である。CSS 2.1パーサは@規則全体を無視し、事実上スタイルシートを単純化する:
    
@import "subs.css";
h1 { color: blue }

  

  
    不正な例:

    '@media'ブロック内で'@import'が出現するため、次の例において2番目の'@import'規則は不正である。
    
@import "subs.css";
@media print {
  @import "print-main.css";
  body { font-size: 10pt }
}
h1 {color: blue }


    その代わりに、"print"メディア用のスタイルシートのインポート効果だけを実現するよう、media構文で@import規則を使用する。例:
    
@import "subs.css";
@import "print-main.css" print;
@media print {
  body { font-size: 10pt }
}
h1 {color: blue }

  

  4.1.6 ブロック

  ブロックは、左波括弧（{）で始まり、対応する右波括弧（}）で終わる。丸括弧（()）、角括弧（[]）、および波括弧（{}）は常に一致するペアで出現しなければならないこと以外は、その間に任意のトークンが存在してよく、入れ子にしてよい。単一引用符（'）および二重引用符（"）も一致するペアで出現しなければならず、それらの間の文字は、文字列として解析される。文字列の定義については、上記のトークン化を参照のこと。

  
    不正な例:

    ここにブロックの例がある。二重引用符の間の右波括弧は、ブロックの開波括弧と一致せず、また2つ目の単一引用符がエスケープ文字であり、1つ目の単一引用符と一致しないことに注意する。
    
{ causta: "}" + ({7} * '\'') }


    上記の規則は妥当なCSS 2.1ではないが、上記で定義されたブロックではあることに注意する。
  

  4.1.7 規則集合、宣言ブロック、セレクタ

  規則集合（または"規則"と呼ばれる）は、セレクタとそれに続く宣言ブロックから構成する。

  宣言ブロックは、左波括弧（{）で始まり、対応する右波括弧（}）で終わる。宣言の間には、ゼロ個以上のセミコロン（;）で区切られたリストが存在しなければならない。

  セレクタは、最初の左波括弧（{）（自身を含まない）までのすべてのもので構成される（セレクタの節も参照）。セレクタは常に宣言ブロックを伴う。ユーザエージェントがセレクタを解析できない場合（すなわち、妥当なCSS 2.1でない）、セレクタと、（もしあれば）続く宣言ブロックを無視しなければならない。

  CSS 2.1はセレクタ内のコンマ（,）に特別な意味を与える。しかし、コンマがCSSの将来の更新で他の意味を得る可能性があるどうかはわからない。よって、セレクタのどこかにエラーがあって、セレクタの残りの部分がCSS 2.1として筋が通ったように見える場合であっても、文全体を無視すべきである。

  
    不正な例:

    たとえば、"&"はCSS 2.1のセレクタとして妥当なトークンではないので、CSS 2.1のユーザエージェントは、二行目の全体を無視し、H3の色を赤に設定することはない:
    
h1, h2 {color: green }
h3, h4 & h5 {color: red }
h6 {color: black }

  

  
    例:

    より複雑な例を示す。最初の波括弧の2つのペアが文字列の内部に存在するが、セレクタの末尾をマークしない。次に述べるものは妥当なCSS 2.1の規則である。
    
p[example="public class foo\
{\
    private int x;\
\
    foo(int x) {\
        this.x = x;\
    }\
\
}"] { color: red }

  

  4.1.8 宣言とプロパティ

  宣言は、空であるか、もしくはプロパティ名の後にコロン（:）続くでプロパティ値で構成される。これらの前後に空白が出現してよい。

  セレクタの働きのために、同じセレクタに対する複数の宣言は、セミコロン（;）で区切られたグループに整理してよい。

  
    例:

    したがって、以下の規則は:
    
h1 { font-weight: bold }
h1 { font-size: 12px }
h1 { line-height: 14px }
h1 { font-family: Helvetica }
h1 { font-variant: normal }
h1 { font-style: normal }


    以下と同等である:
    
h1 {
  font-weight: bold;
  font-size: 12px;
  line-height: 14px;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal
}

  

  プロパティ名は識別子である。任意のトークンは、プロパティ値で出現してよい。丸括弧（"()"）、角括弧（"[]"）、波括弧（"{}"）、単一引用符（'）、および二重引用符（"）は一致するペアで出現しなければならず、文字列でないセミコロンはエスケープしなければならない。丸括弧、角括弧、大括弧は入れ子にしてよい。引用符の内側の文字は、文字列として解析される。

  値の構文は各プロパティごとに個別に指定される。しかし、いかなる場合でも、識別子、文字列、数値、長さ、パーセンテージ、URI、色、その他から値は組み立てられる。

  ユーザエージェントは、妥当でないプロパティ名もしくは値の宣言を無視しなければならない。すべてのCSSプロパティは、対応する値に構文上および意味上の制約がある。

  
    不正な例:

    たとえば、CSS 2.1パーサが次のスタイルシートに遭遇すると仮定する:
    
h1 { color: red; font-style: 12pt }  /* 不正な値: 12pt */
p { color: blue;  font-vendor: any;  /* 不正なプロパティ: font-vendor */
    font-variant: small-caps }
em em { font-style: normal }


    1行目の2番目の宣言は妥当でない値'12pt'を含む。2行目の2番目の宣言は、未定義のプロパティ'font-vender'をが含む。CSS 2.1パーサーはこれらの宣言を無視し、事実上スタイルシートを単純化する:
    
h1 { color: red; }
p { color: blue;  font-variant: small-caps }
em em { font-style: normal }

  

  4.1.9 コメント

  コメントは文字"/*"に始まり、文字"*/"で終わる。コメントは他のトークン以外のどこでも出現してよく、その内容がレンダリングに影響することはない。コメントは入れ子にすることはできない。

  CSSはまた、文法で定義された特定の場所でSGMLのコメント区切り子("<!--"および"-->")を許すが、CSSのコメントを区切るものではない。これらは、HTMLソース文書で（STYLE要素内の）スタイル規則が出現できるように、HTML 3.2以前のユーザエージェントから隠すためのものである。詳細については、HTML 4の仕様を参照のこと（[HTML4]）。

  4.2 構文解析エラーの処理規定

  場合によって、ユーザーエージェントは不正なスタイルシートの一部を無視しなければならない。本仕様は無視の意味を、ユーザーエージェントが不正な部分（の先頭と末尾を検出するために）を解析するが、不正な部分が存在しないかのように振る舞う、と定義する。CSS 2.1はCSSの全プロパティの将来における更新のためにダッシュまたは下線で始まる識別子を含まない値の組み合わせおよび@キーワードを予約する。実装は、そのような（CSSの将来の更新で導入されたもの以外の）組み合わせを無視しなければならない。

  新規のプロパティを保証するため、また既存のプロパティに新規の値を追加するために、ユーザーエージェントは、以下のシナリオに遭遇した場合の各規則に従う必要がある。

  
      未知のプロパティ。 ユーザーエージェントは、未知のプロパティを含む宣言を無視しなければならない。たとえば、このようなスタイルシートがある場合:
      
h1 { color: red; rotation: 70minutes }


      ユーザーエージェントはスタイルシートをこのように処理する
      
h1 { color: red }

    

    
      不正な値。 ユーザーエージェントは不正な値を含む宣言を無視しなければならない。たとえば:
      
img { float: left }       /* 正しいCSS 2.1 */
img { float: left here }  /* "here"は'float'の値には存在しない */
img { background: "red" } /* キーワードを引用符でくくってはならない */
img { border-width: 3 }   /* 長さの値には単位が必要 */
CSS 2.1パーサは1つ目の規則を引き受けて残りを無視するので、スタイルシートはこのようになる:
      
img { float: left }
img { }
img { }
img { }


      将来のCSS仕様に準拠したユーザエージェントは、他の規則の1つ以上を受け入れるかもしれない。
    

    
      不正な形式の宣言。 ユーザエージェントは、()、[]、{}、""、''、そして正確なエスケープ処理のペアと一致する規則を維持しつつ、宣言の最後まで読むことで、宣言の解析中に遭遇した予期しないトークンを処理しなければならない。たとえば、不正な形式の宣言は、プロパティ名やコロン（:）、プロパティ値を除外してよい。以下はすべて等価である。
      
p { color:green }
p { color:green; color }  /* ':'と値が欠落した不正な形式の宣言 */
p { color:red;   color; color:green }  /* 予期する回復に一致 */
p { color:green; color: } /* 値の欠落した不正な形式の宣言 */
p { color:red;   color:; color:green } /* 予期する回復に一致 */
p { color:green; color{;color:maroon} } /* 予期しないトークン { } */
p { color:red;   color{;color:maroon}; color:green } /* 回復に一致 */

    

    
      Malformed statements. User agents must handle unexpected tokens encountered while parsing a statement by reading until the end of the statement, while observing the rules for matching pairs of (), [], {}, "", and '', and correctly handling escapes. For example, a malformed statement may contain an unexpected closing brace or at-keyword. E.g., the following lines are all ignored:
      
p @here {color: red}     /* 予期しない@キーワード"@here"をもつ規則集合 */
@foo @bar;               /* 予期しない@キーワード"@bar"をもつ@規則 */
}} {{ - }}               /* 予期しない右括弧をもつ規則集合 */
) ( {} ) p {color: red } /* 予期しない右括弧をもつ規則集合 */

    

    
      未知の@キーワードをもつ@規則。ユーザーエージェントは、妥当でない@キーワードとその後に続くすべてのもの、妥当でない@キーワードを含むブロックの終端、次のセミコロン（;）を含むもの、次のブロック（{...}）を含むもの、のいずれか早い方を無視しなければならない。たとえば、以下を考える:
      
@three-dee {
  @background-lighting {
    azimuth: 30deg;
    elevation: 190deg;
  }
  h1 { color: red }
}
h1 { color: blue }


      '@three-dee'規則はCSS 2.1の一部ではない。したがって、（3つ目の右波括弧までを含む）@規則全体は無視される。CSS 2.1ユーザーエージェントはこれを無視し、事実上スタイルシートは単純化される:
      
h1 { color: blue }


      たとえば@media規則内の妥当でない宣言のような、妥当でないために無視される@規則内部のものが、@規則の全体を非妥当にすることはない。
    

    
      予期しないスタイルシートの終了。

      ユーザーエージェントは、すべての開いた構成物（たとえば:ブロック、括弧、規則、コメント）をスタイルシートの終端で閉じなければならない。たとえば:
      
  @media screen {
    p:before { content: 'Hello


      これは以下と同様に処理する:
      
  @media screen {
    p:before { content: 'Hello'; }
  }


      適合ユーザーエージェントではこのようになる。
    

    
      予期しない文字列の終了。

      ユーザエージェントは、行（すなわち、エスケープされていない改行、復帰、書式送り文字の前）の終わりに達した時点で文字列を閉じなければならないが、その一方で文字列が検出された構成物（宣言または規則）を削除しなければならない。たとえば:
      
      p {
        color: green;
        font-family: 'Courier New Times
        color: red;
        color: green;
      }


      これは以下と同様に処理する:
      
      p { color: green; color: green; }


      2番目の宣言（'font-family'から'color: red'の後のセミコロンまで)は妥当でないため、削除される。
    

    宣言ブロックの解析規則については規則集合、宣言ブロック、セレクタも参照のこと。
  4.3 値

  4.3.1 整数値と実数値

  ある値の種類は、整数値（<integer>で示される）または実数値（<number>で示される）を取ることがある。実数および整数は10進数のみを規定する。<integer>は1つ以上の"0"から"9"までの数字で構成される。<number>は<integer>もしくは0個以上の数字の後に、ドット（.）が続き、1つ以上の数字が続くものである。整数値と実数値のどちらも、符号を示す"-"または"+"を先行させてよい。-0は0と等価であって、負の数ではない。

  整数値や実数値を取る多くのプロパティは、実際にはある範囲、もっぱら負でない値に制限されることに注意する。

  4.3.2 長さ

  長さは、距離の寸法を参照する。

  長さの値の形式（本仕様では<length>で示される）は、（小数点の有無に関係なく）<number>の直後に単位識別子（例:px、emなど）が続くものである。長さがゼロならば、単位識別子は省略できる。

  一部のプロパティは負の長さの値を許可するが、これは整形モデルを複雑にする可能性があり、実装特有の限界があるかもしれない。負の長さの値をサポートできない場合、値をサポート可能な最も近い値に変換するべきである。

  負の長さの値を許可しないプロパティにその値が設定される場合、宣言は無視される。

  使用される長さがサポートできない場合、ユーザエージェントは実効値で近似しなければならない。

  長さの単位には、相対と絶対の2種類がある。 相対的長さの単位は、別の長さのプロパティに対して相対的な長さを指定する。相対単位を使用するスタイルシートは、より簡単に1つの出力環境から別のものに拡張できる。

  相対単位は以下のものがある:

  em: 関連するフォントの'font-size'

    ex: 関連するフォントの'x-height'
  
    例:
    
h1 { margin: 0.5em }      /* em */
h1 { margin: 1ex }        /* ex */

  

  'em'単位は、その単位が使われた要素の'font-size'プロパティの算出値に等しい。例外は'em'が'font-size'プロパティ自身の値に出現した時で、この場合は親要素のフォントサイズを参照する。この単位は縦または横の寸法に用いてよい。（この単位は、印刷テキストでクワタ幅と呼ぶこともある。）

  'ex'単位は、要素の最初の利用可能なフォントによって定義される。例外は'ex'が'font-size'プロパティ自身の値に出現した時で、この場合は親要素の'ex'を参照する。

  'x-height'は、小文字の"x"の高さに等しくなることが多いことからこう呼ばれる。しかし、'ex'は"x"を含まないフォントに対しても定義される。

  フォントの-heightは、別の方法で見つけることができる。一部のフォントは、x-heightの信頼できる測定基準を含む。信頼できるフォント測定基準が利用できない場合、ユーザーエージェントは小文字グリフの高さからx-heightを決定してよい。実行可能な経験則の1つは、小文字の"o"のグリフを下ベースラインまで広げ、境界ボックスの上ベースラインから値を減算し、その長さを調べることである。x-heightを測定することが不可能か非現実的な場合、0.5emの値を使用すべきである。

  
    例:

    規則:
    
h1 { line-height: 1.2em }


    これは"h1"要素の行高さがフォントサイズの20%増しであることを意味する。一方:
    
h1 { font-size: 1.2em }


    これは"h1"要素のフォントサイズが継承値の20%増しであることを意味する。
  

  文書ツリーのルート（たとえば、HTMLであれば"HTML"）に指定された場合、'em'と'ex'はプロパティの初期値を参照する。

  子要素は特定の親の相対値を継承しない。算出値を継承するのである。

  
    例:

    次の規則において、"h1"が"body"要素の子であれば、"h1"の要素の'text-indent'の算出値は45pxではなく36pxとなる。
    
body {
  font-size: 12px;
  text-indent: 3em;  /* すなわち、36px */
}
h1 { font-size: 15px }

  

  絶対的長さ単位は相互に関連して一定である。これは、主に出力環境が既知の場合に有用である。絶対単位は物理単位（in、cm、mm、pt、pc）とpx単位で構成される:

  in: インチ―1inは2.54cmに等しい。

    cm: センチメートル

    mm: ミリメートル

    pt: ポイント―CSSで用いるポイントは1inの1/72に等しい。

    pc: パイカ―1pcは12ptに等しい。

    px: ピクセル―1pxは0.75ptに等しい。
  CSSデバイスの場合、これらの大きさは、(1)物理的寸法に物理単位を関連付けること、または（2）参照画素に画素部を関連付けることのいずれかによって固定される。印刷媒体と同様の高解像度デバイスの場合、固定単位は標準的な物理単位の1つ（インチ、センチメートルなど）となるべきである。低解像度のデバイスおよび独自の視聴距離を伴うデバイスの場合、固定単位は代わりにピクセル単位が推奨される。このようなデバイスの場合は、画素単位で最適な参照画素を近似するデバイスピクセルの整数を参照することを推奨する。

  固定単位がピクセル単位の場合、物理単位は、物理的な測定結果と一致するとは限らないことに注意する。あるいは固定単位が物理単位の場合、ピクセル単位は、デバイスピクセルの整数に変換されないことがある。

  このピクセル単位と物理単位の定義は、CSSの以前のバージョンとは異なることに注意する。特に、ピクセル単位と物理単位が固定比で関連しないとされた以前のCSSバージョンで、ピクセル単位に最も近い基準画素と一致するように変化するだろうが、物理単位は常に物理的な測定に関連する。（この変更は、あまりにも多くの既存のコンテンツが96dpiの仮定に依存するために行われた。この前提を壊すことはコンテンツを壊すことになる。）

  基準画素は、腕の長さのデバイスからの距離と96dpiのピクセル密度におけるデバイス上の1ピクセルとの視角である。名目の腕の長さが28インチの場合、視角は約0.0213度である。距離をおいて読むために、1pxは約0.26mm（1/96インチ）に対応する。

  下の画像は、参照ピクセルの大きさで距離を見ることの効果を示している: 71cm（28インチ）の読み取り距離では基準画素が0.26mmで、3.5m（12フィート）では1.3mmの参照画素となる。

  
       [説明]
  

  次の図は、ピクセル単位でのデバイスの解像度の効果を示している: 低解像度のデバイス（たとえば、典型的なコンピュータ画面）では1px平方の領域が単独の画素で覆われてしまうのに対し、高解像度のデバイス（レーザープリンタなど）では1pxの領域に16個もの画素が入ることがわかる。

  
       [説明]
  

  
    例:
    
h1 { margin: 0.5in }      /* インチ */
h2 { line-height: 3cm }   /* センチ */
h3 { word-spacing: 4mm }  /* ミリ */
h4 { font-size: 12pt }    /* ポイント */
h4 { font-size: 1pc }     /* パイカ */
p  { font-size: 12px }    /* ピクセル */

  

  4.3.3 パーセント値

  パーセント値の形式（<percentage>で示される）は、<number>の直後に'%'が続くものである。

  パーセント値は、たとえば長さなど、常に他の値に対する相対値となる。パーセント値をとることのできる各プロパティは、参照先の値も定義する。その値は、同じ要素の別のプロパティ、祖先要素のプロパティ、または整形文脈に関わる値（たとえば、包含ブロックの幅）であってよい。パーセント値がルート要素のプロパティに指定されており、かつあるプロパティの継承値を参照するものとして定義される場合、値はそのプロパティの初期値のパーセント倍をする。

  
    例:

    （一般に）子要素は親の算出値を継承するので、次の例では、P要素の子が継承する'line-height'の値はパーセント値（120%）ではなく12pxとなる:
    
p { font-size: 10px }
p { line-height: 120% }  /* 'font-size'の120% */

  

  4.3.4 URLおよびURI

  本仕様においてURI（統一資源識別子のこと。URLやURNを含むものである。[RFC3986]を参照）値は<uri>として示される。プロパティ値にURIを指定する関数表記は"url()"を用いる:

  
    例:
    
body { background: url("http://www.example.com/pinkish.png") }

  

  URI値の形式では、'url()'関数の括弧内にURIを記述する。URIは単一引用符（'）もしくは二重引用符（"）でくくってもよく、また空白を任意に挿入してもよい。2つの引用符は同じでなければならない。

  
    例:

    引用符が無い例:
    
li { list-style: url(http://www.example.com/redball.png) disc }

  

  引用符で囲まれていないURIにおいて、括弧、空白文字、単一引用符（'）と二重引用符（"）の文字は、結果として得られるURI値がURIトークンになるようバックスラッシュでエスケープしなければならない: '\(''、'\)'。

  URIの種類によっては、上記の文字を[RFC3986]で説明されるようにURIエスケープ（ "(" = %28、 ")" = %29、など）として記述可能でもある。

  
    COMMENTトークンは、他のトークン内で出現できないことに注意する: したがって、"url(/*x*/pic.png)"はURI"/*x*/pic.png"を表し、"pic.png"ではない。
  

  リソースの絶対位置に依存しないモジュラー・スタイルシートを作成するために、著者は、相対URIを使用してよい。相対URI（[RFC3986]で定義される）は、基底URIを用いて完全なURIに解決される。RFC 3986の5章は、この処理に用いる標準的なアルゴリズムを定義する。CSSスタイルシートでは、基底URIはソース文書のURIではなく、スタイルシートのURIである。

  
    例:

    たとえば、以下の規則を考える:
    
body { background: url("yellow") }


    URIで指定されたスタイルシート:
    http://www.example.org/style/basic.css

    ソース文書のBODYの背景は、URIで指定されたリソースによって記述される画像でタイル状に表示される:
    http://www.example.org/style/yellow
  

  ユーザエージェントは、妥当でないURI、またはURIが利用できないか不適当なリソースを指定する場合の処理方法が異ってよい。

  4.3.5 カウンタ

  カウンタは、大文字と小文字を区別する識別子で表される（'counter-increment'と'counter-reset'を参照）。カウンタの値を参照するには、'counter(<identifier>)'または'counter(<identifier>, <'list-style-type>)'という表記法を使用する。トークンを区切る任意の空白があってよい。デフォルトのスタイルは'decimal'である。

  同じ名前の入れ子にされたカウンタの順序を参照するには、'counters(<identifier>, <string>)'または'counters(<identifier>, <string>, <'list-style-type'>)'という表記法を使用する。トークンを区切る任意の空白があってよい。

  どのようにしてユーザエージェントが値またはカウンタの値を決定しなければならないかについては生成コンテンツの章の"カウンタの入れ子と範囲"を参照のこと。どのようにしてこれらの値を文字列に変換しなければならないかについては'content'プロパティのカウンタ値の定義を参照のこと。

  CSS 2.1では、'content'プロパティを通してのみカウンタの値を参照できる。 カウンタの<list-style-type>には'none'も指定できることに注意する。'counter(x, none)'という関数は空の文字列を返すことになる。

  
    例:

    以下は各章（h1要素）の段落（p要素）を数えるスタイルシートである。各段落にはローマ数字で番号が振られ、番号の後ろにはピリオドとスペースが続く:
    
p {counter-increment: par-num}
h1 {counter-reset: par-num}
p:before {content: counter(par-num, upper-roman) ". "}

  

  4.3.6 色

  <color>はキーワードまたは数値RGBのいずれかである。

  色キーワードのリストは、aqua、black、blue、fuchsia、gray、green、lime、maroon、navy、olive、orange、purple、red、silver、teal、white、yellowである。この17色は以下の値をもつ。

  
    
      maroon #800000 red #ff0000 orange #ffA500 yellow #ffff00 olive #808000
    

    
      purple #800080 fuchsia #ff00ff white #ffffff lime #00ff00 green #008000
    

    
      navy #000080 blue #0000ff aqua #00ffff teal #008080
    

    
      black #000000 silver #c0c0c0 gray #808080
    
  

  ユーザーは、これらの色キーワードに加えて、ユーザー環境内の特定のオブジェクトが使用する色に対応するキーワードを指定してよい。詳細については、システム色の節を参照のこと。

  
    例:
    
body {color: black; background: white }
h1 { color: maroon }
h2 { color: olive }

  

  数値の色指定では、RGB色モデルを使用する。この例はすべて同じ色を指定している:

  
    例:
    
em { color: #f00 }              /* #rgb */
em { color: #ff0000 }           /* #rrggbb */
em { color: rgb(255,0,0) }      
em { color: rgb(100%, 0%, 0%) } 

  

  16進表記のRGB値の形式は、'#'の直後に3桁もしくは6桁の16進数のいずれか続くものである。3桁のRGB表記（#rgb）は6桁の形式（#rrggbb）に変換される。これは桁を繰り返したものであって、ゼロを付け足したものではない。たとえば、#fb0は#ffbb00に展開する。これは、白（#ffffff）が簡略記法（#fff）として指定でき、ディスプレイの色深度に依存しないことを保証する。

  関数表記のRGB値の形式は'rgb()'であり、括弧内に3つのカンマ区切りの整数値またはパーセント値のリストのいずれかである。整数値の255がパーセント値の100%、16進数表記でFまたはFFに対応している:すなわち、rgb(255,255,255) = rgb(100%,100%,100%) = #FFFとなる。数値の前後に空白文字が出現してよい。

  すべてのRGB色はsRGB色空間に指定される（[SRGB]参照）。ユーザエージェントは、これらの色再現が異なってよい。しかし、sRGBを使用することは、明確で客観的に測定可能な色のあるべき定義を提供することができる。また、国際標準との関連が得られる（[COLORIMETRY]参照）。

  適合ユーザエージェントは、色表示にガンマ補正処理の試みを限定してよい。sRGBは、指定の閲覧環境のもとで2.2の表示ガンマを規定する。ユーザエージェントは、出力デバイスの"自然な"表示ガンマと組み合わせた、効果的な表示ガンマ2.2が生成される、というようなCSSで与えられた色を調整すべきである。CSSで指定された色だけが影響を受けることに注意する。たとえば、画像は独自の色情報を持つだろう。

  色域が既知の場合、デバイスの範囲外の値を切り取りとるか変換すべきである。赤、緑、および青の値は、デバイスでサポートされる範囲内に収まるように変換しなければならない。ユーザーエージェントはある色域から別の高品質な色域に変換してよい。デバイス色域がsRGBと同一である典型的なCRTモニタにおいて、以下の4つの規則は等価である:

  
    例:
    
em { color: rgb(255,0,0) }       /* 整数の範囲0-255 */
em { color: rgb(300,0,0) }       /* rgb(255,0,0)に切り取られる */
em { color: rgb(255,-10,0) }     /* rgb(255,0,0)に切り取られる */
em { color: rgb(110%, 0%, 0%) }  /* rgb(100%,0%,0%)に切り取られる */

  

  プリンタなどの他のデバイスは、sRGBと異なる色域を持っている:0-255のsRGB範囲外の色が（デバイスの色域内に）表現されることもある一方で、0..255のsRGB範囲内の色がデバイスの色域の範囲外になるためにマッピングされることがある。

  
    注。カラー値のクリッピングまたはマッピングは、実際のデバイスの色域が既知の場合（0..255より大きいのか小さいのか）に行われるべきである。
  

  4.3.7 文字列

  文字列は、一重あるいは二重引用符で書きあらわされる。二重引用符は、エスケープされない限り二重引用符の内部に出現することはできない（たとえば、'\"'または'\22'とする）。一重引用符も同様である（"\'"または"\27"）。

  
    例:
    
"this is a 'string'"
"this is a \"string\""
'this is a "string"'
'this is a \'string\''

  

  文字列は直接改行を含むことはできない。文字列に改行を含むには、ISO 10646で（U+000A）をエスケープ表現した改行文字"\A"または"\00000a"を用いる。この文字は、CSSで"改行"の一般概念を表現する。使用例は'content'プロパティを参照のこと。

  美的またはその他の理由で、複数行にわたって文字列を分割することは可能だが、そのような場合には改行文字自体をバックスラッシュ（\）でエスケープする必要がある。たとえば、以下の2つのセレクタは厳密に等価である:

  
    例:
    
a[title="a not s\
o very long title"] {/*...*/}
a[title="a not so very long title"] {/*...*/}

  

  4.3.8 サポートしない値

  ユーザーエージェントが特定の値をサポートしていない場合、スタイルシートを解析するときにその値が不正な値であるかのように、その値を無視すべきである。たとえば:

  
    例:
    
  h3 {
    display: inline;
    display: run-in;
  }

  

  'display'プロパティで'run-in'値をサポートするユーザーエージェントは、最初の表示の宣言を受け入れてから、2番目のdisplayの宣言と値で"上書き"される。'run-in'値をサポートしないユーザーエージェントは、最初の表示の宣言を処理し、2番目のdisplayの宣言を無視する。

  4.4 CSSスタイルシートの表現

  CSSスタイルシートは、国際文字集合（[ISO10646]を参照）からなる文字の並びである。通信および保存のために、これらの文字はUS-ASCII文字集合をサポートする文字エンコーディング（たとえば、UTF-8、ISO 8859-x、SHIFT JISなど）でエンコードしなければならない。文字集合と文字エンコーディングへの役立つ手引きついては、HTML 4仕様書を参照のこと（[HTML4]、5章）。またXML 1.0仕様も参照されたい（[XML10]、2.2節、4.3.3節および付録F）。

  STYLE要素またはHTMLの"style"属性のように別の文書にスタイルシートが埋め込まれている場合、スタイルシートは、文書全体の文字エンコーディングを共有する。

  スタイルシートが別ファイルに存在する場合、ユーザエージェントはスタイルシートの文字エンコーディングをを決定するにあたり、以下の（高いものから低いものへ）優先順位を遵守しなければならない:

  HTTPプロトコルでの"Content-Type"フィールドの"charset"パラメータ（または他のプロトコルの類似のパラメータ）

    BOMと@charsetの両方またはいずれか一方（以下参照）

    <link charset="">または（もしあれば）リンクの機構による他のメタデータ

    スタイルシートやドキュメントの参照する文字集合（もしあれば）

    UTF-8を仮定する
  @charset規則を使用する著者は、文字を先行させることなくスタイルシートの最初に規則を設置しなければならない。（バイトオーダーマークが使用されるエンコードに対して適切な場合、@charset規則に先行してよい。）

  "@charset"の後に、著者は文字エンコーディング名を（引用符内に） 指定する。たとえば:
  @charset "ISO-8859-1";

  @charsetは文字通りに記述しなければならない。すなわち、'@charset "'（小文字でバックスラッシュでエスケープせず）10文字、その直後にエンコーディング名、その直後に'";'とする。

  エンコーディング名はIANAレジストリに記載された文字集合の名前でなければならない。文字集合の完全な一覧については[CHARSETS]を参照のこと。著者は、IANAレジストリにおいて"preferred MIME name"としてマークされた文字集合名を使用すべきである。

  ユーザーエージェントは少なくともUTF-8エンコーディングをサポートしなければならない。

  ユーザーエージェントはスタイルシートの冒頭にないすべての@charset規則を無視しなければならない。ユーザーエージェントがBOMと@charset規則の両方またはいずれか一方を用いて文字エンコーディングを検出する場合、ユーザーエージェントは以下の規則に従うべきである:

  以下の規則で指定されたとする場合を除き、すべての@charset規則は無視される。

    エンコーディングは、スタイルシートの最初のバイト列に基づいて検出される。次の表は、（16進数で書かれた）初期バイト列の可能性のあるセットを与える。スタイルシートの先頭に一致する最初の行は、BOMと@charset規則の両方またはいずれか一方に基づいて、エンコーディング検出の結果が得られる。一致する行がない場合、エンコーディングはBOMと@charset規則の両方またはいずれか一方に基づく結果が得られない。最長一致の表記(...)*は、1回以上のできるだけ少ない回数の繰り返しを示す。"XX"とマークされているバイトは、ASCII文字のシーケンスとして所定の順序により処理することで、エンコーディング名の決定に使用されるものである。"YY"とマークされたバイトも同様だが、前述したようにASCIIにコード変換する必要がある。ユーザーエージェントがエントリに関連するあらゆるエンコーディングをサポートしていない場合、ユーザエージェントはテーブル内のエントリを無視してよい。

      初期バイト列

            結果
          EF BB BF 40 63 68 61 72 73 65 74 20 22 (XX)* 22 3B

            指定値
          EF BB BF

            UTF-8
          40 63 68 61 72 73 65 74 20 22 (XX)* 22 3B

            指定値
          FE FF 00 40 00 63 00 68 00 61 00 72 00 73 00 65 00 74 00 20 00 22 (00 XX)* 00 22 00 3B

            指定される（ビッグエイディアンのバイトオーダーで指定されない場合）
          00 40 00 63 00 68 00 61 00 72 00 73 00 65 00 74 00 20 00 22 (00 XX)* 00 22 00 3B

            指定される（ビッグエイディアンのバイトオーダーで指定されない場合）
          FF FE 40 00 63 00 68 00 61 00 72 00 73 00 65 00 74 00 20 00 22 00 (XX 00)* 22 00 3B 00

            指定される（リトルエイディアンのバイトオーダーで指定されない場合）
          40 00 63 00 68 00 61 00 72 00 73 00 65 00 74 00 20 00 22 00 (XX 00)* 22 00 3B 00

            指定される（リトルエイディアンのバイトオーダーで指定されない場合）
          00 00 FE FF 00 00 00 40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 (00 00 00 XX)* 00 00 00 22 00 00 00 3B

            指定される（ビッグエイディアンのバイトオーダーで指定されない場合）
          00 00 00 40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 (00 00 00 XX)* 00 00 00 22 00 00 00 3B

            指定される（ビッグエイディアンのバイトオーダーで指定されない場合）
          00 00 FF FE 00 00 40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 00 (00 00 XX 00)* 00 00 22 00 00 00 3B 00

            指定される（2143のバイトオーダーで指定されない場合）
          00 00 40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 00 (00 00 XX 00)* 00 00 22 00 00 00 3B 00

            指定される（2143のバイトオーダーで指定されない場合）
          FE FF 00 00 00 40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 00 00 (00 XX 00 00)* 00 22 00 00 00 3B 00 00

            指定される（3412のバイトオーダーで指定されない場合）
          00 40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 00 00 (00 XX 00 00)* 00 22 00 00 00 3B 00 00

            指定される（3412のバイトオーダーで指定されない場合）
          FF FE 00 00 40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 00 00 00 (XX 00 00 00)* 22 00 00 00 3B 00 00 00

            指定される（リトルエイディアンのバイトオーダーで指定されない場合）
          40 00 00 00 63 00 00 00 68 00 00 00 61 00 00 00 72 00 00 00 73 00 00 00 65 00 00 00 74 00 00 00 20 00 00 00 22 00 00 00 (XX 00 00 00)* 22 00 00 00 3B 00 00 00

            指定される（リトルエイディアンのバイトオーダーで指定されない場合）
          00 00 FE FF

            UTF-32-BE
          FF FE 00 00

            UTF-32-LE
          00 00 FF FE

            UTF-32-2143
          FE FF 00 00

            UTF-32-3412
          FE FF

            UTF-16-BE
          FF FE

            UTF-16-LE
          7C 83 88 81 99 A2 85 A3 40 7F (YY)* 7F 5E

            EBCDICからASCIIへのコード変換として指定される
          AE 83 88 81 99 A2 85 A3 40 FC (YY)* FC 5E

            IBM1026からASCIIへのコード変換として指定される
          00 63 68 61 72 73 65 74 20 22 (YY)* 22 3B

            GSM 03.38からASCIIへのコード変換として指定される
          類似のパターン

            ユーザーエージェントがこのパターンによって処理されないエンコーディングをサポートしている場合、ユーザエージェントは追加で類似したパターンをサポートしてよい。
          

    エンコーディングが上記の表で"指定された"とマークされている1つに基づき検出された場合において、ユーザーエージェントは、たとえ選択された@charsetでのデコードの結果による文字列で開始された適切な@charset規則を解析しないとしても、スタイルシートを無視する。これは、次のことが保証される:

      @charset規則は、スタイルシートのエンコーディングにおいてのみ機能すべきであり、

        バイトオーダーマークは、バイトオーダーマークをサポートするエンコーディングにのみ無視され、

        エンコーディング名は改行を含めることはできない。
      
  ユーザーエージェントは未知のエンコーディングのスタイルシートを無視しなければならない。

  4.4.1 文字符号化で表現できない文字を参照する

  スタイルシートは、現在の文字エンコーディングで表現できない文字を参照する必要があるかもしれない。これらの文字はISO 10646文字を参照するエスケープとして記述しなければならない。このエスケープは、HTMLやXML文書の数値文字参照と同じ役割を果たす（[HTML4]の5章と25章を参照のこと）。

  文字エスケープ機構は、ごくわずかの文字をエスケープ文字として表現しなければならない場合にのみ使用すべきである。スタイルシートの大部分がエスケープを必要とする場合、著者はより適切なエンコーディングでエンコードすべきである（たとえば、スタイルシートがギリシャ文字を大量に含む場合、著者は"ISO-8859-7"または"UTF-8"を使用してよい）。

  異なる文字エンコーディングを用いる中間プロセッサは、エスケープシーケンスをエンコーディングのバイト列に変換してよい。その一方で、中間プロセッサは、ASCII文字の特別な意味を相殺するエスケープシーケンスを変更してはならない。

  適合ユーザーエージェントは、認識する任意の文字エンコーディングにおいてISO-10646 の全文字をマップしなければならない（またはそうであるかのように振る舞わなければならい）。

  たとえば、ISO-8859-1（Latin-1）として伝送されるスタイルシートは、ギリシャ文字を直接含めることができない: "κουρος"（ギリシャ語: "kouros"）は"\3BA\3BF\3C5\3C1\3BF\3C2"として記述される必要がある。

  
    注。 HTML 4では、"style"属性値での数値実体参照は解釈されるが、STYLE要素の内容は解釈されない。この非対称性のため、著者は"style"属性とSTYLE要素の両方で数値文字参照よりもCSSの文字エスケープ機構を使用することを推奨する。たとえば、以下のものが推奨される:
    
<SPAN style="font-family: L\FC beck">...</SPAN>


    以下のものではなく:
    
<SPAN style="font-family: L&#252;beck">...</SPAN>

  

  5 セレクタ

  
    目次

    5.1 パターンマッチ

      
        5.2 セレクタの構文

        5.2.1 グループ化
        

      5.3 全称セレクタ

      5.4 型セレクタ

      5.5 子孫セレクタ

      5.6 子セレクタ

      5.7 隣接セレクタ

      
        5.8 属性セレクタ

        5.8.1 属性および属性値のマッチング

          5.8.2 DTDにおける属性の規定値

          5.8.3 クラスセレクタ
        

      5.9 IDセレクタ

      5.10 擬似要素と擬似クラス

      
        5.11 擬似クラス

        5.11.1 :first-child 擬似クラス

          5.11.2 リンク擬似クラス: :linkと:visited

          5.11.3 動的擬似クラス: :hover、:active、:focus

          5.11.4 言語擬似クラス: :lang
        

      
        5.12 擬似要素

        5.12.1 :first-line擬似要素

          5.12.2 :first-letter疑似要素

          5.12.3 :beforeと:after疑似要素
        
    

  5.1 パターンマッチ

  CSSでは、パターンマッチ規則が文書ツリー内のどの要素にスタイル規則を適用するかを決定する。セレクタと呼ばれるこれらのパターンは単純な要素名から豊富な文脈上のパターンへと多岐にわたる。パターン内のすべての条件が特定の要素に対して該当する場合、セレクタは要素にマッチする。

  セレクタについて文書言語の要素名における大文字小文字の区別は、文書言語に依存する。たとえば、HTMLでは要素名の大文字小文字は区別されないが、XMLでは区別される。

  次の表はCSS 2.1セレクタ構文の概要である:

  パターン

        意味

        解説する節
      *

        すべての要素にマッチする。

        全称セレクタ
      E

        E要素にマッチする（すなわち、E要素型）。

        型セレクタ
      E F

        E要素の子孫であるF要素にマッチする。

        子孫セレクタ
      E > F

        E要素の子であるF要素にマッチする。

        子セレクタ
      E:first-child

        親要素の最初の子であるE要素にマッチする。

        :first-child擬似クラス
      E:link
        E:visited

        ハイパーリンクのアンカーであるE要素のうち、未訪問（:link）であるもの、訪問済み（:visited）であるものにマッチする。

        リンク疑似クラス
      E:active
        E:hover
        E:focus

        特定のユーザーアクション状態にあるE要素にマッチする。

        動的疑似クラス
      E:lang(c)

        言語cを持つE要素にマッチする（言語情報の決定方法は文書言語が規定する）。

        :lang()疑似クラス
      E + F

        E要素の直後に現れるF要素にマッチする。

        隣接セレクタ
      E[foo]

        （値にかかわらず）"foo"属性を設定されたE要素にマッチする。

        属性セレクタ
      E[foo="warning"]

        "foo"属性の値が"warning"であるE要素にマッチする。

        属性セレクタ
      E[foo~="warning"]

        "foo"属性が空白区切りの値をとり、その値の1つが"warning"であるE要素にマッチする。

        属性セレクタ
      E[lang|="en"]

        "lang"属性が"en"で（左から）始まるハイフン区切りのリストをもつE要素にマッチする。

        属性セレクタ
      DIV.warning

        言語固有。（HTMLでは、DIV[class~="warning"]と同義。）

        クラスセレクタ
      E#myid

        "myid"と同値のIDをもつE要素にマッチする。

        IDセレクタ
      5.2 セレクタの構文

  単体セレクタは型セレクタもしくは 全称セレクタのいずれかの直後に、0個以上の属性セレクタ、IDセレクタ、擬似クラスが任意の順序で続くものである。セレクタの構成要素のすべてが一致する場合、単体セレクタはマッチする。

  注: CSS 2.1において使用される用語は、CSS3で使用されているものとは異なる。たとえば、"単体セレクタ"は、CSS 2.1と比較してCSS3でのセレクタはより小さな部分を参照する。CSS3セレクタモジュール[CSS3SEL]を参照のこと。

  セレクタは、結合子で区切られた1つ以上の単体セレクタからなる。結合子は、空白、">"、"+"がある。空白は結合子と単体セレクタの間や前後に出現してよい。

  セレクタにマッチする文書ツリーの要素を、セレクタの対象と呼ぶ。単一の単体セレクタから成るセレクタは、その要件を満たすすべての要素にマッチする。単体セレクタや結合子を列の先頭に追加することは、追加のマッチング制約を課す。よってセレクタの対象は、常に最後の単体セレクタに一致する要素のサブセットである。

  単一の擬似要素は、連鎖の最後の単純セレクタに追加してよい。その場合、スタイル情報は各対象の一部に適用される。

  5.2.1 グループ化

  複数のセレクタが同じ宣言を共有する場合、セレクタをコンマ区切りのリストにグループ化してよい。

  
    例:

    この例では、同一の宣言を持つ3つの規則を1つに簡略化する。つまり、
    
h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }


    これは以下と同等である:
    
h1, h2, h3 { font-family: sans-serif }

  

  CSSは、複数の宣言や短縮形のプロパティを含む、他の"簡潔表現"のメカニズムを提供する。

  5.3 全称セレクタ

  "*"と書き表される全称セレクタは、すべての要素型の名前とマッチする。文書ツリー内の任意の単一要素にマッチするのである。

  全称セレクタが単体セレクタの唯一の構成要素でない場合、"*"を省略してよい。たとえば:

  *[LANG=fr]と[LANG=fr]は等価である。

    *.warningと.warningは等価である。

    *#myidと#myidは等価である。
  5.4 型セレクタ

  型セレクタは、文書言語の要素型の名前とマッチする。型セレクタは、文書ツリー内の要素型の全インスタンスとマッチする。

  
    例:

    次の規則は、文書ツリー内のすべてのH1要素とマッチする。
    
h1 { font-family: sans-serif }

  

  5.5 子孫セレクタ

  ときには、著者はセレクタが文書ツリー内の別の要素の子孫である要素とマッチさせたいこともあるだろう（たとえば、H1要素に含まれるEM要素にマッチさせる）。子孫セレクタは、パターン内のそのような関係を表現する。子孫セレクタは、空白で区切られた2つ以上のセレクタで構成される。形式"A B"の子孫セレクタは、要素Bが、ある祖先要素Aの任意の子孫である場合にマッチする。

  
    例:

    たとえば、次の規則を考えてみる:
    
h1 { color: red }
em { color: red }


    この規則の意図するところは、文字色の変更によってテキストを強調することだが、次のような場合にその効果は失われる。
    
<H1>This headline is <EM>very</EM> important</H1>


    この場合、H1内にEMが出現するときに文字色を青に設定する規則を、以前の規則に補完することによって対処する:
    
h1 { color: red }
em { color: red }
h1 em { color: blue }


    3番目の規則は以下の断片でEMとマッチする:
    
<H1>This <SPAN class="myclass">headline 
is <EM>very</EM> important</SPAN></H1>

  

  
    例:

    以下のセレクタは:
    
div * p 


    DIV要素の孫またはそれ以上の代の子孫となるP要素にマッチする。"*"の両側の空白は、全称セレクタの一部でないことに注意する。空白は、DIVが要素の祖先でなければならないこと、およびその要素がPの祖先でなければならないことを意味する結合子である。
  

  
    例:

    子孫セレクタと属性セレクタを組み合わせたものが以下の規則である。このセレクタは、(1)"href"属性が設定されており、(2)DIVの内側にあってPの内部にある任意の要素にマッチする。
    
div p *[href]

  

  5.6 子セレクタ

  要素がある要素の子である場合、子セレクタはマッチする。子セレクタは">"で区切られた2つ以上のセレクタで構成される。

  
    例:

    次の規則は、BODYの子であるすべてのP要素にスタイルを設定する:
    
body > P { line-height: 1.3 }

  

  
    例:

    次の例は、子孫セレクタと子セレクタを組み合わせている:
    
div ol>li p


    このセレクタはLIの子孫であるP要素にマッチする。LI要素はOL要素の子でなければならず、OL要素はDIVの子孫でなければならない。">"結合子の前後の空白が省略されていることに注意する。
  

  ある要素における最初の子のセレクタに関する詳細は、:first-child擬似クラスの節を参照のこと。

  5.7 隣接セレクタ

  隣接兄弟セレクタはE1 + E2の構文をとる。ここでE2がセレクタの主体である。E1とE2が文書ツリーで同じ親を共有し、かつE1の直後にE2が続く場合、非要素ノード（テキストノードやコメントなど）を無視してセレクタはマッチする。

  
    例:

    したがって、次の規則はMATH要素の直後に続くP要素のインデントすべきではないことを提示している:
    
math + p { text-indent: 0 } 


    次の例では、H1とその直後に続くH2の間にある垂直方向のスペースを削減する:
    
h1 + h2 { margin-top: -5mm }   

  

  
    例:

    次の規則は、クラスセレクタが追加されたことを除けば、上の例と同様である。したがって、H1がclass="opener"を持つ場合に限り、特別な整形効果が現れる:
    
h1.opener + h2 { margin-top: -5mm }   

  

  5.8 属性セレクタ

  CSS 2.1は、作者がソース文書で定義されたある属性を持つ要素にマッチする規則を指定できる。

  5.8.1 属性および属性値のマッチング

  属性セレクタは、4つの方法でマッチしてよい。

  [att]

    要素の"att"属性が任意の値を設定するときにマッチする。

    [att=val]

    要素の"att"属性値が厳密に"val"であるときにマッチする。

    [att~=val]

    空白区切りのリストで、そのうちの1つの単語が厳密に"val"であるようなatt属性値を持つ要素を意味する。"val"が空白に相当する場合、（単語が空白区切りなので）何かを意味することは決してない。"val"が空の文字列の場合、いずれも意味するものではない。

    [att|=val]

    値が厳密に"val"または"val"で始まり直後に"-"（U+002D）が続くいずれかのatt属性を持つ要素を意味する。これは、主にBCP 47（[BCP47]）またはその後継で説明されるような言語のサブコードとマッチすることを意図している（たとえば、HTMLのa要素におけるhreflang属性）。lang（あるいはxml:lang）の言語のサブコードのマッチについては、:lang擬似クラスを参照のこと。
  属性値は、識別子または文字列でなければならない。セレクタの属性名と属性値について、大文字小文字の区別は文書言語に依存する。

  
    例:

    たとえば、以下の属性セレクタは、値にかかわらず"title"属性を指定するすべてのH1要素とマッチする。
    
h1[title] { color: blue; }

  

  
    例:

    次の例では、セレクタは、"class"属性が厳密に値"example"を持つすべてのSPAN要素にマッチする:
    
span[class=example] { color: blue; }

  

  複合的な属性セレクタは、ある要素の複数の属性、あるいは同一属性の複数回の参照できる。

  
    例:

    ここで、セレクタは、"hello"属性が厳密に値"Cleveland"を持ち、"goodbye"属性が厳密に値 "Columbus"を持つすべてのSPAN要素にマッチする:
    
span[hello="Cleveland"][goodbye="Columbus"] { color: blue; }

  

  
    例:

    以下のセレクタは"="と"~="の違いを示している。たとえば、最初のセレクタは、"rel"属性の値"copyright copyleft copyeditor"とマッチする。2つめのセレクタは、"href"属性が値"http://www.w3.org/"を持つときのみマッチする。
    
a[rel~="copyright"]
a[href="http://www.w3.org/"]

  

  
    例:

    次の規則は、"lang"属性値が"fr"（フランス語）となっているすべての要素を非表示にする。
    
*[lang=fr] { display : none }

  

  
    例:

    次の規則は、"lang"属性値が"en"で始まるものにマッチする。これは、"en"、"en-US"、"en-cockney"などを含む:
    
*[lang|="en"] { color : red }

  

  
    例:

    同様に、次の聴覚スタイルシートの規則は、セリフを各役割ごとに異なる声で読み上げさせる:
    
DIALOGUE[character=romeo] 
     { voice-family: "Laurence Olivier", charles, male }
      
DIALOGUE[character=juliet]  
     { voice-family: "Vivien Leigh", victoria, female }

  

  5.8.2 DTDにおける属性の規定値

  マッチングは、文書ツリーの属性値に対して行われる。デフォルトの属性値はDTDまたは他の場所で定義されてよいが、常に属性セレクタを選択できるとは限らない。スタイルシートは、デフォルト値が文書ツリーに含まれない場合でも動作するように策定されるべきである。

  より正確には、ユーザーエージェントは、DTDの"外部サブセット"を読んで、文書中にデフォルト属性値を検索することを要求されなくてよいが、文書の"内部サブセット"においては要求されてよい（これらのサブセットの定義については、[XML10]を参照のこと）。DTDの外部サブセットで定義されるデフォルトの属性値が、文書ツリーに出現するかどうかは、ユーザーエージェントに依存する。

  ユーザーエージェントはXML名前空間[XMLNAMESPACES]を認識してよいが、名前空間が文書に存在したかどうかにかかわらず、デフォルトの属性値を扱うために名前空間の知識を要求されない。（たとえば、XHTMLユーザーエージェントは、XHTMLのDTDの組み込み知識の使用を要求されない。）

  一般に、実装は外部サブセットの無視を選択することに注意する。

  
    例:

    Example:

    たとえば、デフォルト値"decimal"である属性"notation"を持つ要素の例を考える。DTD断片はこのようになる
    
<!ATTLIST EXAMPLE notation (decimal,octal) "decimal">


    スタイルシートが次の規則を含むとすると
    
EXAMPLE[notation=decimal] { /*... 規定のプロパティ設定 ...*/ }
EXAMPLE[notation=octal]   { /*... 別の設定 ...*/ }


    最初の規則は、その"notation"属性がデフォルトで設定されている要素とマッチしない場合がある。すなわち、明示的に設定されていないことがある。すべての場合を捕らえるには、デフォルト値の属性セレクタを削除しなければならない:
    
EXAMPLE                   { /*... 規定のプロパティ設定 ...*/ }
EXAMPLE[notation=octal]   { /*... 別の設定 ...*/ }


    ここで、セレクタEXAMPLE[notation=octal]が単独の型セレクタよりも詳細であるので、2番目の規則でのスタイル宣言は、"notation"の属性値"octal"を持つ要素が最初のものを上書きする。デフォルトの場合のみに適用される任意のプロパティの宣言は、非デフォルトの場合のスタイル規則で上書きされることに配慮する必要がある。
  

  5.8.3 クラスセレクタ

  HTMLと連携する場合、著者はclass属性を表す場合~=表記の代わりにピリオド（.）を使用してよい。このようにHTMLに対して、div.valueとdiv[class~=value]は同じ意味を持つ。属性値は、"ピリオド"（.）の直後に続かなければならない。ユーザーエージェントは、それぞれの名前空間の"class"属性を決定するための名前空間固有の知識を持つ場合、XML文書にピリオド（.）表記を使ってセレクタを適用してよい。名前空間固有の知識の一例は、特定の名前空間の仕様における文である（たとえば、SVG 1.1[SVG11]はSVG"class"属性およびユーザーエージェントが属性をどのように解釈すべきかを説明する。同様にMathML 3.0[MATH30]はMathML"class"属性を説明する）。

  
    例:

    たとえば、以下のようにclass~="pastoral"を持つすべての要素にスタイル情報を割り当て可能である:
    
*.pastoral { color: green }  /* class~=pastoralを持つ全要素 */
または単に
    
.pastoral { color: green }  /* class~=pastoralを持つ全要素 */


    以下は、class~="pastoral"であるH1要素にのみスタイルを割り当てる:
    
H1.pastoral { color: green }  /* class~=pastoralを持つH1要素 */


    この規則を考えると、以下の最初のH1要素のテキストは緑色にならないが、2番目のH1要素は緑色となる:
    
<H1>Not green</H1>
<H1 class="pastoral">Very green</H1>

  

  "class"値のサブセットをマッチングさせるには、"."の直後に各値が存在しなければならない。

  
    例:

    たとえば、以下の規則は、"class"属性がスペース区切りのリストに"pastoral"と"marine"を含んだすべてのP要素とマッチする。
     
p.marine.pastoral { color: green }


    この規則は、class="pastoral blue aqua marine"とマッチするが、class="pastoral blue"とはマッチしない。
  

  
    注。 CSSは、"class"属性に非常に大きな力を与える。したがって著者は、ほとんど見栄えに関係しない要素（HTMLでのDIVやSPANなど）のスタイル情報に基づき、"class"属性を使用して割り当てた独自の"文書言語"を設計することができる。著者は、文書言語の構造要素が意味を認識し受け入れていることが多いので、このような用法を避けるべきである。著者が定義したクラス名は認識されないかもしれない。
  

  
    注: 要素が複数のクラス属性を持つ場合、クラスを検索する前にクラス値の間をスペースで連結されなければならない。しかし、執筆時点でワーキンググループはこの状況に到達する可能なすべての方法を認識していないため、本仕様においてこの動作は明示的に非規範的である。
  

  5.9 IDセレクタ

  文書言語は、ID型と宣言される属性を含んでよい。ID型属性の特殊さは、2つの属性が同値を持つことができないことにある。どのような文書言語でも、ID属性は一意に要素を識別するために使用できる。HTMLですべてのID属性は"id"と名付けられる。XMLアプリケーションは、異なるID属性に名前を付けてもよいが、同じ制約が適用される。

  文書言語のID属性は、文書ツリー内の1つの要素インスタンスに識別子を割り当て可能である。CSS IDセレクタは、その識別子に基づいて要素のインスタンスにマッチする。CSS IDセレクタは、"#"の直後にID値が続く識別子でなければならない。

  CSSはユーザーエージェントが要素のID属性を識別する方法を規定しないことに注意する。たとえば、ユーザーエージェントは文書のDTDを読んでよいし、決め打ちされた情報を持ってよいし、ユーザーに尋ねてよい。

  
    例:

    以下のIDセレクタは、ID属性値"chapter1"であるH1要素とマッチする。
    
h1#chapter1 { text-align: center }

  

  
    次の例でスタイル規則は、ID値"z98y"を持つ要素にマッチする。規則は、このようにP要素に対してマッチする:
    
<HEAD>
  <TITLE>Match P</TITLE>
  <STYLE type="text/css">
    *#z98y { letter-spacing: 0.3em }
  </STYLE>
</HEAD>
<BODY>
   <P id=z98y>Wide text</P>
</BODY>


    しかし、次の例でスタイル規則は、"z98y"のID値を持つH1要素とマッチする。規則は、この例でP要素とマッチしない。
    
<HEAD>
  <TITLE>Match H1 only</TITLE>
  <STYLE type="text/css">
    H1#z98y { letter-spacing: 0.5em }
  </STYLE>
</HEAD>
<BODY>
   <P id=z98y>Wide text</P>
</BODY>

  

  IDセレクタは属性セレクタよりも高い詳細度を持つ。たとえばHTMLで、セレクタ#p123は、カスケードの面で[id=p123]より詳細である。

  
    注。XML 1.0[XML10]において、属性が要素のIDを含むかについての情報は、DTDに含まれる。XMLを解析する際、ユーザーエージェントは常にDTDを読むとは限らないため、ある要素のIDが何であるか識別できないかもしれない。スタイルシートの設計者がこのような場合になると知っている、もしくは予想した場合、#p371の代わりに[name=p371]のように通常の属性セレクタを使用すべきである。しかし、通常の属性セレクタのカスケード順序は、IDセレクタとは異なる。[name=p371] {color: red ! important} のように、宣言に"!important"プロパティを追加する必要があるかもしれない。
  

  要素が複数のID属性を持つ場合、ID属性のすべては、IDセレクタの目的のために、その要素のIDとして扱われなければならない。このような状況は、xml:id[XMLID]、DOM3 Core[DOM-LEVEL-3-CORE]、XMLのDTD[XML10]と名前空間固有の知識の混合物を使用して達せられるだろう。

  5.10 疑似要素と疑似クラス

  CSS 2.1では、スタイルは通常、文書ツリー内の位置に基づいて要素に配置される。この単純なモデルは、多くの場合十分だが、一部の一般的な公開シナリオは、文書ツリーの構造に起因しない場合がある。たとえば、HTML 4（[HTML4]を参照）で、段落の最初の行を参照する要素はなく、したがって単体のCSSセレクタがその行を参照できないことになる。

  CSSは文書ツリーの外側にある情報に基づいた書式設定を可能にするために、擬似要素や擬似クラスの概念を導入する。

  擬似要素は、文書言語によって指定された範囲を超えて、文書ツリーに関する抽象概念を作成する。たとえば、文書言語は、要素の内容の最初の文字または最初の行にアクセスする仕組みを提供してない。CSS擬似要素は、スタイルシートの設計者がこのアクセスできない情報を参照することができる。また、擬似要素はスタイルシートの設計者がソース文書内で存在しない内容にスタイルを割り当てる手段を提供してよい（たとえば、:beforeおよび:after擬似要素が生成内容にアクセスできる）。

    疑似クラスは、要素の名前や属性、内容以外の特性、原則として、文書ツリーから推測できない特性上の要素を分類する。疑似クラスは、ユーザーがドキュメントと対話しながら、要素が擬似クラスを獲得したり喪失したりするという意味で、動的であってよい。例外は、文書ツリーから推測できる':first-child'、および場合によっては文書ツリーから推測できる':lang()'である。
  擬似要素や擬似クラスのいずれも文書ソースや文書ツリーに出現しない。

  疑似クラスはセレクタ内のどこにでも許可されるが、擬似要素はセレクタの最後の単純セレクタの後にのみ追加してよい。

  擬似要素と擬似クラスの名前は、大文字と小文字を区別しない。

  一部の擬似クラスは相互に排他的である一方、同じ要素に同時に適用可能なものもある。規則が競合する場合、通常のカスケード順序が結果を決定する。

  5.11 擬似クラス

  5.11.1 :first-child擬似クラス

  :first-child擬似クラスは、ある別の要素における最初の子要素にマッチする。

  
    例:

    次の例では、セレクタはDIV要素の最初の子であるすべてのP要素にマッチする。規則は、DIVの第一段落のインデントを禁止する。
    
div > p:first-child { text-indent: 0 }
このセレクタは、以下の断片でDIV中のPにマッチする:
    
<P> The last P before the note.
<DIV class="note">
   <P> The first P inside the note.
</DIV>
しかし、以下の断片で2つめのPにはマッチしない:
    
<P> The last P before the note.
<DIV class="note">
   <H2>Note</H2>
   <P> The first P inside the note.
</DIV>

  

  
    例:

    次の規則は、P要素の子孫であって最初の子であるEM要素を'bold'にフォントの太さを設定する:
    
p:first-child em { font-weight : bold }

  

  匿名ボックスは、文書ツリーの一部ではないので、最初の子を数えるときに匿名ボックスがカウントされないことに注意する。

  
    たとえば、EMについて:
    
<P>abc <EM>default</EM> 
これは、Pの最初の子である。
  

  次の2つのセレクタは等価である:
  
* > a:first-child   /* A要素は任意の要素の最初の子 */
a:first-child       /* 上に同じ */


  5.11.2 リンク擬似クラス: :linkと:visited

  ユーザエージェントは一般に、未訪問のリンクと訪問済みのリンクを区別して表示する。CSSはそれらを区別するために擬似クラス':link'および':visited'を提供する:

  :link擬似クラスは未訪問のリンクに適用される。

    :visited擬似クラスは、ユーザーが一度訪問したリンクに適用される。
  ユーザーエージェントは、ある時点で訪問済みリンクを（未訪問の）':link'状態に戻してよい。

  2つの状態は互いに排他的である。

  どの要素がハイパーリンクのソースアンカーかについては、文書言語が決定する。たとえば、HTML4で、リンク擬似クラスは"href"属性を持つA要素に適用される。したがって、次の2つのCSS 2.1の宣言は、同様の効果がある:
  
a:link { color: red }
:link  { color: red }


  
    例:

    次のリンクの場合:
    
<A class="external" href="http://out.side/">external link</A>
訪問済みの場合、この規則は:
    
a.external:visited { color: blue }
青色にする。
  

  注。スタイルシート著者はユーザーの同意なしに訪問しているサイトかどうかを判断する上で:linkおよび:visited擬似クラスを悪用することが可能である。

  したがって、ユーザーエージェントは、未訪問のリンクなどのすべてのリンクを扱う一方で、訪問済みまたは未訪問のリンクを異なるものとしてレンダリングし、ユーザのプライバシーを保護する他の手段を実装してよい。プライバシーの取り扱いの詳細については[P3P]を参照のこと。

  5.11.3 動的疑似クラス: :hover、:active、:focus

  対話的なユーザエージェントは、しばしばユーザーの動作に応じてレンダリングを変更する。CSSは、一般的な場合の3つの擬似クラスを提供する:

  :hover擬似クラスは、ユーザが（ポインティングデバイスで）アクティブではない要素を指定する間に適用される。たとえば、視覚系ユーザエージェントは、要素が生成したボックス上にカーソル（マウスポインタ）を置いたとき、この擬似クラスを適用できる。インタラクティブメディアをサポートしないユーザエージェントは、この擬似クラスをサポートする必要はない。インタラクティブメディアをサポートする一部の適合ユーザエージェントは、この擬似クラスをサポートできないかもしれない（たとえば、ペンデバイス）。

    :active擬似クラスは、ユーザーが要素をアクティブにする間に適用される。たとえば、ユーザーがマウスのボタンを押してから離すまでの間である。

    :focus疑似クラスは、フォーカスしている（キーボードイベントやテキスト入力の他の形態を受け入れる）間に適用する。
  要素は複数の擬似クラスと同時にマッチしてよい。

  CSSは、どの要素が上記の状態にあるか、どのように状態が入力または出力されるかを定義しない。スクリプトは、要素がユーザーイベントに反応するかどうかを変更してよく、異なるデバイスやユーザーエージェントは要素を指示したり、アクティブにするさまざまな方法があってよい。

  ':active'または':hover'である要素の親がその状態になっているかどうかもCSS 2.1は定義しない。

  ユーザエージェントは、擬似クラスの遷移のために現在表示されている文書のリフローを要求しない。たとえば、スタイルシートは、非アクティブなリンクよりもアクティブなリンクの'font-size'を大きくするよう指定してよいが、これは読者がリンクを選択する際の文字の位置を変更する可能性があるため、ユーザーエージェントは対応するスタイル規則を無視してよい。

  
    例:
    
A:link    { color: red }    /* 未訪問のリンク */
A:visited { color: blue }   /* 訪問済みリンク */
A:hover   { color: yellow } /* ユーザがマウスポインタを重ねている */
A:active  { color: lime }   /* アクティブなリンク */


    A:hoverはA:linkとA:visitedの後に配置しなければならないことに注意する。そうでなければカスケーディング規則がA:hover規則の'color'プロパティを無効にしてしまうことになる。同様に、A:activeはA:hoverの後に配置されるため、A要素上でアクティブとホバーのどちらの場合でもアクティブ色（ライム色）が適用される。
  

  
    例:

    動的擬似クラスを組み合わた例:
    
a:focus { background: yellow }
a:focus:hover { background: white }


    最後のセレクタは、:focus疑似クラスかつ:hover擬似クラスであるA要素とマッチする。
  

  フォーカスアウトラインの表示については、動的なフォーカスアウトラインの節を参照のこと。

  
    注。 CSS1では、':active'疑似クラスは、':link'および':visited'と相互に排他的であった。これはもはや当てはまらない。要素は、':visited'と':active'（または':link'と':active'）の両方を共存でき、スタイル宣言が適用されるかどうかを通常のカスケード規則が決定する。
  

  
    注。 また、CSS1において':active'疑似クラスはリンクにのみ適用されることに注意する。
  

  5.11.4 言語疑似クラス :lang

  文書言語で要素の自然言語の指定方法を決められた場合、その言語に基づく要素とマッチするようなCSSのセレクタを記述できる。たとえば、HTML[HTML4]で、"lang"属性、META要素、可能ならば（HTTPヘッダのような）プロトコルからの情報の組み合わせで言語は決定される。XMLは、xml:langと呼ばれる属性を使用し、言語を決定するための他の文書の言語固有の方法があってよい。

  擬似クラス':lang(C)'は言語Cの要素が存在すればマッチする。単に識別子のCに対して要素の言語の値と等しい場合でも、ハイフン区切りの部分文字列でも、あたかも'|='演算子によって実行されたかのように同じ方法でマッチする。要素の言語の値に対するCのマッチングは、ASCIIの範囲内の文字において大文字と小文字を区別せずに行われる。識別子Cは妥当な言語名である必要はない。

  Cは空であってはならない。

  注: 文書やプロトコルは、BCP 47[BCP47]およびその後続のコードを用いての言語の指示が推奨される。また、XMLベースの文書の場合は"xml:lang"属性による言語の指示が推奨される[XML10]。 "FAQ: Two-letter or three-letter language codes."を参照のこと。

  
    例:

    次の規則は、カナダでのフランス語またはドイツ語のいずれかのHTML文書に対して引用符を設定する:
    
html:lang(fr-ca) { quotes: '« ' ' »' }
html:lang(de) { quotes: '»' '«' '\2039' '\203A' }
:lang(fr) > Q { quotes: '« ' ' »' }
:lang(de) > Q { quotes: '»' '«' '\2039' '\203A' }


    2番目の規則のペアは、実際には親要素の言語に従ってQ要素に'quotes'プロパティを設定する。一般に引用符の選択は、引用文自身ではなく、引用文の周囲にある要素の言語に基づくため、このような方法がとられる。英文中のフランス語の断片"à L' improviste"は英語の引用符を使用するのである。
  

  
    注 [lang|=xx]と:lang(xx)の違いに注意する。このHTMLの例では、BODYのみ[lang|=fr]にマッチする（LANG属性を持つため）。しかし、BODYとPの両方が:lang(fr)にマッチする（両方ともフランス語のため）。
    <body lang=fr>
  <p>Je suis Français.</p>
</body>
  

  5.12 擬似要素

  擬似要素は、以下と別の章で説明する例外を除いてCSSの実際の要素のように振る舞う。

  以下の節では、すべての場合における":first-line"や':first-letter'の正確なレンダリングを定義しないことに注意する。将来のCSSレベルは、これらをより正確に定義するかもしれない。

  5.12.1 :first-line疑似要素

  :first-line擬似要素は、段落の1行目に整形された内容に特別なスタイルを適用する。たとえば:
  
p:first-line { text-transform: uppercase }


  上記の規則は、"全段落の1行目の文字を大文字に変更する"ことを意味する。しかし、セレクタ"P:first-line"は実在するどのHTML要素ともマッチしない。このセレクタは、適合ユーザエージェントが全段落の先頭に挿入する擬似要素とマッチする。

  1行目の長さは、ページの幅、フォントサイズなどを含む多数の要因に依存することに注意する。したがって、次のようなよく目にするHTMLの段落は:
  
<P>This is a somewhat long HTML 
paragraph that will be broken into several 
lines. The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.</P>


  次のように改行されたとすると:
  
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag 
sequence. The other lines will be treated as 
ordinary lines in the paragraph.


  :first-lineの仮想タグを含むようにユーザーエージェントによって"書き換え"られる。この仮想タグは、プロパティの継承方法を示すのに役立つ。
  
<P><P:first-line> This is a somewhat long HTML 
paragraph that </P:first-line> will be broken into several
lines. The first line will be identified 
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.</P>


  擬似要素が実在の要素を分断してしまう場合、その要素を一度閉じて再び開くことで期待する効果を得る。したがって、SPAN要素を用いて前述の段落をマークアップする場合:
  
<P><SPAN class="test"> This is a somewhat long HTML
paragraph that will be broken into several
lines.</SPAN> The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.</P>


  :first-line仮想タグの挿入時に、ユーザエージェントはSPANの開始タグと終了タグをシミュレーションできる。
  
<P><P:first-line><SPAN class="test"> This is a
somewhat long HTML
paragraph that will </SPAN></P:first-line><SPAN class="test"> be
broken into several
lines.</SPAN> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the 
paragraph.</P>


  :first-line擬似要素は、ブロックコンテナ要素にのみ付属可能である。

  要素の"最初に整形される行"は、同じフローでブロックレベルの子孫の内部に出現してよい（すなわち、配置もフロートもされていない、ブロックレベルの子孫）。たとえば、<DIV><P>This line...</P></DIV>のDIVの1行目は、Pの1行目である（PとDIVの両方がブロックレベルであると仮定）。

  テーブルセルまたはインラインブロックの最初の行は、最初に整形された祖先要素の行にすることはできない。したがって、<DIV><P STYLE="display: inline-block">Hello<BR>Goodbye</P> etcetera</DIV>において、DIVの最初に整形される行は"Hello"の行ではない。

  なお、この断片のPの1行目:<p><br>First...は、いずれの文字も含まないことに注意する（HTML 4でBRの既定のスタイルを仮定）。単語"First"は、最初に整形される行ではない。

  ユーザーエージェントは、あたかもfirst-line疑似要素の仮想開始タグがちょうど最も内側のブロックレベル要素内にネストされていたかのように振る舞うべきである。（CSS1とCSS2はこのケースを暗に守っていたため、作者はこの動作に依存すべきではない。）次に例を示す。この断片に対する仮想タグは
  
<DIV>
  <P>First paragraph</P>
  <P>Second paragraph</P>
</DIV>


  このようになる
  
<DIV>
  <P><DIV:first-line><P:first-line>First paragraph</P:first-line></DIV:first-line></P>
  <P><P:first-line>Second paragraph</P:first-line></P>
</DIV>


  :first-line擬似要素はインラインレベル要素に類似するが、一定の制限がある。:first-line擬似要素に適用されるプロパティは次の通り: フォントプロパティ、色のプロパティ、背景のプロパティ、'word-spacing'、'letter-spacing'、'text-decoration'、'text-transform'、'line-height'。ユーザーエージェントは、他のプロパティを同様に適用してよい。

  5.12.2  :first-letter疑似要素

  ある行に他の内容（画像やインラインテーブルなど）が先行しない場合、:first-letter擬似要素は、ブロックの1行目の最初の文字を選択しなければならない。:first-letter擬似要素は、一般的な印刷効果である"イニシャルキャップ"および"ドロップキャップ"として使用してよい。'float'プロパティが'none'である場合、この種類の先頭文字はインラインレベル要素と、それ以外の場合はフロート要素と類似する。

  次に述べるものは、:first-letter擬似要素に適用されるプロパティである: フォントのプロパティ、'text-decoration'、'text-transform'、'letter-spacing'、'word-spacing'（適切な場合）、'line-height'、'float'、'vertical-align'（'float'が'none'の場合のみ）、マージンプロパティ、パディングプロパティ、ボーダープロパティ、色のプロパティ、背景のプロパティ。ユーザーエージェントは、他のプロパティと同様に適用されてよい。活字として正確なイニシャルキャップまたはドロップキャップをレンダリングできるようにするために、ユーザーエージェントは、通常の要素の場合とは異なった行の高さや文字の形状に基づく幅と高さを選択してよい。CSS3は、先頭文字に適用される特定のプロパティを持つことが期待されている。

  
    この例では、イニシャルキャップの可能なレンダリングを示している。first-letter擬似要素によって継承される'line-height'は1.1であるが、この例ではユーザーエージェントが異なる先頭文字の高さを計算しているため、最初の2行の間に不要なスペースが発生しないことに注意する。また、先頭文字の仮想開始タグがSPANの内部にあるため、先頭文字のフォントの太さはnormalであり、boldでないことにも注意する。
    
p { line-height: 1.1 }
p:first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
<p><span>Het hemelsche</span> gerecht heeft zich ten lange lesten<br>
Erbarremt over my en mijn benaeuwde vesten<br>
En arme burgery, en op mijn volcx gebed<br>
En dagelix geschrey de bange stad ontzet.


    
      
    
  

  
    次のCSS 2.1はドロップキャップの先頭文字の範囲を2行にする。
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
 <HEAD>
  <TITLE>Drop cap initial letter</TITLE>
  <STYLE type="text/css">
   P              { font-size: 12pt; line-height: 1.2 }
   P:first-letter { font-size: 200%; font-style: italic;
                    font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  </STYLE>
 </HEAD>
 <BODY>
  <P><SPAN>The first</SPAN> few words of an article
    in The Economist.</P>
 </BODY>
</HTML>


    この例は次のように整形される:

    
         [説明]
    

    仮想タグは次のとおり:
    
<P>
<SPAN>
<P:first-letter>
T
</P:first-letter>he first
</SPAN> 
few words of an article in the Economist.
</P>


    :first-line擬似要素の開始タグが右側にあるブロック要素の開始タグの後に挿入されると同時に、:first-letter擬似要素のタグはコンテンツ（すなわち、先頭文字）に隣接することに注意する。
  

  伝統的なドロップキャップ整形を実現するため、たとえばベースラインを揃えるために、ユーザエージェントはフォントサイズを近似してよい。また、整形の際、グリフのアウトラインを考慮してよい。

  句読点（すなわち、Unicode[UNICODE]で定義されている文字、"open"（Ps）、"close"（Pe）、"initial"（Pi）、"final"（Pf）、"other"（Po）の句読点クラス）が先行または先頭文字の後に続く場合、次のように文字が含まれるべきである:

  
       [説明]
  

  ':first-letter'は先頭文字が数字である場合も適用される。たとえば、"67万ドルのお金がたくさんある。"の"6"など。

  :first-letter擬似要素は、ブロックコンテナ要素に適用される。

  :first-letter擬似要素は、テキストを含む、または同じフローでテキストが含まれた子孫を持つすべての要素で使用できる。ユーザーエージェントは、その最初のテキストが子孫に存在する場合でも、first-letter擬似要素の仮想開始タグが要素の最初のテキストの前にいるかのように振る舞うべきである。

  
    例:

    以下に例を示す。このHTMLの断片に対する仮想タグ:
    
<div>
<p>The first text.


    is:
    
<div>
<p><div:first-letter><p:first-letter>T</...></...>he first text.

  

  テーブルセルまたはインラインブロックの先頭文字は、祖先要素の先頭文字にすることはできない。したがって、<DIV><P STYLE="display: inline-block">Hello<BR>Goodbye</P> etcetera</DIV>において、DIVの先頭文字は"H"ではない。実際、DIVは先頭文字を持たない。

  先頭文字は、最初に整形される行で出現しなければならない。たとえば、この断片: <p><br>First...最初の行はいずれの文字も含まず、":first-letter"はマッチしない（HTML 4でBRの既定のスタイルを仮定）。具体的には、"First"の"F"とはマッチしない。

  要素がリスト項目（'display: list-item'）の場合、':first-letter'は、マーカーの後の主ボックスの先頭文字に適用される。ユーザーエージェントは、'list-style-position: inside'を伴うリストの項目上の':first-letter'を無視してよい。要素が':before'か':after'の内容を持つ場合、':first-letter'はそのコンテンツを含む要素の先頭文字に適用される。

  たとえば、規則'p:before {content: "Note: "}'の後で、セレクタ'p:first-letter'は"Note"の"N"とマッチする。

  一部の言語は、特定の文字の組み合わせを扱う方法について、特定の規則があるかもしれない。たとえば、オランダ語において、文字結合"ij"が単語の先頭に出現する場合、どちらも:first-letter擬似要素内に含まれるよう考慮されるべきである。

  <p>'<em>T...における"'T"のように、同じ要素内で先頭文字を形成しないおそれのある場合、ユーザーエージェントは、要素の1つからもしくは両方の要素からfirst-letter擬似要素を作成してよいし、または単に擬似要素を作成しなくてよい。

  同様に、ブロックの先頭文字が行の先頭でない（たとえば双方向の並べ替えに起因する）場合、ユーザーエージェントは擬似要素を作成する必要はない。

  
    例:

    次の例は、擬似要素が重なった場合にどのような相互作用をもたらすかを示している。各P要素の先頭文字は、'24pt'のフォントサイズで緑色になる。最初に整形される行の残りは'青'になり、残りの段落は'赤'になる。
    
p { color: red; font-size: 12pt }
p:first-letter { color: green; font-size: 200% }
p:first-line { color: blue }

<P>Some text that ends up on two lines</P>


    単語"ends"の前に改行が出現すると仮定すると、この断片に対して仮想タグは:
    
<P>
<P:first-line>
<P:first-letter> 
S 
</P:first-letter>ome text that 
</P:first-line> 
ends up on two lines 
</P>


    :first-letter要素が:first-line要素の内部にあることに注意する。:first-lineに設定されたプロパティは、:first-letterに継承されるが、同じプロパティが:first-letterに設定される場合は上書きされる。
  

  5.12.3  :beforeおよび:after疑似要素

  ':before'および':after'擬似要素'は、ある要素の内容の前あるいは後に生成コンテンツを挿入可能である。これらは、生成テキストの節で説明される。

  
    例:
    
h1:before {content: counter(chapno, upper-roman) ". "}

  

  :first-letterおよび:first-line擬似要素が:beforeおよび:afterを用いて生成されたコンテンツを持つ要素に適用される場合、これらは生成されたコンテンツを含む要素の先頭文字または先頭行に適用される。

  
    例:
    
p.special:before {content: "Special! "}
p.special:first-letter {color: #ffd800}


    これは、"Special!"の"S"を金色にレンダリングする。
  

  6 プロパティ値とカスケーディング、継承の割り当て

  
    目次

    
        6.1 指定値、算出値、実効値

        6.1.1 指定値

          6.1.2 算出値

          6.1.3 使用値

          6.1.4 実効値
        

      
        6.2 継承

        6.2.1 'inherit'値
        

      6.3 @import規則

      
        6.4 カスケード処理

        6.4.1 カスケード処理の順序

          6.4.2 !important規則

          6.4.3 セレクタの詳細度の計算

          6.4.4 非CSSの見栄えヒントの優先順位
        
    

  6.1 指定値、算出値、実効値

  ユーザエージェントは文書を解析し、文書ツリーを構築した時点で、ツリーのすべての要素に対して、対象のメディアタイプに適用されるすべてのプロパティの値を割り当てなければならない。

  プロパティの最終値は、4段階の計算結果である。値は仕様を通じて決定され（"指定値"）、その後、継承に使用される値（"算出値"）に解決される。さらに、必要に応じて絶対値に変換され（"使用値"）、そして最終的にローカル環境の制限に応じて変換される（"実効値"）。

  6.1.1 指定値

  ユーザエージェントは、最初に以下の手順（優先順）に基づいて各プロパティに指定値を割り当てなければならない:

  カスケード処理で値を得られる場合、これを使用する。ただし、値が'inherit'である場合、指定値は、下記の“'inherit'という値”定義される場合を除く。

    そうでなければ、プロパティが継承し、かつ要素が文書ツリーのルートではない場合、親要素の計算値を使用する。

    そうでなければ、プロパティの初期値を使用する。各プロパティの初期値は、プロパティの定義で示される。
  6.1.2 算出値

  指定値は、カスケード処理時に算出値に解決される。たとえば、URIを絶対URIにし、'em'や'ex'単位はピクセルまたは絶対的な長さに計算される。算出値は、ユーザエージェントに文書のレンダリングを要求しない。

  ユーザーエージェントが絶対URIに解決できないURIの算出値は、指定値である。

  プロパティの算出値は、プロパティの定義の中で算出値の行で規定されるように決定される。指定値が'inherit'である算出値の定義については、継承の節を参照のこと。

  算出値は、行'適用対象'で定義され、プロパティが適用されない場合でも存在する。ただし、一部のプロパティは、プロパティが要素に適用されるかどうかに依存する要素のプロパティの算出値を定義してよい。

  6.1.3 使用値

  算出値は、できる限り文書を整形せずに処理される。しかし、一部の値は、文書が配置されるときのみ決定できる。たとえば、ある要素の幅が要素の包含ブロックの特定の割合になるように設定される場合、包含ブロックの幅が決定されるまで幅を決定できない。使用値とは、算出値を取り、残りの依存関係を解決した絶対値の結果である。

  6.1.4 実効値

  使用値は、原則的にレンダリングに使用される値だが、ユーザエージェントは、与えられた環境で値を利用できない場合がある。たとえば、ユーザエージェントは、整数ピクセル幅のボーダーをレンダリングするため、計算された幅を近似する必要があるかもしれない。またユーザエージェントが、白と黒の代わりにフルカラーを使用するように強制される場合がある。実効値は、使用値にすべての近似を適用した後の値である。

  6.2 継承

  上記のように一部の値は、文書ツリー内の要素の子によって継承される。継承の有無は、各プロパティが定義する。

  
    強調要素（EM）の内部にH1要素があるとする:
    
<H1>The headline <EM>is</EM> important!</H1>


    EM要素に色が割り当てられていない場合、強調された"is"は、親要素の色を継承する。よって、もしH1が青色を持つならば、EM要素も同様に青になる。
  

  継承が発生すると、要素は算出値を継承する。親要素からの算出値は、指定値と子の算出値の両方となる。

  
    例:

    たとえば、以下のスタイルシートを与えられ:
    
body { font-size: 10pt }
h1 { font-size: 130% }


    次の文書断片があるとすると:
    
<BODY>
  <H1>A <EM>large</EM> heading</H1>
</BODY>


    H1要素の'font-size'プロパティは、算出値'13pt'（親の値10ptの130%）を持つ。'font-size'の算出値が継承されるため、EM要素も同様に算出値'13pt'を持つ。ユーザエージェントが13ptのフォントを入手できない場合、H1とEMの'font-size'の実効値は、たとえば、'12pt'となる。
  

  継承は文書ツリーに従い、匿名ボックスによって横取りされないことに注意する。

  6.2.1 'inherit'値

  各プロパティは、カスケードされた値'inherit'を持ってもよい。この値は、与えられた要素に対して、プロパティが要素の親の算出値を指定値として取ることを意味する。'inherit'値は、値の継承を強制するために使用でき、正常に継承されないプロパティにも使用できる。

  'inherit'値がルート要素に設定される場合、プロパティには初期値が代入される。

  
    例:

    以下の例では、BODY要素に'color'および'background'プロパティが設定されている。他のすべての要素に'color'値は継承され、背景は透過となる。この規則がユーザスタイルシートの一部である場合、文書全体に白の背景色と黒の前景色が適用される。
    
body {
  color: black !important; 
  background: white !important;
}

* { 
  color: inherit !important; 
  background: transparent !important;
}

  

  6.3 @import規則

  '@import'規則は、ユーザーが他のスタイルシートからスタイル規則の取り込みを可能にする。CSS 2.1では、あらゆる@import規則は、他のすべての規則の前に置かなければならない（@charset規則が存在する場合を除く）。ユーザエージェントが@import規則を無視しなければならない条件については、構文解析の節を参照のこと。'@import'キーワードは、組み込むスタイルシートのURIを続けなければならない。文字列も許容される。文字列は前後にurl(...)を持つかのように解釈される。

  
    例:

    次の行は意味上等価であり、2つの'@import'構文（"url()"と最小限の文字列）を示している:
    
@import "mystyle.css";
@import url("mystyle.css");

  

  ユーザーエージェントがサポートしないメディアタイプのリソースの取得を回避するよう、著者は、メディア依存な@importを指定してよい。この条件付き取り込みは、URIの後にコンマ区切りのメディアタイプを指定する。

  
    例:

    次の規則は、メディア依存な@import規則を指示する:
    
@import url("fineprint.css") print;
@import url("bluish.css") projection, tv;

  

  メディアタイプがない場合、無条件で取り込みがされる。これはメディア指定'all'と同じ効果を持つ。メディアのリストとマッチする場合のみ、対象メディアは有効である。

  メディアリスト内の項目の1つが対象メディアであるか'all'の場合、対象メディアはマッチする。

  なお、メディアクエリはメディアリストの構文とマッチングの定義を拡張する。[MEDIAQ]

  同じスタイルシートが、複数の場所にある文書に取り込まれるかリンクされる場合、ユーザエージェントは、各リンクをあたかも別のスタイルシートにリンクされているように処理（またはそうするかのように機能）しなければならない。

  6.4 カスケード処理

  スタイルシートは、著者、ユーザ、およびユーザエージェントの3つの異なる起源を持ってよい。

  著者: 著者は、文書言語の規則に従ってソース文書にスタイルシートを指定する。たとえばHTMLで、スタイルシートを文書に含める、または外部にリンクしてよい。

    ユーザー: ユーザーは特定の文書に対してスタイル情報を指定してよい。たとえば、ユーザーがスタイルシートを含むファイルを指定してよいし、ユーザーエージェントがユーザースタイルシートを生成する（またはあるかのように振る舞う）インタフェースを提供してよい。

    
      ユーザーエージェント: 適合ユーザーエージェントはデフォルトスタイルシートを適用（またはそうしたかのように動作）しなければならない。ユーザーエージェントのデフォルトスタイルシートは、文書言語の一般的な見栄えの意図を満たすように文書言語の要素を表現すべきである（たとえば視覚系ブラウザのために、HTMLのEM要素を斜体フォントで表示する）。HTML文書で推奨されるデフォルトスタイルシートについてはHTMLのサンプルスタイルシートを参照のこと。

      ユーザーはデフォルトスタイルシートに影響を与えるシステム設定（たとえば、システム色）を変更してよいことに注意する。ただし、一部のユーザーエージェントの実装は、デフォルトスタイルシートの値を変更することができない。
    
  これら3つの起源を持つスタイルシートは、範囲内で重複し、カスケード規則にしたがって相互に作用する。

  CSSカスケード処理は、各スタイル規則に重みを割り当てる。複数の規則が適用されるとき、最大の重みを持つ規則が優先される。

  デフォルトでは、著者のスタイルシートの規則は、ユーザースタイルシートの規則よりも重みを持つ。しかし、優先順位は"!important"規則により、逆になる。すべてのユーザーと著者の規則は、ユーザーエージェントのデフォルトスタイルシートの規則よりも重みを持つ。

  6.4.1 カスケード処理の順序

  要素とプロパティの組み合わせの値を見つけるために、ユーザーエージェントは、以下のソート順を適用しなければならない:

  対象のメディアタイプに対して、問題の要素とプロパティに適用されるすべての宣言を検索する。関連するセレクタが対象の要素にマッチし、対象メディアすべての@media規則がスタイルシートに到達するために使用した、すべてのリンクおよびパス上での宣言を含むメディアリストとマッチする場合、宣言は適用される。

    ソートは重要性（通常、important）と起源（著者、ユーザー、ユーザーエージェント）に従う。優先順位は昇順で:

      ユーザーエージェントの宣言

        ユーザーの通常宣言

        著者の通常宣言

        著者のimportant宣言

        ユーザーのimportant宣言
      

    同じ重要性と起源をもつ規則を、セレクタの詳細度によってソートする: より詳細なセレクタが、より一般的なものを上書きする。擬似要素と擬似クラスはそれぞれ、通常の要素とクラスとみなされる。

    最後に、指定された順序でソートする: 2つの宣言が同じ重み、起源と詳細度を持つ場合、最後の指定された規則が適用される。取り込まれたスタイルシートの宣言は、スタイルシート自体の宣言に先行するものと考えられる。
  個々の宣言の"!important"設定はさておき、この戦略はユーザーよりも著者のスタイルシートにより大きな重みを与える。ユーザーエージェントは、たとえばプルダウンメニューから、ユーザーに特定の著者のスタイルシートの影響をオフにする機能を付与しなければならない。UAAG 1.0のチェックポイント4.14への適合性は、この条件を満たす[UAAG10]。

  6.4.2 !important規則

  CSSは、著者とユーザースタイルシート間のパワーバランスを作成しようとする。デフォルトでは、著者スタイルシートの規則は、ユーザースタイルシートで上書きされる（カスケード規則3を参照）。

  しかし、バランスのために"!important"宣言（宣言の後に区切りトークン"!"とキーワード"important"が続く）は通常の宣言よりも優先される。著者とユーザースタイルシートのどちらも"!important"宣言を含んでよく、ユーザー"!important"規則は、著者"!important"規則を上書きする。このCSSの機能は、特殊な要件（大きなフォント、色の組み合わせ、など）見栄えの制御をユーザーに与えることにより、文書のアクセシビリティを向上させる。

  簡略化プロパティを"!important" 宣言すること（たとえば、'background'）は、そのサブプロパティのすべてを"!important"と宣言することと等価である。

  
    例:

    次の例で、ユーザースタイルシートの最初の規則は"!important"宣言を含んでおり、著者スタイルシート内の対応する宣言を上書きする。2番目の宣言も、"!important"とマークされたものが優先する。しかし、ユーザースタイルシートの3番目の規則は"!important"ではないので、著者スタイルシートの2番目の規則（簡略化プロパティでスタイル設定するために起こる）に上書きされる。また、著者の3番目の規則は、2番目の規則に"!important"があるので、著者の2番目の規則に上書きされる。これは "!important" 宣言が、著者スタイルシート内でも機能することを示している。
    
/* ユーザースタイルシートから */
p { text-indent: 1em !important }
p { font-style: italic !important }
p { font-size: 18pt }

/* 著者スタイルシートから */
p { text-indent: 1.5em !important }
p { font: normal 12pt sans-serif !important }
p { font-size: 24pt }

  

  6.4.3 セレクタの詳細度の計算

  セレクタの詳細度は、次のように計算される。

  宣言が、'style'属性からではなく、セレクタを持つ規則の場合は1としてカウントし、そうでなければ0（=a）となる（HTMLでは、要素の"style"属性値は、スタイルシート規則である。これらの規則はセレクタを持たないので、a=1、b=0、c=0、かつd=0。）

    セレクタ内のID属性の数を数えた、その数（=b）

    セレクタ内の他の属性および擬似クラスを数えた、その数（=c）

    セレクタ内の要素名と疑似要素を数えた、その数（=d）
  詳細度は、セレクタの形式に基づいている。特に、セレクタ形式"[ID=P33]"のセレクタは、たとえid属性が"ID"としてソース文書のDTD内で定義されていても、属性セレクタ（a=0、b=0、c=1、d=0）としてカウントされる。

  （十分大きな基数の記進法で）abcdの4つの数値を連結すると、詳細度が得られる。

  
    例:

    いくつかの例を挙げる:
    
 *             {}  /* a=0 b=0 c=0 d=0 -> 詳細度 = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> 詳細度 = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> 詳細度 = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> 詳細度 = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> 詳細度 = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> 詳細度 = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> 詳細度 = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> 詳細度 = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> 詳細度 = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> 詳細度 = 1,0,0,0 */

  

  
    
<HEAD>
<STYLE type="text/css">
  #x97z { color: red }
</STYLE>
</HEAD>
<BODY>
<P ID=x97z style="color: green">
</BODY>


    上記の例で、P要素の色は緑色となる。より高い詳細度を持っているので、"style"属性の宣言は、カスケーディング規則3のためにSTYLE要素内のものを上書きする。
  

  6.4.4 非CSSの見栄えヒントの優先順位

  ユーザーエージェントは、HTMLソースドキュメントの体裁用の属性を尊重してよい。その場合、これらの属性は0に等しい詳細度と対応するCSS規則に変換され、それらは著者スタイルシートの先頭に挿入されたかのように扱われる。したがって、後のスタイルシート規則によって上書きされることがある。移行段階では、この方針はスタイル属性のスタイルシートとの共存が容易となる。

  HTMLのために、以下のリストにない任意の属性のための見栄えを考慮すべきである: abbr, accept-charset, accept, accesskey, action, alt, archive, axis, charset, checked, cite, class, classid, code, codebase, codetype, colspan, coords, data, datetime, declare, defer, dir, disabled, enctype, for, headers, href, hreflang, http-equiv, id, ismap, label, lang, language, longdesc, maxlength, media, method, multiple, name, nohref, object, onblur, onchange, onclick, ondblclick, onfocus, onkeydown, onkeypress, onkeyup, onload, onload, onmousedown, onmousemove, onmouseout, onmouseover, onmouseup, onreset, onselect, onsubmit, onunload, onunload, profile, prompt, readonly, rel, rev, rowspan, scheme, scope, selected, shape, span, src, standby, start, style, summary, title, type （LI、OLとUL要素を除く）, usemap, value, valuetype, version.

  他の言語の場合、すべての文書言語ベースのスタイルは、対応するCSSに変換されなければならず、ユーザーエージェントレベルでカスケードを入力するか、HTMLの見栄えのヒントと同様に、著者スタイルシートの先頭に置かるようなゼロの詳細度を持つ著者レベルの規則のいずれかとして扱われなければならない。

  
    例:

    次のユーザースタイルシートは、すべての文書で'B'要素のフォントの太さ、およびXMLドキュメント内のcolor属性を持つ'font'要素の色を上書きする。これは、HTML文書内のcolor属性を持つ任意の'font'要素の色には影響を与えない:
    
b { font-weight: normal; }
font[color] { color: orange; }


    しかし、以下はすべての文書のfont要素の色を上書きする。
    
font[color] { color: orange ! important; }

  

  7 メディアタイプ

  
    目次

    7.1メディアタイプの手引き

      
        7.2メディア依存なスタイルシートの指定

        7.2.1 @media規則
        

      
        7.3認識されるメディアタイプ

        7.3.1メディアグループ
        
    

  7.1 メディアタイプの手引き

  スタイルシートの最も重要な特徴のひとつは、画面上に、紙の上に、音声シンセサイザーに、点字デバイスになどの異なるメディア上への文書の表示方法を指定することである。

  特定のCSSプロパティは、特定のメディア用に設計されている（例えば、'page-break-before' プロパティは、ページメディアに適用される）。しかし、時折異なるメディアタイプのスタイルシートはプロパティを共有することがあるが、そのプロパティに異なる値が必要な場合がある。たとえば、'font-size'プロパティは、画面と印刷メディアの両方に有用である。2つのメディアタイプは、共通のプロパティに別の値を必要とするほど異なるものである。一般に、文書は紙の上よりもコンピュータの画面上でより大きなフォントが必要になる。したがって、スタイルシートまたはスタイルシートの一部では、特定のメディアタイプの適用を表現する必要がある。

  7.2 メディア依存なスタイルシートの指定

  スタイルシートのメディア依存関係を指定するには2つの方法が現在ある。

  
      @mediaまたは@import規則でスタイルシートから対象メディアを指定する。

      
        例:
        
@import url("fancyfonts.css") screen;
@media print {
  /* 印刷用のスタイルシートがここに入る */
}

      
    

    言語内の対象メディアを指定する。たとえば、HTML 4（[HTML4]）では、LINK要素の"media"属性が外部スタイルシートの対象メディアを指定する。

      
        
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
   <HEAD>
      <TITLE>Link to a target medium</TITLE>
      <LINK REL="stylesheet" TYPE="text/css" 
     MEDIA="print, handheld" HREF="foo.css">
   </HEAD>
   <BODY>
      <P>The body...
   </BODY>
</HTML>

      
    
  @importは、カスケード処理の章で定義されている。

  7.2.1 @media規則

  @media規則は文の集合（波括弧区切り）の対象メディアタイプ（コンマ区切り）を指定する。妥当でない文は、4.1.7節"規則セット、宣言ブロック、およびセレクタ"と4.2節"構文解析エラーの処理ルール"を通して無視されなければならない。@media構造は、同一スタイルシート内の複数メディアのスタイルシート規則を許可する。
  
  @media print {
    body { font-size: 10pt }
  }
  @media screen {
    body { font-size: 13px }
  }
  @media screen, print {
    body { line-height: 1.2 }
  }


  @media規則外のスタイル規則は、スタイルシートを適用するすべてのメディアタイプに適用される。@media内部での@規則はCSS 2.1において無効である。

  7.3 認識されるメディアタイプ

  CSSメディアタイプに選ばれた名前は、関連するプロパティが意味をなす対象デバイスを反映している。以下のリストにあるCSSメディアタイプの名前は規範的であるが、説明は参考情報である。同様に、各プロパティの説明で"メディア"欄は参考情報である。

  all

    すべてのデバイスにあてはまる。

    braille

    点字触覚フィードバックデバイスを対象とする。

    embossed

    ページ点字プリンタを対象としている。

    handheld

    携帯端末（典型的な小さな画面、限られた帯域幅）を対象としている。

    print

    ページ素材を対象とした、または印刷プレビューモードの画面表示を想定している。ページメディア固有な整形問題の詳細については、ページメディアに関する節を参照のこと。

    projection

    例では、プロジェクターの投影を意図する。ページメディア固有な整形問題の詳細については、ページメディアに関する節を参照のこと。

    screen

    主としてコンピュータのカラー画面を対象とする。

    speech

    音声合成を対象とする。注: CSS2は、この目的に対して"aural"と呼ばれる類似したメディアタイプを持っていた。詳細については聴覚スタイルシートに関する付録を参照のこと。

    tty

    固定ピッチ文字格子（例えば、限られた表示機能を備えたテレタイプ、端末、またはポータブルデバイスなど）を使用したメディアを対象とする。著者は、"tty"メディアタイプでピクセル単位を使用すべきでない。

    tv

    テレビ型デバイス（低解像度、カラー、限定スクロール画面、音声使用可能）を対象とする。
  メディアタイプ名は大文字と小文字の区別をしない。

  メディアタイプは、文書をレンダリングする際にユーザエージェントが1つのメディアタイプのみをサポート可能であるという意味で相互に排他的である。ただし、ユーザーエージェントは、別のキャンバスに異なるメディアタイプを使用してよい。たとえば、文書が（同時に）1つのキャンバスに'print'モード、もう1つのキャンバス上に'screen'モードで表示してよい。

  マルチメディアタイプが1つのメディアタイプでしかないことに注意する。たとえば、'tv'メディアタイプは、単一のキャンバスに視覚と聴覚の両方をレンダリングするマルチメディアタイプである。

  未知のメディアタイプをもつ（とはいえ、妥当な識別子である）@mediaと@import規則は、未知のメディアタイプが存在しないかのように処理される。@mediaまたは@import規則は、（識別子でない）不正な形式のメディアタイプを含む場合、その文は無効である。

  注: メディアクエリは、このエラー処理を優先する。

  
    例:

    たとえば、次の断片においてP要素の規則は、（'3D'メディアタイプが未知であるが）'screen'モードが適用される。
    
@media screen, 3D {
  P { color: green; }
}

  

  
    注。 将来のCSSの改訂では、メディアタイプのリストを拡張するかもしれない。著者は、CSS仕様で未定義なメディアタイプの名前に依存すべきではない。
  

  7.3.1 メディアグループ

  この節は参考情報で、規範的ではない。

  各CSSプロパティの定義は、プロパティが適用されるメディアタイプを指定する。プロパティは、一般的に複数のメディアタイプに適用されるので、各プロパティ定義リストのメディアグループではなく、個々のメディアタイプの"メディアに適用される"。各プロパティは、その定義に記載されているメディアグループ内のすべてのメディアタイプに適用される。

  CSS 2.1は次のメディアグループを定義している。

  continuousまたはpaged。

    visual、audio、speech、tactile。

    grid（文字グリッドデバイス）またはbitmap。

    interactive（ユーザーとの対話を許可するデバイス）またはstatic（そうでないもの）。

    all （すべてのメディアタイプを含む）
  次の表は、メディアグループとメディアタイプ間の関係を示している。

  
      メディアグループとメディアタイプの関係
    

    メディア型

        メディアグループ
       

        continuous/paged

        visual/audio/speech/tactile

        grid/bitmap

        interactive/static
      braille

        continuous

        tactile

        grid

        both
      embossed

        paged

        tactile

        grid

        static
      handheld

        both

        visual, audio, speech

        both

        both
      print

        paged

        visual

        bitmap

        static
      projection

        paged

        visual

        bitmap

        interactive
      screen

        continuous

        visual, audio

        bitmap

        both
      speech

        continuous

        speech

        適用不能

        both
      tty

        continuous

        visual

        grid

        both
      tv

        both

        visual, audio

        bitmap

        both
      
  8 ボックスモデル

  
    目次

    8.1 ボックスの寸法

      8.2 マージン、パディング、ボーダーの例

      
        8.3 マージンのプロパティ: 'margin-top'、'margin-right'、'margin-bottom'、'margin-left'、'margin'

        8.3.1 マージンの相殺
        

      8.4 パディングのプロパティ: 'padding-top'、'padding-right'、'padding-bottom'、'padding-left'、'padding'

      
        8.5 ボーダーのプロパティ

        8.5.1 ボーダーの幅: 'border-top-width'、'border-right-width'、'border-bottom-width'、'border-left-width'、'border-width'

          8.5.2 ボーダーの色: 'border-top-color'、'border-right-color'、'border-bottom-color'、'border-left-color'、'border-color'

          8.5.3 ボーダーの線種: 'border-top-style'、'border-right-style'、'border-bottom-style'、'border-left-style'、'border-style'

          8.5.4 ボーダーの簡略化プロパティ: 'border-top'、'border-bottom'、'border-right'、'border-left'、'border'
        

      8.6 双方向コンテキスト内のインライン要素のボックスモデル
    

  CSSボックスモデルは、文書ツリー内の要素に対して生成され、視覚整形モデルに従ってレイアウトされる矩形のボックスについて説明する。

  8.1 ボックスの寸法

  各ボックスは、コンテンツ領域（たとえば、テキスト、イメージなど）と、任意のパディング、ボーダー、マージンなどの周辺領域をもってよい。各領域の大きさは、以下で定義されるプロパティによって指定される。次の図は、これら領域の関係と用語が参照する、マージン、ボーダー、パディングを示す:

  
       [説明]
  

  マージン、ボーダー、パディングは上下左右の辺に分解できる（たとえば図では、"LM"は左マージン、右パディングは"RP"、上ボーダーは"TB"を表す）。

  4つの領域の各境界（コンテンツ、パディング、ボーダー、マージン）は"辺"と呼ぶ。よって各ボックスは4辺を持つ:

  内容辺または内辺

    内容辺は、多くの場合、要素のレンダリングされる内容に依存するボックスの幅と高さによって、与えられた矩形領域を取り囲んでいる。4つの内容辺は、ボックスの内容ボックスを定義する。

    パディング辺

    パディング辺は、ボックスのパディングを囲む。パディング幅が0の場合、パディング辺は内容辺と同じとなる。4つのパディング辺は、ボックスのパディングボックスを定義する。

    ボーダー辺

    ボーダー辺は、ボックスの境界線を囲む。ボーダー幅が0の場合、ボーダー辺はパディング辺と同じとなる。4つのボーダー辺は、ボックスのボーダーボックスを定義する。

    マージン辺または外辺

    マージン辺は、ボックスのマージンを囲む。マージン幅が0の場合、マージン辺はボーダー辺と同じである。4つのマージン辺は、ボックスのマージンボックスを定義する。
  各辺は、上下左右の辺に分解されてよい。

  ボックスの内容領域の寸法―内容幅と内容高さ―は、複数の要因に依存する。ボックスを生成する要素が'width'または'height'プロパティセットを持っているかどうか、ボックスがテキストや他のボックスが含むかどうか、ボックスがテーブルであるかどうかなどである。ボックスの幅と高さは、視覚整形モデルの詳細の章で説明されている。

  背景の内容、パディング、およびボックスのボーダー領域のスタイルは、生成要素の'background'プロパティで指定される。マージンの背景は常に透明である。

  8.2 マージン、パディング、ボーダーの例

  この例では、マージン、パディング、およびボーダーがどのように相互作用するかを示す。たとえば、次のHTML文書で:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>Examples of margins, padding, and borders</TITLE>
    <STYLE type="text/css">
      UL { 
        background: yellow; 
        margin: 12px 12px 12px 12px;
        padding: 3px 3px 3px 3px;
                                     /* ボーダーを設定しない */
      }
      LI { 
        color: white;                /* テキストの色は白 */ 
        background: blue;            /* コンテンツ領域とパディング領域は青 */
        margin: 12px 12px 12px 12px;
        padding: 12px 0px 12px 12px; /* 右パディングが0 */
        list-style: none             /* リストには印を付けない */
                                     /* ボーダーを設定しない */
      }
      LI.withborder {
        border-style: dashed;
        border-width: medium;        /* すべての辺にボーダーを設定 */
        border-color: lime;
      }
    </STYLE>
  </HEAD>
  <BODY>
    <UL>
      <LI>First element of list
      <LI class="withborder">Second element of list is
           a bit longer to illustrate wrapping.
    </UL>
  </BODY>
</HTML>


  文書ツリーは、（他の関係の間で）2つのLIの子を持つUL要素を伴なう。

  以下の1つ目の図は、この例が生成するものを示す。2つ目の図は、マージン、パディング、およびUL要素のボーダーとその子のLI要素の関係を示す。（画像は拡大したものではない。）

  
       [説明]
  

  注意点:

  各LIボックスの内容幅は、階層的に算出される。各LIボックスの包含ブロックは、UL要素によって設置される。

    各LIボックスのマージンボックスの高さは、内容の高さと、上下のパディング、ボーダー、マージンをに加えたものに依存している。LIボックス間の垂直方向のマージンは相殺されることに注意する。

    LIボックスの右パディングがゼロ幅に設定されている（'padding'プロパティ）。効果は、2番目の図で明らかである。

    LIボックスのマージンは透明である―マージンは常に透明である―よって、ULのパディングとコンテンツ領域の背景色（黄色）が透けている。

    2つ目のLI要素は、破線を指定する（'border-style'プロパティ）。
  8.3 マージンのプロパティ: 'margin-top'、'margin-right'、'margin-bottom'、'margin-left'、'margin'

  マージンのプロパティは、ボックスのマージン領域の幅を指定する。'margin'簡略プロパティは、4辺すべてのマージンを設定する。一方、他のマージンのプロパティは、それぞれの辺のみを設定する。これらのプロパティは、すべての要素に適用されるが、垂直方向のマージンは、非置換インライン要素には何の影響も与えない。

  この節で定義されたプロパティは、<margin-width>値型を参照し、次のいずれかの値を取る。

  <length>

    固定幅を指定する。

    <percentage>

    割合は、生成されたボックスの包含ブロックの幅に関して計算される。これは'margin-top'と 'margin-bottom'と同様に当てはまることに注意する。包含ブロックの幅がこの要素に依存する場合、その結果のレイアウトはCSS 2.1で未定義である。

    auto

    動作の幅およびマージンの計算の節を参照のこと。
  マージンのプロパティに負の値は許可されｂるが、実装固有の制限があるかもしれない。

  
    'margin-top', 'margin-bottom'

      
        値:  

              <margin-width> | inherit
            初期値:  

              0
            適用対象:  

              table-caption、table、inline-table以外のテーブルdisplayタイプを持つ要素を除くすべての要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              指定値のパーセンテージまたは絶対長さ
            
    

  これらのプロパティは、非置換インライン要素に影響を与えない。

  
    'margin-right', 'margin-left'

      
        値:  

              <margin-width> | inherit
            初期値:  

              0
            適用対象:  

              table-caption、table、inline-table以外のテーブルdisplayタイプを持つ要素を除くすべての要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              指定値のパーセンテージまたは絶対長さ
            
    

  これらのプロパティは、ボックスの上下左右のマージンを設定する。

  
    例:
    
h1 { margin-top: 2em }

  

  
    'margin'

      
        値:  

              <margin-width>{1,4} | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              table-caption、table、inline-table以外のテーブルdisplayタイプを持つ要素を除くすべての要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  'margin'プロパティは、'margin-top'、'margin-right'、'margin-bottom'、'margin-left'の簡略プロパティで、これらをスタイルシートの同じ場所で設定できる。

  1つのみの値の場合、4辺すべてに適用される。2つの値がある場合は、1つ目の値が上下のマージンに設定され、2つ目の値が左右のマージンに設定される。3つの値が存在する場合は、1つ目の値が上、2つ目の値が左右に、3つ目の値が下に設定される。4つの値がある場合、それぞれ、上、右、下、左の順に適用される。

  
    例:
    
body { margin: 2em }         /* すべてのマージンを2emに設定 */
body { margin: 1em 2em }     /* 上下=1em、左右=2em */
body { margin: 1em 2em 3em } /* 上=1em、右=2em、下=3em、左=2em */


    上記の最後の規則は、以下の例と等価である:
    
body {
  margin-top: 1em;
  margin-right: 2em;
  margin-bottom: 3em;
  margin-left: 2em;        /* 反対側（右）からコピー */
}

  

  8.3.1 マージンの相殺

  CSSでは、2つ以上のボックス（兄弟であるかもしれないし、そうでないかもしれない）の隣接するマージンは、単一のマージンを形成するために組み合わせることができる。この方法を組み合わせて余白を相殺すると言い、結果として結合マージンを、相殺マージンと呼ぶ。

  隣接する垂直マージンの相殺を除き:

  ルート要素のボックスのマージンは相殺されない。

    隙間を持つ要素の上部と下部のマージンが隣接している場合は、次の兄弟の隣接マージンが結果としてマージンを持ち、マージンの相殺は、親ブロックの下マージンと相殺しない。
  水平方向のマージンは相殺しない。

  2つのマージンが隣接する場合に限り:

  両方とも同じブロックの整形コンテキストを共有するフロー内のブロックレベルボックスに属する

    行ボックス、クリアランス、パディング、ボーダーのないものを区別する（特定の高さがゼロの行ボックスは（9.4.2節を参照）、この目的のために無視されることに注意する。）

    両方が垂直に隣接ボックス辺に属する、すなわち形態が以下のいずれかである:

      ボックスの上マージンと、そのボックスの最初のフロー内における子の上マージン

        ボックスの下マージンと、そのボックスの次のフロー内での兄弟の上マージン

        最後のフロー内の子の下マージンと、その親の下マージンで、親が'auto'の算出高さを持つ場合

        ボックスの上下マージンで、そのボックスが新しいブロックの整形コンテキストを設置せず、かつゼロ算出'min-height'を持つか、ゼロか、'auto'算出'height'であって、かつフロー内の子を持たない
      
  相殺マージンは、特にそのコンポーネントがそのマージンに隣接する場合、別のマージンに隣接するとみなす。

  注。 隣接するマージンは、兄弟や祖先として関連しない要素でも生成可能である。

  
    注 上記の規則は以下の意味を含む:

    浮動ボックスと他ボックスとの間のマージンは相殺しない（浮動ボックスと、そのフロー内の子の間でも相殺しない）。

      新しいブロックの整形コンテキスト（たとえば、'visible'以外の'overflow'の浮動体や要素など）を設置する要素のマージンは、それらのフロー内の子とともに相殺しない。

      絶対配置ボックスのマージンは相殺しない（そのフロー内の子も）。

      インラインブロックボックスのマージンは相殺しない（そのボックスのフロー内の子も）。

      フロー内のブロックレベル要素の下マージンは常に、クリアランスを持たない限り、その次のフロー内のブロックレベルの兄弟の上マージンを相殺する。

      フロー内のブロック要素の上マージンは、要素が上ボーダーおよび上パディングを持たず、かつ子がクリアランスを持たない場合、その最初のフロー内のブロックレベルの子の上マージンを相殺する。

      'auto'の'height'をもち、かつゼロの'min-height'をもつフロー内のブロックボックスの下マージンは、ボックスが下パディングと下ボーダーを持たず、かつ子の下マージンが上マージンのクリアランスを持ち相殺しない場合、その最後のフロー内のブロックレベルの子の下マージンを相殺する。

      ボックス自身のマージンは、'min-height'プロパティがゼロで、かつ上または下ボーダーと上または下パディングのどちらもなく、かつ0または'auto'の'height'を持ち、かつ行ボックスを含まず、かつそのフロー内の子のマージンのすべてを（もしあれば）、相殺する。
    

  2つ以上のマージンが相殺したとき、マージン幅の結果は相殺したマージンの幅の最大値である。負のマージンの場合には、負の隣接マージンの絶対値の最大値が、正の隣接マージンの最大値から差し引かれる。正のマージンが存在しない場合、隣接するマージンの絶対値の最大値がゼロから差し引かれる。

  ボックスの上下マージンが隣接する場合、マージンがボックスを通して相殺する可能性がある。この場合、要素の位置はマージンが相殺された他の要素との関係に依存する。

  要素のマージンが親の上マージンとともに相殺される場合、ボックスの上ボーダー辺が親と同じになるように定義される。

    それ以外の場合は、要素の親がマージンの相殺に関係しない、または親の下のマージンのみが関係するかのどちらかとなる。要素の上ボーダー辺の位置は、あたかも要素が非ゼロの下ボーダーを持っていたかのよう同じである。
  相殺された要素の位置は、マージンとともに他の要素の位置に影響を及ぼさないことに注意する。上ボーダー辺の位置は、要素の子孫をレイアウトするためのみに要求される。

  8.4 パディングのプロパティ: 'padding-top'、'padding-right'、'padding-bottom'、'padding-left'、'padding'

  パディングのプロパティは、ボックスのパディング領域の幅を指定する。'padding'簡略プロパティは、4辺すべてのパディングを設定する。一方、他のパディングのプロパティは、それぞれの辺のみを設定する。

  この節で定義されたプロパティは、<padding-width>値型を参照し、次のいずれかの値を取る。

  <length>

    固定幅を指定する。

    <percentage>

    割合は、生成されたボックスの包含ブロックの幅に関して計算される。'padding-top'や'padding-bottom'も同様である。包含ブロックの幅がこの要素に依存する場合、その結果のレイアウトはCSS 2.1で未定義である。
  マージンのプロパティとは異なり、パディングの値は負にできない。マージンのプロパティと同様に、パディングのプロパティのパーセント値は、生成ボックスの包含ブロックの幅を参照する。

  
    'padding-top', 'padding-right', 'padding-bottom', 'padding-left'

      
        値:  

              <padding-width> | inherit
            初期値:  

              0
            適用対象:  

              table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-columnを除くすべての要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              指定値のパーセンテージまたは絶対長さ
            
    

  これらのプロパティは、ボックスの上下左右のパディングを設定する。

  
    例:
    
blockquote { padding-top: 0.3em }

  

  
    'padding'

      
        値:  

              <padding-width>{1,4} | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-columnを除くすべての要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  'padding'プロパティは、'padding-top'、'padding-right'、'padding-bottom'、'padding-left'の簡略プロパティで、これらをスタイルシートの同じ場所で設定できる。

  1つのみの値の場合、4辺すべてに適用される。2つの値を指定した場合、1つ目の値が上下のパディング、2つ目の値が左右のパディングに適用される。 3つの値が存在する場合は、1つ目の値が上、2つ目の値が左右に、3つ目の値が下に設定される。4つの値がある場合、それぞれ、上、右、下、左の順に適用される。

  パディング領域の表面色や画像は、'background'プロパティを通して指定する:

  
    例:
    
h1 { 
  background: white; 
  padding: 1em 2em;
} 


    この例では垂直方向のパディング（'padding-top'と'padding-bottom'）を'1em'に、水平方向のパディング（'padding-right'と'padding-left'）を'2em'に設定している。'em'単位は、要素のフォントサイズに対して相対的である。'1em'は用いたフォントサイズと等しい。
  

  8.5 ボーダーのプロパティ

  ボーダーのプロパティは、ボックスのボーダー領域の幅、色、種類を指定する。これらのプロパティは、すべての要素に適用される。

  
    注。 特にHTMLでは、ユーザーエージェントは特定のユーザーインターフェイス要素（たとえば、ボタン、メニューなど）のボーダーに対し、"よく目にする"要素と異なる方法でレンダリングしてよい。
  

  8.5.1 ボーダーの幅: 'border-top-width'、'border-right-width'、'border-bottom-width'、'border-left-width'、'border-width'

  このプロパティはボーダー領域の幅を指定する。この節で定義されたプロパティは、<border-width> 値型を参照し、次のいずれかの値を取る:

  thin

    細いボーダー。

    medium

    通常のボーダー。

    thick

    太いボーダー。

    <length>

    ボーダーの太さは明示的な値を持つ。ボーダーの幅は負にできない。
  最初の3つの値の解釈は、ユーザーエージェントに依存する。しかし、次の関係は保持しなければならない:

  'thin' <='medium' <= 'thick'.

  さらに、これらの幅は文書を通して一定でなければならない。

  
    'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'

      
        値:  

              <border-width> | inherit
            初期値:  

              medium
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              絶対長さ。ボーダーの種類が'none'または'hidden'の場合、'0'とする。
            
    

  これらのプロパティはボックスの上下左右のボーダーを設定する。

  
    'border-width'

      
        値:  

              <border-width>{1,4} | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  これは簡略化プロパティで、'border-top-width'、'border-right-width'、'border-bottom-width'、'border-left-width'という4つのプロパティを1箇所で設定できる。

  1つのみの値の場合、4辺すべてに適用される。2つの値がある場合は、1つ目の値が上下のボーダーに設定され、2つ目の値が左右のボーダーに設定される。3つの値が存在する場合は、1つ目の値が上、2つ目の値が左右に、3つ目の値が下に設定される。4つの値がある場合、それぞれ、上、右、下、左の順に適用される。

  
    例:

    以下の例で、コメントは上、右、下、左ボーダー幅の結果を示す:
    
h1 { border-width: thin }                   /* thin thin thin thin */
h1 { border-width: thin thick }             /* thin thick thin thick */
h1 { border-width: thin thick medium }      /* thin thick medium thick */

  

  8.5.2 ボーダーの色: 'border-top-color'、'border-right-color'、'border-bottom-color'、'border-left-color'、'border-color'

  このプロパティは、ボックスのボーダーの色を指定する。

  
    'border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color'

      
        値:  

              <color> | transparent | inherit
            初期値:  

              'color'プロパティの値
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              'color'プロパティから取られる場合、'color'の算出値。そうでなければ、指定値。
            
    

  
    'border-color'

      
        値:  

              [ <color> | transparent ]{1,4} | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  'border-color'プロパティは4辺のボーダーの色を設定する。値の意味は次のとおり:

  <color>

    色の値を指定する。

    transparent

    ボーダーは透明となる（ただし幅を持つ）。
  'border-color'プロパティは、1つから4つまでの値を持つことができ、その値は 'border-width'と関係なく設定される。

  要素のボーダーの色がborderプロパティで指定されない場合、ユーザエージェントはボーダーの色の算出値として、要素の'color'プロパティの値を使用しなければならない。

  
    例:

    この例では、ボーダーは黒い実線になる。
    
p { 
  color: black; 
  background: white; 
  border: solid;
}

  

  8.5.3 ボーダーの種類: 'border-top-style'、'border-right-style'、'border-bottom-style'、'border-left-style'、'border-style'

  このプロパティは、ボックスのボーダーの種類（実線、二重、破線など）を指定する。この節で定義されたプロパティは、<border-style>値型を参照し、次のいずれかの値を取る。

  none

    ボーダーなし。ボーダーの算出幅はゼロになる。

    hidden

    'none'とほぼ同じ。ただし、テーブル関連要素でボーダーの競合が発生する場合を除く。

    dotted

    ボーダーを点線にする。

    dashed

    ボーダーを破線にする。

    solid

    ボーダーを実線にする。

    double

    ボーダーを二重線にする。2本の実線とその間の空白との合計幅が'border-width'の値と等しくなる。

    groove

    キャンバスの窪みとしてボーダーを表示する。

    ridge

    'groove'の逆で、キャンバスの隆起としてボーダーを表示する。

    inset

    ボックスのボーダーより内側全体がキャンバスの窪みになる様に表示する。

    outset

    'inset'の逆で、ボックスのボーダーより内側全体がキャンバスの隆起になる様に表示する。
  すべてのボーダーは、ボックスの背景の上に描画される。'groove'、'ridge'、'inset'、'outset'の値で描画されるボーダーの色は、'border-color'プロパティに依存するが、ユーザーエージェントは実際に使用する色を計算するために、独自のアルゴリズムを選択してよい。たとえば、'border-color'の値が'silver'である場合、ユーザーエージェントは傾斜したボーダーを示すために、白からダークグレイのグラデーションを使用できる。

  
    'border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style'

      
        値:  

              <border-style> | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  
    'border-style'

      
        値:  

              <border-style>{1,4} | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  'border-style'プロパティは4辺のボーダーの種類を設定する。1つから4つまでの値を持つことができ、その値は'border-width'と関係なく設定される。

  
    例:
    
#xy34 { border-style: solid dotted }


    上の例では、上下のボーダーがは実線に、左右のボーダーは点線になる。
  

  ボーダーの種類の初期値は'none'なので、ボーダーの種類を設定しない限り、ボーダーは見えない。

  8.5.4 ボーダーの簡略化プロパティ: 'border-top'、'border-bottom'、'border-right'、'border-left'、'border'

  
    'border-top', 'border-right', 'border-bottom', 'border-left'

      
        値:  

              [ <border-width> || <border-style> || <'border-top-color'> ] | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  これは簡略化プロパティで、上下左右のボーダーの幅、種類、色を1箇所で指定できる。

  
    例:
    
h1 { border-bottom: thick solid red }


    上記の規則は、H1要素の下ボーダーの幅、種類、色を設定している。省略された値には、初期値が設定される。次の規則はボーダーの色を指定しないので、ボーダーは'color'プロパティで指定された色を持つ:
    
H1 { border-bottom: thick solid }

  

  
    'border'

      
        値:  

              [ <border-width> || <border-style> || <'border-top-color'> ] | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  'border'プロパティは簡略化プロパティで、ボックスの4つのすべてのボーダーを同じ幅、色、種類に設定する。'margin'や'padding'簡略化プロパティとは異なり、'border'プロパティは4つのボーダーに異なる値を設定できない。その場合、1つ以上の他のボーダープロパティを使用しなければならない。

  
    例:

    たとえば、以下の最初の規則は、その後に示す4つの規則と等価である:
    
p { border: solid red }
p {
  border-top: solid red;
  border-right: solid red;
  border-bottom: solid red;
  border-left: solid red
}

  

  ボーダーのプロパティはある程度機能が重複しているので、規則を指定する順序が重要である。

  
    例:

    次のような例を考えてみよう:
    
blockquote {
  border: solid red;
  border-left: double;
  color: black;
}


    上記の例では、左ボーダーの色が黒で、他のボーダーは赤である。これは、'border-left'が幅、種類、色を設定してしまうためである。色の値は'border-left'プロパティで指定されないため、'color'プロパティから取得される。'color'プロパティが'border-left'プロパティの後に設定されていることは何の関係もない。
  

  8.6 双方向コンテキスト内のインライン要素のボックスモデル

  各行ボックスのために、ユーザーエージェントは各要素に対して生成されたインラインボックスを取らなければならず、（論理的な順序でなく）視覚的な順序でマージン、ボーダー、パディングをレンダリングしなければならない。

  要素の'direction'プロパティが'ltr'である場合、要素が表示される最初の行ボックスの一番左に生成されたボックスには、左マージン、左ボーダー、左パディングを持ち、最後の行の一番右に生成されたボックス要素が表示されるボックスは、右パディング、右ボーダー、右のマージンを持つ。

  要素の'direction'プロパティが'rtl'である場合、要素が表示される最初の行ボックスの一番右に生成されたボックスは、右パディング、右ボーダー、右マージンを持ち、最後の行の一番左に生成されたボックス要素が表示されるボックスは、左マージン、左ボーダー、左パディングを持つ。

  9 視覚整形モデル

  
    目次

    
        9.1 視覚整形モデルの導入

        9.1.1 ビューポート

          9.1.2 包含ブロック
        

      
        9.2 ボックスの生成を制御する

        
            9.2.1 ブロックレベル要素とブロックボックス

            9.2.1.1匿名ブロックボックス
            

          
            9.2.2インラインレベル要素とインラインボックス

            9.2.2.1 匿名インラインボックス
            

          9.2.3 ランインボックス

          9.2.4 'display'プロパティ
        

      
        9.3 位置決め方式

        9.3.1 位置決め方式の選択: 'position'プロパティ

          9.3.2 ボックスのオフセット: 'top'、'right'、'bottom'、'left'
        

      
        9.4 通常フロー

        9.4.1 ブロック整形コンテキスト

          9.4.2 インライン整形コンテキスト

          9.4.3 相対配置
        

      
        9.5 浮動

        9.5.1 浮動体の配置: 'float'プロパティ

          9.5.2 浮動体に隣接するフローの制御: 'clear'プロパティ
        

      
        9.6 絶対配置

        9.6.1 固定配置
        

      9.7 'display'、'position'、'float'の関係

      
        9.8 通常フロー、浮動、絶対配置の比較

        9.8.1 通常フロー

          9.8.2 相対配置

          9.8.3 ボックスの浮動

          9.8.4 絶対配置
        

      
        9.9 レイヤーの表現

        9.9.1 スタックレベルの指定: 'z-index'プロパティ
        

      9.10 書字方向: 'direction'、'unicode-bidi'プロパティ
    

  9.1 視覚整形モデルの導入

  本章および次章では、ユーザーエージェントが視覚メディアの文書ツリーを処理する方法である視覚整形モデルについて説明する。

  視覚整形モデルでは、文書ツリー内の各要素がボックスモデルに従って0個以上のボックスを生成する。これらボックスのレイアウトは以下の事項に左右される:

  ボックスの寸法および種類。

    ボックスの位置決め方式（通常フロー、浮動、絶対配置）。

    文書ツリーにおける要素間の関係。

    外部情報（たとえば、ビューポートのサイズ、画像の固有寸法​​など）。
  本章および次章で定義されたプロパティは、連続メディアとページメディアの両方に適用される。しかし、ページメディアに適用した場合、マージンのプロパティの意味は異なる（詳細については、ページモデルを参照）。

  視覚整形モデルは、書式設定のすべてを規定するものではない（たとえば、文字間隔アルゴリズムを規定しない）。適合ユーザエージェントは、本仕様の対象外となる整形について動作が異なってよい。

  9.1.1 ビューポート

  一般に、連続メディアのユーザエージェントは、ユーザーが文書を参照するためのビューポート（画面上のウィンドウまたは他の表示領域）を提供している。ビューポートのサイズが変更されたときにユーザエージェントは、文書のレイアウトを変更してよい（初期包含ブロックを参照のこと）。

  ビューポートが文書のレンダリングされているキャンバスの面積よりも小さい場合、ユーザエージェントはスクロール機構を提供すべきである。1つのキャンバスに複数のビューポートがあってはならないが、ユーザエージェントは複数のキャンバスにレンダリングしてよい（すなわち、同じ文書の異なる表示を提供してよい）。

  9.1.2 包含ブロック

  CSS 2.1では、多くのボックスの位置や大きさは、包含ブロックと呼ばれる矩形のボックス辺を基準に計算される。一般に、生成ボックスは、子孫ボックスのブロックを含むとして機能する。これを、ボックスがその子孫の包含ブロックを"設置する"と言う。"ボックスの包含ブロック"は"そのボックスが含まれている包含ブロック"を意味し、そのボックスが生成する包含ブロックという意味ではない。

  各ボックスは、包含ブロックに対する位置を与えられるが、その位置はこの包含ブロックによって制限されない。外にはみ出してよい。

  包含ブロックの寸法を計算する方法の詳細については、次章で説明される。

  9.2 ボックスの生成を制御する

  以下の節では、CSS 2.1で生成されるボックスの種類について説明する。視覚整形モデルでは、ボックスの種類が部分的にボックスの動作に影響を与える。後述の'display'プロパティが、ボックスの種類を指定する。

  9.2.1 ブロックレベル要素とブロックボックス

  ブロックレベル要素は、ソース文書でブロック（段落など）として視覚的にフォーマットされた要素のことである。'display'プロパティの'block'、'list-item'、'table'値は、要素をブロックレベルにする。

  ブロックレベルボックスはブロック整形コンテキストに関わるボックスである。各ブロックレベル要素は、子孫ボックスや生成されたコンテンツが含まれており、また、任意の位置決め方式に関与するボックスである主ブロックレベルボックスを生成する。一部のブロックレベル要素（'list-item'要素）は、主ボックスに加えて追加のボックスを生成することがある。この追加ボックスは主ボックスを基準にして配置される。

  後の章で説明する、置換要素とテーブルボックスを除くブロックレベルボックスは、ブロックコンテナボックスでもある。ブロックコンテナボックスはブロックレベルボックスのみが含まれているか、またはインライン書式コンテキストを設置するかのいずれかであり、したがってインラインレベルボックスのみが含まれる。すべてのブロックコンテナボックスがブロックレベルボックスとは限らない。非置換インラインブロックおよび非置換テーブルセルは、ブロックレベルボックスでないが、ブロックコンテナである。ブロックレベルボックスはブロックコンテナでもあり、ブロックボックスと呼ばれる。

  3つの用語"ブロックレベルボックス"、"ブロックコンテナボックス"、"ブロックボックス"は明確な場合に"ブロック"と略される。

  9.2.1.1 匿名ブロックボックス

  次のような文書で:
  
<DIV>
  Some text
  <P>More text
</DIV>


  （DIVとPの両方が'display: block'であると仮定して）、DIVはインラインコンテンツとブロックコンテンツの両方を持つように見える。整形の定義のわかりやすさのために、"Some text"の周囲に匿名ブロックボックスがあるとみなす。

  
       [説明]

    上記の例である3つのボックスの図、そのうち1つは匿名である。
  

  言い換えれば、ブロックコンテナボックス（上記の例ではDIVに対して生成される）が内部にブロックレベルボックス（上記の例で P）を持つ場合、ブロックボックスの内部にブロックレベルボックスのみを持つよう強制する。

  インラインボックスがフロー内にブロックレベルボックスを含む場合、インラインボックス（およびラインボックスを含むそのインラインの祖先）は、ブロックレベルボックス（および任意の、連続する、もしくは空白のみの区切られるかフロー外の要素の両方またはいずれか一方である、兄弟ブロックレベルボックス）、2つのボックスに分割されるインラインボックス（片方が空の場合も含む）、ブロックレベルボックスの両側の一方の周囲で中断される。中断前および中断後の行ボックスは匿名ブロックボックスで囲まれ、ブロックレベルボックスはこの匿名ボックスの兄弟となる。このようにインラインボックスが相対位置によって影響される場合、結果として得られる変換は、インラインボックスに含まれるブロックレベルボックスにも影響を与える。

  
    例:

    このモデルを以下の例に当てはめる。以下の規則を:
    
p    { display: inline }
span { display: block }


    このようなHTML文書に用いるとする:
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HEAD>
<TITLE>Anonymous text interrupted by a block</TITLE>
</HEAD>
<BODY>
<P>
This is anonymous text before the SPAN.
<SPAN>This is the content of SPAN.</SPAN>
This is anonymous text after the SPAN.
</P>
</BODY>


    P要素は、匿名テキスト（C1）、続いてブロックレベル要素、続いてもう1つの匿名テキスト（C2）を含んでいる。その結果ボックスは、C1の周囲の匿名ブロックボックス、SPANブロックボックス、C2の周囲の別の匿名ブロックボックスと、これらを含むBODYブロックボックスの4つとなる。
  

  匿名ボックスのプロパティは、囲んでいる非匿名ボックス（たとえば、例では単に"匿名ブロックボックス"、DIVのための1つをサブセクションの見出しの下）から継承される。非継承のプロパティは初期値を持つ。たとえば、匿名ボックスのフォントはDIVから継承されるが、マージンは0になる。

  匿名ブロックボックスを生成させる要素に設定されたプロパティは、まだ、その要素のボックスとコンテンツに適用される。たとえば、上記の例ではボーダーがP要素に設定された場合、ボーダーはC1（行の終わりにオープン）とC2（行の先頭に開いている）の周囲に描画される。

  一部のユーザエージェントは、たとえば、"匿名の行ボックス"内のネストされたブロックをラップし、そのボックスの周囲にインラインのボーダーを描画するような方法で、ブロックを含むインラインでボーダーを実装している。CSS1とCSS2はこの動作を定義していないので、CSS1のみおよびCSS2のみのユーザエージェントは、この代替モデルを実装してもCSS 2.1の本部分への適合を要求できる。これは、本仕様書がリリースされた後に開発されたユーザーエージェントには適用されない。

  パーセント値を参照することになり、パーセント値を解決するときに匿名ブロックボックスは無視される。最も近い非匿名先祖ボックスが代わりに使用される。たとえば、上記のDIV内の匿名ブロックボックスの子がパーセント高さを解決するために、その包含ブロックの高さを知る必要がある場合、匿名ブロックボックスではなくDIVによって形成された包含ブロックの高さを使用する。

  9.2.2 インラインレベル要素とインラインボックス

  インラインレベル要素はソース文書のうち新しい内容ブロック整形しない要素であり、内容は複数行にまたがる（たとえば、段落内の文字強調や、インライン画像など）。'display'プロパティの'inline'、 'inline-table'、'inline-block'値は、要素をインラインレベルにする。インラインレベル要素はインラインレベルボックスを生成する。これはインライン整形コンテキストに関与するボックスである。

  インラインボックスは、インラインレベルとそのコンテンツの両方がインライン整形コンテキストを含むものの1つである。'inline'の'display'値を伴なう非置換要素は、インラインボックスを生成する。インラインレベルボックスが（置換インライン要素、インラインブロック要素、インラインテーブル要素のような）インラインボックスでないものは、単一の不透明なボックスとしてインライン整形コンテキストに関与するため、原子インラインレベルボックスと呼ばれる。

  9.2.2.1 匿名インラインボックス

  すべてのテキストは（インライン要素の内側ではなく）ブロックコンテナ要素の内側に直接含まれる。テキストは匿名インライン要素として扱われなければならない。

  次のようなHTMLマークアップされた文書で:

  
    
<p>Some <em>emphasized</em> text</p>

  

  <p>はインラインボックスを伴なうブロックボックスを生成する。"emphasized"のボックスは、インライン要素（<em>）によって生成されたインラインボックスであるが、他のボックス（"Some"と"text"）はブロックレベル要素（<p>）によって生成されたインラインボックスである。後者は、関連するインラインレベル要素を持たないため匿名インラインボックスと呼ばれる。

  匿名インラインボックスは親ブロックボックスから継承可能なプロパティを継承する。非継承のプロパティは初期値を持つ。たとえば、匿名インラインボックスの色はPから継承するが、背景は透明になる。

  'white-space'プロパティによって相殺される空白コンテンツは、任意の匿名インラインボックスを生成しない。

  本仕様において匿名ボックスの種類が文脈から明らかな場合、匿名インラインボックスと匿名ブロックボックスのどちらも単に匿名ボックスと呼ぶ。

  テーブルを整形する際に生じる匿名ボックスには、より多くの匿名ボックスの種類がある。

  9.2.3 ランインボックス

  [本節は、節番号が以前のドラフトと同じになるように存在する。'Display: run-in'は現在CSS level 3で定義されている（CSS basic box model参照）。]

  9.2.4  'display'プロパティ

  
    'display'

      
        値:  

              inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit
            初期値:  

              inline
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              all
            算出値:  

              テキスト参照
            
    

  このプロパティの値は以下の意味を持つ:

  block

    この値は要素にブロックボックスを生成させる。

    inline-block

    この値は要素にインラインレベルボックスコンテナを生成させる。インラインブロックの内側はブロックボックスとして整形され、要素自身は原子インラインレベルボックスとして整形される。

    inline

    この値は1つ以上のインラインボックスを生成させる。

    list-item

    この値は要素（たとえばHTMLのLI）に主要ボックスとマーカーボックスを生成させる。リストおよびリストの書式設定の例については、リストの章を参照のこと。

    none

    
      この値は要素を整形構造に出現させない（すなわち、視覚メディアにおいて要素はボックスを生成せず、レイアウトに影響しない）。子孫要素もいかなるボックスも生成しない。要素とその内容は整形構造から完全に削除される。この動作は、子孫での'display'プロパティの設定によって上書きされない。

      'none'は不可視のボックスを作成するわけではないことに注意する。全くボックスを作成しないのである。CSSは、要素が整形に影響を与える整形構造においてボックスを生成できるようにするメカニズムを含むが、それ自体は不可視である。詳細については、可視性の節を参照のこと。
    

    table、inline-table、 table-row-group、table-column、table-column-group、table-header-group、table-footer-group、table-row、table-cell、table-caption

    これらの値は要素をテーブル要素のように作用させる（テーブルの章で説明される制限に従う）。
  位置指定、浮動要素（'display'、'position'、'float'の関係を参照）またルート要素を除いて、算出値は指定値と同値である。ルート要素に対しては、算出値は'display'、'position'、'float'の関係の節で説明されたとおりに変更される。

  'display'の初期値は'inline'であるが、ユーザエージェントのデフォルトスタイルシートの規則は、この値を上書きしてよいことに注意する。付録のHTML4におけるサンプルスタイルシートを参照のこと。

  
    例:

    'display'プロパティのいくつかの例を示す:
    
p   { display: block }
em  { display: inline }
li  { display: list-item } 
img { display: none }      /* 画像を表示しない */

  

  9.3 位置決め方式

  CSS 2.1では、ボックスを3種類の位置決め方式に従ってレイアウトしてよい:

  通常フロー。CSS 2.1では、通常フローはブロックレベルボックスのブロック整形、インラインレベルボックスのインライン整形、およびブロックレベルとインラインレベルボックスの相対位置が含まれる。

    浮動。浮動モデルでは、ボックスは最初に通常フローに従ってレイアウトされ、それからフローから取り出されて、左または右へ可能な限り遠くにシフトする。内容は、浮動の側面に沿って流しこんでよい。

    絶対配置。絶対位置決めモデルでは、ボックスは通常フローから完全に削除され（以降の兄弟に影響を与えない）、包含ブロックに対して位置が割り当てられる。
  ある要素が浮動、絶対位置決め、ルート要素である場合、フロー外と呼ばれる。ある要素がフロー外でなければフロー内と呼ばれる。要素のフローAがAから構成される集合であり、最も近いフロー外の先祖がAであるようなすべてのフロー内要素。

  
    注。 CSS 2.1の位置決め方式は、著者がレイアウト効果のために使われているマークアップのトリック（たとえば、不可視の画像）を回避できるようにすることで、文書をよりアクセシブルにする手助けとなる。
  

  9.3.1 位置決め方式の選択: 'position'プロパティ

  'position'と'float'プロパティはボックスの位置を計算するために使用されCSS 2.1位置アルゴリズムを決定する。

  
    'position'

      
        値:  

              static | relative | absolute | fixed | inherit
            初期値:  

              static
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティの値は以下の意味を持つ:

  static

    ボックスは通常ボックスであり、通常フローに従ってレイアウトされる。'top'、'right'、'bottom'、'left'プロパティは適用されない。

    relative

    ボックスの位置は通常フローに従って計算される（これを通常フローでの位置と呼ぶ）。それからボックスはその通常位置から相対的にオフセットされる。あるボックスBが相対配置されるとき、後に続くボックスの位置はBがあたかもオフセットされていないかのように計算される。table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column、table-cell、table-caption要素での'position:relative'の効果は未定義である。

    absolute

    ボックスの位置（と場合によっては大きさ）は'top'、'right'、'bottom'、'left'プロパティで指定される。これらのプロパティはボックスの包含ブロックとの関係を示すオフセットを指定する。絶対配置のボックスは通常フローの範囲外である。これはボックスが以降の兄弟に影響を与えないことを意味する。また、絶対配置ボックスはマージンを持つが、このボックスは他のマージンと相殺しない。

    fixed

    
      ボックスの位置は'絶対'モデルに従って計算されるが、それに加えて、ボックスはある参照に対して固定される。'絶対'モデルでは、ボックスのマージンは他のマージンと相殺しない。handheld、projection、screen、tty、tvメディアタイプの場合、ボックスはビューポートに対して固定され、スクロール時に移動しない。printメディアタイプの場合、ボックスは各ページごとに描画され、ページボックスに対して固定される。たとえページがビューポートを通して見られている場合でも固定される（たとえば、印刷プレビューの場合）。他のメディアタイプの場合、見栄えは未定義である。著者はメディアごとに'固定'を指定したい場合もあるだろう。たとえば、著者が画面上のビューポートの上辺に対してボックスを固定したいが、印刷ページでは固定したくない場合である。2つの仕様が@media規則を用いて分離されてよい:

      
        例:
           
@media screen { 
  h1#first { position: fixed } 
}
@media print { 
  h1#first { position: static }
}

      

      ユーザーエージェントは固定ボックスの内容を割り付けてはならない。ユーザーエージェントは別の方法で不可視の内容を印刷してもよいことに注意する。13章の"ページボックスの外側の内容 "を参照。
    
  ユーザーエージェントはルート要素上で'static'として位置を扱ってよい。

  9.3.2 ボックスのオフセット: 'top'、'right'、'bottom'、'left'

  ある要素の'position'プロパティが'static'以外の値を取る場合、その要素は位置指定されたと言う。位置指定された要素は位置指定されたボックスを生成し、4つのプロパティに従ってレイアウトされる:

  
    'top'

      
        値:  

              <length> | <percentage> | auto | inherit
            初期値:  

              auto
            適用対象:  

              位置指定された要素
            継承:  

              no
            パーセンテージ:  

              内容ブロックの高さを参照
            メディア:  

              visual
            算出値:  

              長さが指定された場合、絶対長さが対応する。パーセンテージが指定された場合、指定値となる。そうでなければ、'auto'。
            
    

  このプロパティは、絶対配置ボックスの上マージン辺がボックスの包含ブロックの上辺からどれだけ下にオフセットされるかを指定する。相対配置ボックスの場合、オフセットはボックス自体の上辺を基準にしている（すなわち、ボックスは通常フロー内の位置を与えられ、その後、これらのプロパティに従ってその位置からのオフセットとなる）。

  
    'right'

      
        値:  

              <length> | <percentage> | auto | inherit
            初期値:  

              auto
            適用対象:  

              位置指定された要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              長さが指定された場合、絶対長さが対応する。パーセンテージが指定された場合、指定値となる。そうでなければ、'auto'。
            
    

  'top'と同様だが、ボックスのマージン右辺が包含ブロック右辺からどれだけ左に位置しているかを指定する。 相対配置ボックスの場合、オフセットはボックス自体の右辺を基準にする。

  
    'bottom'

      
        値:  

              <length> | <percentage> | auto | inherit
            初期値:  

              auto
            適用対象:  

              位置指定された要素
            継承:  

              no
            パーセンテージ:  

              内容ブロックの高さを参照
            メディア:  

              visual
            算出値:  

              長さが指定された場合、絶対長さが対応する。パーセンテージが指定された場合、指定値となる。そうでなければ、'auto'。
            
    

  'top'と同様だが、ボックスのマージン下辺が包含ブロック下辺からどれだけ上に位置しているかを指定する。相対配置ボックスの場合、オフセットはボックス自体の下辺を基準にする。

  
    'left'

      
        値:  

              <length> | <percentage> | auto | inherit
            初期値:  

              auto
            適用対象:  

              位置指定された要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              長さが指定された場合、絶対長さが対応する。パーセンテージが指定された場合、指定値となる。そうでなければ、'auto'。
            
    

  'top'と同様だが、ボックスのマージン左辺が包含ブロック左辺からどれだけ右に位置しているかを指定する。相対配置ボックスの場合、オフセットはボックス自体の左辺を基準にする。

  4つのプロパティ値の意味は次のとおり:

  <length>

    オフセットは基準となる辺からの固定距離となる。負の値は許可される。

    <percentage>

    オフセットは包含ブロック幅のパーセンテージ（'left'または'right'）または高さ（'top'および'bottom'）。負の値は許可される。

    auto

    非置換要素の場合、この値の効果は同様に値が'auto'を持つ関連のプロパティのどれかに依存する。非置換要素の詳細については、絶対配置の幅と高さの章を参照のこと。置換要素の場合、この値の効果は置換コンテンツの固有寸法にのみ依存する。置換要素の詳細については、絶対配置の幅と高さの章を参照のこと。
  9.4 通常フロー

  通常フローでのボックスは整形コンテキストに属している。整形コンテキストはブロックまたはインラインであり、両方に同時に属することはない。ブロックレベルボックスはブロック整形コンテキストに関与する。インラインレベルボックスはインライン整形コンテキストに関与する。

  9.4.1 ブロック整形コンテキスト

  フロート、絶対配置された要素、ブロックボックスでないブロックコンテナ（たとえば、インラインブロック、テーブルセル、テーブルのキャプションなど）、および'visible'以外の'overflow'をもつブロックボックス（値がビューポートに伝搬されている場合を除く）は、その内容のために新しいブロック整形コンテキストを設置する。

  ブロック整形コンテキストでは、ボックスは包含ブロックの最上部から下へと次々にレイアウトされる。2つの兄弟ボックスの縦の距離は、'margin'プロパティによって決定される。ブロック整形コンテキストでの隣接するブロックレベルボックス間の垂直マージンは相殺する。

  ブロック整形コンテキストでは、各ボックスの左外辺が包含ブロックの左辺と接する（右から左に整形の場合、右辺が接する）。これは、たとえ浮動体が存在するでも当てはまる（あるボックスの行ボックスが浮動体の分だけ縮むが）。ただしボックスが新しいブロック整形コンテキストを設置する場合を除く（その場合、ボックス自体が浮動体のためにより狭くなってよい）。

  ページメディアの改ページについては、許容改ページの節を参照のこと。

  9.4.2 インライン整形コンテキスト

  インライン整形コンテキストでは、ボックスは包含ブロックの最上部から順々に水平にレイアウトされる。水平マージン、ボーダー、パディングは、ボックス間で尊重される。ボックスはさまざまな方法で垂直に揃えてもよい。下部または上部を揃えてもよいし、ボックスのテキストのベースラインを揃えてもよい。ある行を形成するボックスを含む矩形領域のことを、行ボックスと呼ぶ。

  行ボックスの幅は、包含ブロックおよび浮動体の存在によって決定される。行ボックスの高さは、行の高さの計算の節で与えられる規則によって決定される。

  行ボックスは、常に内部のボックスのすべてを含むのに十分な高さがある。しかし、内部の最も高いボックスと同じ高さになるとは限らない（たとえば、ボックスをベースラインで揃える場合）。ボックスBの高さがBを含む行ボックスの高さが低い場合、行ボックスにあるBの垂直揃えは'vertical-align'プロパティによって決定される。複数のインラインレベルボックスが1つの行ボックスの中に水平に収めることができない場合、2つ以上の垂直に積層した行ボックスに分配する。したがって、段落は行ボックスを垂直に積み上げたものとなる行ボックスは、垂直に区切られることなく積み上げられ（他の場所で指定された場合を除く）、決して重ならない。

  一般に、行ボックスの左辺はその包含ブロックの左辺と接しており、右辺はその包含ブロックの右辺と接する。しかし、浮動ボックスは包含ブロックの辺と行ボックスの辺との間に出現してよい。したがって、 同一のインライン整形コンテキストの行ボックスは一般に同じ幅（包含ブロックの幅）を持つが、もし利用可能な水平スペースが浮動体のために削減される場合は、幅は変化してよい。同一インライン整形コンテキストの行ボックスは一般に高さが変化する（たとえば、ある行は高い画像含む一方で、他の行はテキストのみかもしれない）。

  ある行のインラインレベルボックスの幅が行ボックスの幅より小さい場合、行ボックスにおけるそれらの水平配分は'text-align'プロパティによって決定される。プロパティの値が'justify'の場合、ユーザーエージェントはインラインボックス内の空白や単語を一様に伸ばしてよい（inline-tableとinline-blockボックスを除く）。

  インラインボックスが行ボックスの幅を超える場合、インラインボックスを複数のボックスに分割して分配する。インラインボックスが分割できない場合（たとえば、インラインボックスが単一の文字を含む、または言語特有の単語で改行規則がインラインボックス内で改行を許可しない、またはインラインボックスがnowrapまたはpreの空白値によって影響される場合）、インラインボックスは行ボックスからあふれる。

  インラインボックスが分割されたとき、マージン、ボーダー、パッディングは分割が発生した場所で視覚効果を持たない（すなわち任意の分割箇所で、複数存在する場合）。

  インラインボックスは、双方向テキスト処理によって同一行ボックスで複数のボックスに分割されてよい。

  行ボックスは、インライン整形コンテキストの内部でインラインレベルコンテンツを保持される必要があるときに作成される。テキストを含まない、保存された空白のない、ゼロでないマージン、パッディングまたはボーダーを伴なうインライン要素を含まない、他のフロー内の内容（画像や、インラインブロックやインラインテーブルなど）を持たない、または保存された改行で終わらない行ボックスは、それらの内部の任意の要素の位置を決定する目的のためにゼロ高さ行ボックスとして扱われなければならず、他の目的のために存在しないものとして扱われなければならない。

  
    インラインボックス構造の例を示す。（HTMLのブロックレベル要素Pによって作成される）以下の段落はEM要素とSTRONG要素が散財する匿名テキストを含む:
    
<P>Several <EM>emphasized words</EM> appear
<STRONG>in this</STRONG> sentence, dear.</P>


    P要素は5つのインラインボックスを含むブロックボックスを生成する。そのうち3つは匿名である:

    Anonymous: "Several"

      EM: "emphasized words"

      Anonymous: "appear"

      STRONG: "in this"

      Anonymous: "sentence, dear."
    段落に整形するために、ユーザーエージェントは5つのボックスを行ボックスに流しこむ。この例では、P要素によって生成されたボックスは、行ボックスのために包含ボックスを設置する。包含ブロックが十分に幅広い場合、すべてのインラインボックスは単一の行ボックスに収まるだろう。
    
 複数の強調語がこの文中に出現する。


    そうでなければ、インラインボックスは分割され複数の行ボックスにわたって確立するだろう。前の段落は以下のように分割されたり:
    
Several emphasized words appear
in this sentence, dear.
このように分割されたりする:
    
Several emphasized  
words appear in this 
sentence, dear.

  

  後者の場合、EMボックスは2つのEMボックスに分割されている（これらを"split1"と"split2"と呼ぶ）。split1の直後とsplit2の直前で、マージン、ボーダー、パディングまたはテキスト装飾は視覚効果を持たない。

  
    以下の例を考えてみる:
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>Example of inline flow on several lines</TITLE>
    <STYLE type="text/css">
      EM {
        padding: 2px; 
        margin: 1em;
        border-width: medium;
        border-style: dashed;
        line-height: 2.4em;
      }
    </STYLE>
  </HEAD>
  <BODY>
    <P>Several <EM>emphasized words</EM> appear here.</P>
  </BODY>
</HTML>


    Pの幅に応じて、ボックスは以下のように分配されてよい:

    
         [説明]
    

    マージンは"emphasized"の直前と"words"の直後に挿入される。

      パディングは"emphasized"の直前と上下、"words"の直後と上下に挿入される。どちらの場合も破線のボーダーは3辺に描画される。
    

  9.4.3 相対配置

  ボックスが通常フローまたは浮動に従ってレイアウトされた時点で、ボックスをこの位置に対してシフトしてよい。これを相対配置と呼ぶ。この方法でボックス（B1）をオフセットすることは続くボックス（B2）は何の影響も受けない。B2は、あたかもB1がオフセットされておらず、B1のオフセットが適用された後にB2が再配置されていないかのように位置を与えられる。これは、相対配置がボックスの重なりを起こしてよいという意味を含む。しかし、相対配置が'overflow:auto'または'overflow:scroll'のボックスにあふれさせる原因となる場合、ユーザーエージェントは、スクロールバーの作成を通してレイアウトに作用してもよく、ユーザーに（そのオフセット位置において）このコンテンツをアクセスできるようにしなければならない。

  相対配置のボックスは、改行や予約された空白も含めて、通常フローの大きさを維持する。 包含ブロックの節は相対配置のボックスが新しい包含ブロックを設置した際の説明をする。

  相対配置の要素のために、大きさを変更することなく、'left'または'right'はボックスを水平に移動する。'left'はボックスを右に移動させ、'right'はボックスを右に移動する。ボックスは、'left'または'right'の結果として分割または伸長されないため、使用値は常にleft = -rightとなる。

  'left'と'right'のどちらも'auto'（初期値）の場合、使用値は'0'である（すなわち、ボックスは初期位置にとどまる）。

  'left'が'auto'の場合、使用値は'right'の負値となる（すなわち、ボックスは'right'の値によって左に移動する）。

  'right'が'auto'に指定された場合、使用値は'left'の負値となる。

  'left'も'right'も'auto'でない場合、位置は過剰に制約され、どちらか1つは無視される。包含ブロックの'direction'プロパティが'ltr'の場合、'left'の値が勝ち、'right'が-'left'になる。包含ブロックの'direction'が'rtl'の場合、'right'が勝ち、'left'が無視される。

  
    例:

    例。 以下の3つの規則は等価である:
    
div.a8 { position: relative; direction: ltr; left: -1em; right: auto }
div.a8 { position: relative; direction: ltr; left: auto; right: 1em }
div.a8 { position: relative; direction: ltr; left: -1em; right: 5em }

  

  'top'および'bottom'プロパティは、大きさを変えることなく相対位置要素を上または下に移動する。'top'はボックスを下に移動し、'bottom'はボックスを上に移動する。ボックスは、'top'または'bottom'の結果として分割または伸長されないため、使用値は常にtop = -bottomとなる。どちらも'auto'の場合、使用値はどちらも'0'となる。1つが'auto'の場合、他方の負値となる。どちらも'auto'でない場合、'bottom'は無視される（すなわち、'bottom'の使用値は'top'の値のマイナスとなるだろう）。

  注。相対配置ボックスが動的であることを利用すれば、スクリプト環境でアニメーション効果を作り出せる（'visibility'プロパティも参照）。相対配置は上付き文字と下付き文字の一般的形式として利用することもできるが、配置を考慮した行高の自動調節は行われない。詳細は行の高さを計算するを参照のこと。

  相対配置の例については通常フロー、浮動体、絶対配置の比較の節を参照のこと。

  9.5 浮動

  浮動体は、現在の行から左または右にシフトしたボックスである。浮動体（または浮動したあるいは浮動ボックス）の最も興味深い特徴は内容が側面に沿って自由に動いてよい（または'clear'プロパティによって回り込みを禁止できる）ことである。内容は左浮動ボックスの右側あるいは右浮動ボックスの左側を流れる。以下は、浮動体の配置と内容フローに関する概論である。浮動体の振る舞いを抑制する正確な規則は'float' プロパティの説明で与えられる。

  浮動ボックスは、浮動体の外辺が包含ボックス辺または別の浮動体の外辺に接するときまで左または右に移動する。行ボックスが存在する場合、浮動ボックスの外上部は現在の行ボックスの上部で揃えられる。

  浮動体のための十分な水平空間がない場合、浮動体は、浮動体が適合するか、それ以上浮動体が存在しなくなるかのどちらかになるまで下に移動する。

  浮動体はフロー内にないので、浮動体の前後に生成された位置指定されないブロックボックスは、あたかも浮動体が存在しないかのように垂直に流れる。しかし、浮動体の次に生成される現在あるいは後続の行ボックスは、浮動体のマージンボックスの空間作成のために必要に応じて短縮される。

  行ボックスは、以下の4つの条件をすべて満たす垂直位置が存在するときに浮動体に隣接する。(a)行ボックスの上部または上部より下、(b)行ボックスの下部または下部より上、(c)浮動体の上マージン辺の下、(d)浮動体の下マージン辺より上。

  注: これは、0または負の外面高さの浮動体が行ボックスを短縮しないことを意味する。

  短縮された行ボックスが小さすぎて任意の内容を含むことができない場合、ある内容が適合するかそれ以上浮動体が存在しなくなるまでその時の行ボックスは下に移動する（そして行ボックスの幅は最計算される）。浮動ボックスの前の現在の行での任意の内容は浮動体の別の側面の同一行で流しなおす。言い換えるなら、インラインレベルボックスが行ボックス空間にとどまる中で、適合した左浮動体ボックスが出くわす前の行に置かれた場合、左浮動体はその行に置かれ、行ボックスの上部に揃えられ、次に行上のインラインレベルボックスがすでに浮動体の右にその結果移動され（左浮動体の別の側面では右）、rtlの場合は反対に右浮動体となる。

  新しいブロック整形コンテキストを設置する（'visible'以外の'overflow'を持つ要素のような）テーブルのボーダーボックス、ブロックレベル置換要素、または通常フロー内の要素は要素のそれ自身として同一ブロック整形コンテキスト内の任意の浮動体のマージンボックスと重なってはならない。必要ならば、実装は任意の先行する浮動体の下にそれを設置することによって前述の要素を消去すべきであるが、実装は十分な空間がある場合そのような浮動体に隣接した浮動体を設置してよい。これらは、10.3.3節で定義されるものより狭い前述の要素のボーダーボックスでさえも作成してよい。CSS2 はユーザーエージェントが浮動体に隣接する前述の要素を置いてよい場合や、どのような方法で前述の要素がより小さくなるかを定義しない。

  
    例:

    例。 次の文書断片において、包含ブロックはあまりにも小さすぎて浮動体に隣接する内容を含むことはできない。よって内容は包含ブロックがtext-alignプロパティに従って行ボックスが揃えられる場所の浮動体の下に移動させる。
    
p { width: 10em; border: solid aqua; }
span { float: left; width: 5em; height: 5em; border: solid blue; }


...


<p>
  <span> </span>
  Supercalifragilisticexpialidocious
</p>


    この断片は次のようになる:

    
      
    
  

  複数の浮動体は隣接してよく、またこのモデルは、同じ行の隣接する浮動体に適用する。

  
    例:

    以下の規則はclass="icon"をもつすべてのIMGボックスを左に浮動する（そして左マージンを'0'に設定する）:
    
img.icon { 
  float: left;
  margin-left: 0;
}

  

  
    次のHTMLソースとスタイルシートを考えてみる:
      
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>Float example</TITLE>
    <STYLE type="text/css">
      IMG { float: left }
      BODY, P, IMG { margin: 2em }
    </STYLE>
  </HEAD>
  <BODY>
    <P><IMG src=img.png alt="This image will illustrate floats">
       Some sample text that has no other...
  </BODY>
</HTML>


    IMGボックスは左に浮動する。後続の内容は、浮動体の右へ整形され、浮動体として同一行から開始する。浮動体の右の行ボックスは浮動体の存在のために短縮されるが、浮動体の後では"通常の"（P要素によって設置された包含ブロックの）幅に戻る。この文書は次のように整形される:

    
         [説明]
    

    文書が次のようになっても整形は同じである:
    
<BODY>
  <P>Some sample text 
  <IMG src=img.png alt="This image will illustrate floats">
           that has no other...
</BODY>


    なぜなら、浮動体の左の内容は浮動体によって移動し浮動体の右側に流しこみなおすためである。
  

  8.3.1節で述べたように、浮動ボックスのマージンは隣接するボックスのマージンと決して相殺しない。したがって、上の例において、垂直マージンは、Pボックスと浮動IMGボックスとの間で相殺しない。

  浮動体の内容は浮動体が新しいスタックコンテキストがあたかも生成されたかのように並べられる。ただし、任意の位置指定要素および実際に生成された新しいスタックコンテキストが浮動体の親スタックコンテキストに参加する場合を除く。浮動体は通常フロー内の他のボックスと重ねることができる（たとえば、通常フローボックスの次の浮動体が負のマージンを持つ場合）。重なりが起きた場合、浮動体が非位置指定のフロー内のインラインの背後ではなく、フロー内のブロックの前に描画される。

  
    例:

    以下の図は、浮動体が通常フロー内のボーダーと重なった状態を示す。

    
         [説明]

      浮動画像がブロックボックスのボーダーを覆い隠す
    
  

  次の例では、浮動体側面への内容の流し込みを禁止する'clear'プロパティを使っている。

  
    例:

    このような規則があれば:
    
p { clear: left }


    次のように整形される:

    
         [説明]

      どちらの段落も'clear: left'と設定されており、第2段落は浮動体の下へ押し下げられている―整形に際しては第2段落の上マージンが大きくなる（'clear'プロパティの解説を参照のこと）。
    
  

  9.5.1 浮動体の配置: 'float'プロパティ

  
    'float'

      
        値:  

              left | right | none | inherit
            初期値:  

              none
            適用対象:  

              すべて、ただし9.7節参照
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、ボックスを左または右に浮動させるべきか、あるいはまったく浮動させないかどうかを指定する。このプロパティは任意の要素に設定してよいが、絶対配置でないボックスを生成する要素にのみ適用できる。このプロパティの値は以下の意味を持つ:

  left

    要素が左に浮動するブロックボックスを生成する。内容はボックスの右側を流れ、上から開始する（'clear'プロパティに依存する）。

    right

    ボックスが右に浮動することを除いて'left'と同様で、内容はボックスの左側に流れ、上から開始する。

    none

    ボックスは浮動しない。
  ユーザーエージェントはルート要素上で'none'として扱ってよい。

  以下は浮動体の振る舞いを制御する厳密な規則である:

  左浮動ボックスの左外辺は、その包含ブロックの左辺の左にあってはならない。右浮動要素も同様である。

    現在のボックスが左浮動体で、それ以前にソース文書内の要素によって任意の左浮動ボックスが生成される場合、そのような以前のボックスのために、現在のボックスの左外辺が以前のボックスの右外辺の右になければならないか、もしくはその上が以前のボックスの下より低くなければならない。右浮動要素も同様である。

    左浮動ボックスの右外辺は、隣接する任意の右浮動ボックスの左外辺の右にあってはならない。右浮動要素も同様である。

    浮動ボックスの外上は、その包含ブロックの上より高くなってはならない。2つの相殺マージンの間に浮動体が出現した場合、浮動体はあたかもそれがほかの空の匿名ブロック親がフロー内に参加するかのように位置する。そのような親の位置はマージンの相殺の節の規則で定義される。

    浮動ボックスの外上は、ソース文書内の以前の要素によって生成された任意のブロックまたは浮動ボックスの外上より高くあってはならない。

    要素の浮動ボックスの外上は、ソース文書内の以前の要素によって生成されたボックスを含む任意の行ボックスより高くあってはならない。

    自身の左にもう1つ左浮動ボックスを持つ左浮動ボックスは、その包含ブロックの右辺にその右外辺を持ってはならない。(おおまかに言うと: 左浮動体は、すでにできる限り左寄りである場合を除いて、右辺で突き抜けてはならない。）右浮動ボックスの場合の同様である。

    浮動ボックスは可能な限り上に位置しなければならない。

    左浮動ボックスは可能な限り左寄せで、右浮動ボックスは可能なかぎり右寄せで位置しなければならない。より高い位置は左寄せ・右寄せより優先される。
  しかしCSS 2.1において、ブロック整形コンテキストの内で、そのような0に設定される負のマージンの位置より上側の浮動位置であるような負の垂直マージンの場合、浮動体の位置は未定義である。

  これらの規則での他の要素への言及は、浮動体と同じブロック整形コンテキストにおける他の要素のみを参照する。

  
    例:

    このHTML断片はbを右寄せに浮動する結果となる。
    <P>a<SPAN style="float: right">b</SPAN></P>

    P要素の幅が十分である場合、aとbは並んで存在するだろう。これは次のように見える:

    
      
    
  

  9.5.2 浮動体に隣接するフローの制御: 'clear'プロパティ

  
    'clear'

      
        値:  

              none | left | right | both | inherit
            初期値:  

              none
            適用対象:  

              ブロックレベル要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、ある要素ボックスのどちら側が先行する浮動ボックスに隣接してはならないかを指示する。'clear'プロパティは、要素自身の内側または他のブロック整形コンテキスト内の浮動体を考慮しない。

  浮動しないブロックレベルボックスに適用された場合、値は以下のような意味を持つ:

  left

    ボックスの上ボーダー辺が、ソース文書内で以前の要素に由来するすべての左浮動ボックスの下外辺より下に存在することを要求する。

    right

    ボックスの上ボーダー辺が、ソース文書内で以前の要素に由来するすべての右浮動ボックスの下外辺より下に存在することを要求する。

    both

    ボックスの上ボーダー辺が、ソース文書内で以前の要素に由来するすべての左および右浮動ボックスの下外辺より下に存在することを要求する。

    none

    浮動体に関するボックスの位置は何の制約もない。
  'none'以外の値は、潜在的にクリアランスを導入する。クリアランスはマージンの相殺を抑制し、要素のmargin-topの上へ空白のように振る舞う。浮動体を過ぎて垂直に要素を押すために使用される。

  'clear'が設定された要素のクリアランスの計算は最初に要素の上ボーダー辺の仮の決定によってされる。要素の'clear'プロパティが'none'である場合、この位置は実際の上ボーダー辺となる。

  この要素の上ボーダー辺の仮定位置が関連する浮動体を超えない場合、クリアランスは導入され、マージンは8.3.1節の規則に従って相殺する。

  その結果クリアランスはの量はより大きくなる:

  最も低い浮動体の下外辺と同等なブロックのボーダー編の設置に必要な量が除去される。

    その結果の仮定うつにブロックの上ボーダー辺を置くために必要な量。
  あるいは、クリアランスは除去される最低のフロートの下外辺と同等なブロックのボーダー辺を置くために必要な量に設定される。

  注:どちらの振る舞いも既存のウェブコンテンツと適合性の評価の保留を許可されている。将来のCSS仕様は、いずれか一方を要求するだろう。

  注: クリアランスは負または0であってもよい。

  
    例:

    例1。（単純化のために）単に3つのボックスが順に持つと仮定する: M1の下マージンを持つブロックB1（B1は子およびパディングまたはボーダーを持たない）、高さHを持つ浮動ブロックF、M2の上マージンを持つブロックB2（子を持たず、パディングまたはボーダーはない）。B2は'clear'が'both'に設定される。またB2は空でないと仮定する。

    B2の'clear'プロパティを考慮することなく、下の図の状況となる。B1とB2のマージンは相殺する。B1の下ボーダー辺がy = 0と仮定して、それからFの上がy = M1、B2の上ボーダー辺がy = max(M1,M2)、Fの下部がy = M1 + Hであるとする。

    
      
    

    Fの下にB2がないと仮定する、すなわち、クリアランスを追加する必要のある場所で仕様に記述された状況にある。それは意味する:

    
      max(M1,M2) < M1 + H
    

    C1とC2のクリアランスCを2回計算する必要があり、2つの大きさは次の等式を保持する: C = max(C1,C2)。1つ目の方法はB2の上がFの下とぴったり重なって置くことである。すなわち、y = M1 + Hである。これはマージンがもはやそれらの間でクリアランスを伴って相殺されないことを意味する:

    
      F の下部 = B2 の上ボーダー辺 ⇔

      M1 + H = M1 + C1 + M2 ⇔

      C1 = M1 + H - M1 - M2

      = H - M2
    

    2つ目の計算はそれがB2の上部で保持される。すなわちy = max(M1,M2)。それは意味する:

    
      max(M1,M2) = M1 + C2 + M2 ⇔

      C2 = max(M1,M2) - M1 - M2
    

    max(M1,M2) < M1 + Hであると仮定して、これは意味する

    
      C2 = max(M1,M2) - M1 - M2 < M1 + H - M1 - M2 = H - M2 ⇒

      C2 < H - M2
    

    そして、C1 = H - M2として、次のようになる

    
      C2 < C1
    

    したがって

    
      C = max(C1,C2) = C1
    
  

  
    例:

    例2。負のクリアランスの例が-1emという状態である。（要素はボーダーやパディングを持たないと仮定して）
    
<p style="margin-bottom: 4em">
  First paragraph.

<p style="float: left; height: 2em; margin: 0">
  Floating paragraph.

<p style="clear: left; margin-top: 3em">
  Last paragraph.


    説明: 'clear'なしで、最初と最後の段落のマージンは相殺し、最後の段落のボーダー辺は浮動段落の上とぴったり重なる。しかし'clear'は上ボーダー辺が浮動体の下にあること要求する。すなわち、2em低い。これはクリアランスが導入されなければならないことを意味する。したがって、マージンはもはや相殺されず、クリアランスの量は、クリアランス + margin-top = 2emに設定される。すなわち、クリアランス = 2em - margin-top = 2em - 3em = -1emである。
  

  プロパティが浮動要素に設定される場合、浮動体の配置についての規則の修正をもたらす。追加の10番目の制約が加わる:

  浮動体の外上辺は、先行するあらゆる左浮動ボックス（'clear: left'の場合）、もしくは右浮動ボックス（'clear: right'の場合）の外下辺より下でなければならない（'clear: both'の場合は両方）。
  
    注。 このプロパティはCSS1で全要素に適用される。. その結果実装は全プロパティでサポートしてよい。CSS2およびCSS 2.1では'clear'プロパティはブロックレベル要素にのみ適用される。したがって著者はこのプロパティをブロックレベル要素でのみ使うべきである。実装がclearをインライン要素でサポートする場合、上記の説明のようにクリアランスの設定をするよりはむしろ、実装は、下の個別の浮動ボックスに対して除去されるインラインの行ボックスの上に移動するため、改行を強制して効率的に1つ以上の空の行ボックスを挿入すべきである（または9.5節で説明されるような新しい行ボックスを下に移動する）。
  

  9.6 絶対配置

  絶対配置モデルでは、ボックスはその包含ブロックに対して明白にオフセットとなる。これは通常フローから完全に取り除かれる（以降の兄弟に影響しない）。絶対配置ボックスは、通常フローの子供と（fixedでない）絶対位置指定される子孫のための新しい包含ブロックを設置する。しかし、絶対位置要素の内容は任意の他のボックスに流されない。それらは、もう1つのボックスの内容（またはそれら自身）を覆い隠してもよく、重なるボックスのスタックレベルに依存する。

  本仕様において絶対参照要素（またはそのボックス）への言及は、要素の'position'プロパティが値'absolute'または'fixed'を持つという意味を含む。

  9.6.1 固定配置

  固定配置は絶対配置の下位区分である。固定配置ボックスにとっての唯一の相違点は、包含ブロックはビューポートによって設置されることである。連続メディアでは、固定ボックスは文書のスクロール時に移動しない。この点において、それらは固定背景画像に似ている。ページメディアでは、固定配置のボックスはページごとに繰り返される。これは、たとえば各ページの下に署名を打ち込むのに有用である。固定配置のボックスはページの切り取られた領域よりも大きい。固定配置の一部は初期包含ブロックにおいて不可視であり、印刷されない。

  
    著者は、フレームのような見栄えの作成のために固定配置を用いてよい。以下のフレームレイアウトを考える:

    
         [説明]
    

    このレイアウトは、次のHTML文書とスタイル規則で実現することになる:
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>A frame document with CSS 2.1</TITLE>
    <STYLE type="text/css" media="screen">
      BODY { height: 8.5in } /* Required for percentage heights below */
      #header {
        position: fixed;
        width: 100%;
        height: 15%;
        top: 0;
        right: 0;
        bottom: auto;
        left: 0;
      }
      #sidebar {
        position: fixed;
        width: 10em;
        height: auto;
        top: 15%;
        right: auto;
        bottom: 100px;
        left: 0;
      }
      #main {
        position: fixed;
        width: auto;
        height: auto;
        top: 15%;
        right: 0;
        bottom: 100px;
        left: 10em;
      }
      #footer {
        position: fixed;
        width: 100%;
        height: 100px;
        top: auto;
        right: 0;
        bottom: 0;
        left: 0;
      }
    </STYLE>
  </HEAD>
  <BODY>
    <DIV id="header"> ...  </DIV>
    <DIV id="sidebar"> ...  </DIV>
    <DIV id="main"> ...  </DIV>
    <DIV id="footer"> ...  </DIV>
  </BODY>
</HTML>

  

  9.7 'display'、'position'、'float'の関係

  ボックス生成とレイアウトに作用する3つのプロパティ―'display'、'position'、'float'―は次のように相互に作用する。

  'display'が値'none'を持つ場合、'position'および'float'は適用しない。この場合、要素はボックスを生成しない。

    そうでなければ、'position'が値'absolute'または'fixed'を持つ場合、ボックスは絶対位置であり、'float'の算出値は'none'となり、表示は下記のテーブルに従って設定される。ボックスの位置は'top'、'right'、'bottom'、'left'プロパティとボックスの包含ブロックによって決定されるだろう。

    そうでなければ、'float'が'none'以外の値を持つ場合、ボックスは浮動または'display'が下記のテーブルにしたがって設定される。

    そうでなければ、要素がルート要素である場合、それが'list-item'の指定値が'block'または'list-item'の算出値になるかどうかCSS 2.1で未定義である場合を除いて、'display'が下記のテーブルにしたがって設定される。

    そうでなければ、残りの'display'プロパティ値は指定された通りに適用される。
  指定値

        算出値
      inline-table

        table
      inline、table-row-group、table-column、table-column-group、table-header-group、table-footer-group、table-row、table-cell、table-caption、inline-block

        block
      その他

        指定値と同じ
      9.8 通常フロー、浮動、絶対配置の比較

  通常フロー、相対配置、浮動体、絶対配置の間の相違点を説明するために、以下のHTMLをもとにして例を提供する:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>Comparison of positioning schemes</TITLE>
  </HEAD>
  <BODY>
    <P>Beginning of body contents.
      <SPAN id="outer"> Start of outer contents.
      <SPAN id="inner"> Inner contents.</SPAN>
      End of outer contents.</SPAN>
      End of body contents.
    </P>
  </BODY>
</HTML>


  この文書に、以下の規則を仮定する:
  
body { display: block; font-size:12px; line-height: 200%; 
       width: 400px; height: 400px }
p    { display: block }
span { display: inline }


  outerおよびinner要素によって生成されるボックスの最終的な配置はそれぞれの例において変化する。それぞれの図において、図の左側の数字は、（わかりやすさのために）2倍の間隔で行の通常フロー位置を示す。

  注。この節の図は説明であって正確な縮尺ではない。これらはCSS 2.1のさまざまな位置決め方式の違いを強調するために意図されており、与えられた例の規範レンダリングを意図しない。

  9.8.1 通常フロー

  outerおよびinnerに以下のCSS宣言を考えてみる。これらはボックスの通常フローを変更しない:
  
#outer { color: red }
#inner { color: blue }


  P要素はすべてのインライン内容、匿名インラインテキストおよび2つのSPAN要素を含む。したがって、内容のすべては、P要素によって設置される包含ブロック内で、インライン整形コンテキストでレイアウトされる。つまり、以下のものを作る:

  
       [説明]
  

  9.8.2 相対配置

  相対配置の効果を見るために、次の指定をする:
  
#outer { position: relative; top: -12px; color: red }
#inner { position: relative; top: 12px; color: blue }


  テキストはouter要素の直前まで通常に流す。outerのテキストはその結果行1の最後でその通常フローの位置および寸法に流し込まれる。次に、（3行にわたって分布する）テキストを含むインラインボックスが（上に）'-12px'ずつの単位として移動する。

  innerの内容は、outerの子として"of outer contents"の直後に通常に流し込まれる（行1.5）。しかし、inner の内容は outerの内容に関して（下に）'12px'分オフセットし、行2上の元の位置に戻る。

  outerの後の内容は、outerの相対配置によって影響されないことに注意する。

  
       [説明]
  

  outerのオフセットが'-24px'なら、outerのテキストとbodyのテキストが重なることにも注意する。

  9.8.3 ボックスの浮動

  以下の規則を用いてinner要素のテキストを右に浮動する効果を考える:
  
#outer { color: red }
#inner { float: right; width: 130px; color: blue }


  テキストはinnerボックスと並んで通常に流れる。innnerボックスはフローの外から引っ張られ、右マージンへと浮動する（マージンの'width'は明白に割り当てられている）。浮動体の左の行ボックスは短縮され、文書の残りのテキストがそこに流される。

  
       [説明]
  

  'clear'プロパティの効果を示すため、例に兄弟要素を付け加えてみよう:
  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>Comparison of positioning schemes II</TITLE>
  </HEAD>
  <BODY>
    <P>Beginning of body contents.
      <SPAN id=outer> Start of outer contents.
      <SPAN id=inner> Inner contents.</SPAN>
      <SPAN id=sibling> Sibling contents.</SPAN>
      End of outer contents.</SPAN>
      End of body contents.
    </P>
  </BODY>
</HTML>


  次の規則を適用する:
  
#inner { float: right; width: 130px; color: blue }
#sibling { color: red }


  innerボックスは前例と同様に右へ浮動し、文書の残りのテキストは空いたスペースに流し込まれる:

  
       [説明]
  

  しかし、兄弟要素の'clear'プロパティを'right'に設定する（すなわち生成兄弟ボックスが右に浮動ボックスが隣接するのを受け入れない）と、兄弟の内容は浮動体の下へ流れる。
  
#inner { float: right; width: 130px; color: blue }
#sibling { clear: right; color: red }


  
       [説明]
  

  9.8.4 絶対配置

  最後に、絶対配置の効果を考える。outerとinnerに次のCSS宣言を考える:
  
#outer { 
    position: absolute; 
    top: 200px; left: 200px; 
    width: 200px; 
    color: red;
}
#inner { color: blue }


  outerボックスの上はその包含ブロックに対して位置が決まる。位置指定されたボックスの包含ブロックは、最も近い位置指定された祖先（または、例のように存在しない場合は初期包含ブロック）によって設置される。outerボックスの上側は初期包含ブロックの下'200px'であり、左側は左側から'200px'である。outerの子ボックスは親に対して通常に流れる。

  
       [説明]
  

  以下の例は絶対配置ボックスが相対配置ボックスの子になるのを示す。親outerボックスは実際にはオフセットでないが、その'position'プロパティが'relative'に設定することは、そのボックスが位置指定された子孫に包含ブロックとしての機能を果たしてよいことを意味する。outerボックスは複数行に分割されたインラインボックスであるので、最初のインラインボックスの上辺と左辺（下の図で太い破線で表現される）が'top'および'left'のオフセットの参照としての機能を果たす。
  
#outer { 
  position: relative; 
  color: red 
}
#inner { 
  position: absolute; 
  top: 200px; left: -100px; 
  height: 130px; width: 130px; 
  color: blue;
}


  これは次のような結果になる:

  
       [説明]
  

  outerボックスの位置指定をしなければ:
  
#outer { color: red }
#inner {
  position: absolute; 
  top: 200px; left: -100px; 
  height: 130px; width: 130px; 
  color: blue;
}


  innerの包含ブロックは初期包含ブロックになる（この例において）。以下の図は、innerボックスが最後にはこの場合になる場所を示す。

  
       [説明]
  

  
    相対配置と絶対配置を使うと、次例の様に上下に動く棒を実装できる。次の断片で:
    
<P style="position: relative; margin-right: 10px; left: 10px;">
I used two red hyphens to serve as a change bar. They
will "float" to the left of the line containing THIS
<SPAN style="position: absolute; top: auto; left: -1em; color: red;">--</SPAN>
word.</P>


    次のような結果になる:

    
         [説明]
    

    まず、段落は通常に流れる（段落の包含ブロックの端を図に示す）。次に、段落は包含ブロックの左辺から'10px'オフセットになる（つまり、オフセットを見越して'10px'の右マージンが予約されている）。動く棒として2つのハイフンはフローから取り除かれ、現在の行に位置し（'top: auto'による）、その包含ブロックの左辺から'-1em'になる（Pの最終位置でPの設置によって）。その結果動く棒が現在の行の左に"浮動"しているかのようになる。
  

  9.9 レイヤーの表現

  9.9.1 スタックレベルの指定: 'z-index'プロパティ

  
    'z-index'

      
        値:  

              auto | <integer> | inherit
            初期値:  

              auto
            適用対象:  

              位置指定された要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  位置指定されたボックスに対して、'z-index'プロパティは以下を指定する:

  現在のスタックコンテキストでのボックスのスタックレベル。

    ボックスがスタックコンテキストを設置するかどうか。
  値の意味は次のとおり:

  <integer>

    この整数値は、現在のスタックコンテキストにおける生成ボックスのスタックレベルである。ボックスはまた新しいスタックコンテキストを設置する。

    auto

    現在のスタックコンテキストでの生成ボックスのスタックレベルは0になる。ボックスはルート要素でない限り新しいスタックコンテキストを設置しない。
  本節で、"～より前に"という表現は、ユーザーが画面に向かっているとしてユーザーにより近づくことを意味する。

  CSS 2.1では、各ボックスは3次元の位置を持つ。ボックスの水平と垂直位置に加えて、ボックスは"z軸"と平行に位置し、他のボックスの上にあるボックスが整形される。z軸の位置は、ボックスが視覚的に重なるときにとりわけ意味を帯びる。本節はどのようにしてボックスがz軸に沿って配置してよいのかを議論する。

  レンダリングツリーがキャンバスに描かれる順序は、スタックコンテキストの観点から説明される。スタックコンテキストは追加のスタックコンテキストを含むことができる。スタックコンテキストは親コンテキストスタックの観点から原子性となり、他のスタックコンテキスト内のボックスは、任意のボックスの間に来ることはできない。

  各ボックスは、あるスタックコンテキストに属する。与えられたスタックコンテキストでの各位置指定されたボックスは整数のスタックレベルをもつ。このスタックレベルは同一スタックコンテキスト内で他のスタックレベルに対するz軸での位置となる。スタックレベルが大きいボックスはスタックレベルが小さいボックスより前で常に整形される。ボックスは負のスタックレベルを持ってよい。スタックコンテキストで同一のスタックレベルをもつボックスは、文書ツリーの順番に従って後ろから前に積み重ねられる。

  ルート要素はルートスタックコンテキストを整形する。他のスタックコンテキストは、'auto'以外の'z-index'の算出値を持つ任意の位置指定された要素（相対配置の要素を含む）によって生成される。スタックコンテキストは必ずしも包含ブロックと関連しない。CSSの将来のレベルで、他のプロパティがスタックコンテキストを導入してよい。たとえば'opacity'[CSS3COLOR]。

  各スタックコンテキスト内で、以下のレイヤーは後ろから前の順番に描かれる:

  スタックコンテキストが整形する要素の背景とボーダー。

    負のスタックレベルをもつ子スタックコンテキスト（最も小さな値が最初になる）。

    フロー内、非インラインレベル、非位置指定子孫。

    非位置指定の浮動体。

    フロー内、インラインレベル、非位置指定の子孫、インラインテーブルとインラインブロックを含むもの。

    スタックレベル0をもつ子スタックコンテキストでスタックレベル0をもつ位置指定された子孫。

    正のスタックレベルをもつ子スタックコンテキスト（最も小さな値が最初になる）。
  各スタックコンテキストの中で、スタックレベル0をもつ位置指定された要素（レイヤー6）、非位置指定の浮動体（レイヤー4）、インラインブロック（レイヤー5）、およびインラインテーブル（レイヤー5）はこれら要素自身があたかも新しいスタックコンテキストを生成したかのように描かれる。ただし、それらの位置指定された子孫と現在のスタックコンテキストの参加する任意の子スタックコンテキストを除く。

  この描画順序は各スタックコンテキストを再帰的に適用したものである。このスタックコンテキストの描画順序の説明は付録 Eで詳細な規範的な定義の概説を構成する。

  
    以下の例で、ボックスのスタックレベル（"id"要素で識別される）は: "text2"=0、"image"=1、"text3"=2、"text1"=3である。"text2"のスタックレベルはルートボックスからの継承である。その他は'z-index'プロパティで指定される。
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>Z-order positioning</TITLE>
    <STYLE type="text/css">
      .pile { 
        position: absolute; 
        left: 2in; 
        top: 2in; 
        width: 3in; 
        height: 3in; 
      }
    </STYLE>
  </HEAD>
  <BODY>
    <P>
      <IMG id="image" class="pile" 
           src="butterfly.png" alt="A butterfly image"
           style="z-index: 1">

    <DIV id="text1" class="pile" 
         style="z-index: 3">
      This text will overlay the butterfly image.
    </DIV>

    <DIV id="text2">
      This text will be beneath everything.
    </DIV>

    <DIV id="text3" class="pile" 
         style="z-index: 2">
      This text will underlay text1, but overlay the butterfly image
    </DIV>
  </BODY>
</HTML>

  

  この例は透過の概念の説明である。背景のデフォルトの振る舞いは背後にあるボックスが見えるようにすることである。この例では、各ボックスはその下のボックスを透過的に覆う。この振る舞いは既存の背景のプロパティによって上書きできる。

  9.10 書字方向: 'direction'、'unicode-bidi'プロパティ

  双方向テキストをサポートしない適合ユーザーエージェントは、本節で説明する 'direction'および'unicode-bidi'プロパティを無視してよい。この例外は右から左への文字を単純に描画するユーザーエージェントを含む。なぜなら、システム上のフォントは右から左への文字を含むが、右から左へのテキスト方向の概念をサポートしないためである。

  ある用字系において文字は右から左に記述する。特にアラビア語やヘブライ語の文書や、複数の言語が混在する内容において、（視覚的に）1つのかたまりの文書は混在した書字方向が出現してよい。この現象を双方向性あるいは"bidi"と呼ぶ。

  ユニコード標準（[UNICODE]、[UAX9]）は適切なテキストの方向性を決定する複雑なアルゴリズムを定義する。このアルゴルズムは、埋め込みや上書きによる明示的な制御だけでなく、文字特性を基にした暗黙の部分からなる。CSS 2.1は適切な双方向レンダリングを達成するために、このアルゴリズムに依存する。'direction'および'unicode-bidi'プロパティは、文書言語の要素や属性がこのアルゴリズムとどのように対応させるかを著者が指定できる。.

  ユーザーエージェントは、強制的な（bidi class B）改行またはブロック境界によって中断することなく、インラインレベルボックスのシーケンスごとにユニコード双方向アルゴリズムを適用しなければならない双方向テキストをサポートする。このシーケンスは双方向アルゴリズムで"段落"単位を形成する。埋め込みレベルの段落は、ユニコードアルゴリズムのステップP2とP3で与えられた経験則よりはむしろ、包含ブロックの'direction'プロパティ値に従って設定される。

  テキストの方向性は文書言語の構造や意味に依存するため、これらのプロパティはほとんどの場合DTDの設計者や特殊な文書の著者によってのみ使用されるべきである。デフォルトスタイルシートがこれらのプロパティを指定する場合、著者とユーザーはこれらを上書きするような規則を指定すべきではない。

  HTML 4仕様（[HTML4]8.2節）はHTML要素の双方向性の振る舞いを定義する。[HTML4]で指定されるbidiの振る舞いを達成するためのスタイルシート規則は、サンプルスタイルシートで与えられる。HTML 4仕様はまた双方向性の問題についてより詳しい情報を含む。

  
    'direction'

      
        値:  

              ltr | rtl | inherit
            初期値:  

              ltr
            適用対象:  

              すべての要素、ただし文を参照のこと。
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、ブロックの基本書字方向と埋め込みの方向を指定し、ユニコード双方向アルゴルズムを上書きする（'unicode-bidi'参照）。さらに、テーブル列のレイアウト方向、水平のはみ出す方向、'text-align: justify'の場合のブロックで不完全な最終行の配置なども指定する。

  このプロパティの値は以下のような意味を持つ:

  ltr

    左から右の方向。

    rtl

    右から左の方向。
  'direction'プロパティにインライン要素で並び替えに作用するためには、'unicode-bidi'プロパティ値は'embed'または'override'でなければならない。

  
    注。 'direction'プロパティをテーブル列要素に指定しても、列は文書ツリーでセルの祖先でないために、列内のセルには継承されない。したがって、CSSは[HTML4]11.3.2.1節で説明される"dir"属性の継承規則を容易に表現することができない。
  

  
    'unicode-bidi'

      
        値:  

              normal | embed | bidi-override | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素、ただし文を参照のこと。
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティの値は以下のような意味を持つ:

  normal

    要素は双方向アルゴリズムに関する埋め込みの追加の水準を開始しない。インライン要素において、暗黙的な並び替えは要素の境界をまたいで働く。

    embed

    要素がインラインの場合、この値は双方向アルゴリズムに関する埋め込みの追加水準を開始する。この埋め込み水準の方向性は'direction'プロパティによって与えられる。要素の内側で、並び替えは暗黙のうちに完了する。これは要素の先頭でLRE（U+202A、'direction: ltr'）またはRLE（U+202B、'direction: rtl'）の追加に対応し、要素の末尾でPDF（U+202C）の追加に対応する。

    bidi-override

    インライン要素に上書きを作成する。ブロックコンテナ要素にもう1つのブロックコンテナ要素の中ではなく、インラインレベル子孫の上書きを作成する。これは要素の内側で、'direction'プロパティにしたがってシーケンスで並び替えが暗黙的であることを意味する。双方向アルゴリズムの暗黙的な部分は無視される。これは要素の先頭または各匿名子ブロックボックスでLRO（U+202D、'direction: ltr'）またはRLO（U+202E、'direction: rtl'）の追加に対応し、もしあるならば、要素の末尾にPDF（U+202C）の追加に対応する。
  各ブロック要素の最終的な文字の順序は、あたかもbidi制御コードが上記の説のように追加され、マークアップが取り除かれた状態と同じになる。 結果、文字列はプレーンテキストのUnicode双方向アルゴリズムの実装を通過し、整形されたテキストと同じように改行を生じる。 この過程で、'display:inline'をもつ置換要素は中立の文字として扱われる。ただし'unicode-bidi'プロパティが'normal'以外の値を持つ場合、要素で指定された'direction'強調文字として扱われる。その他の原子インラインレベルボックスは中立文字として扱われる。

  順序は単一の方向（完全に左から右または完全に右から左）でインラインボックスを流すことが可能であり、より多くのインラインボックス（匿名インラインボックスを含む）が作成されてよく、一部のインラインボックスは分割され、流す前に並び替えられてよいことに注意する。

  Unicodeアルゴリズムは埋め込みレベルを61に制限しているため、適切な場合を除いて'normal'以外の値の'unicode-bidi'を用いることを避けるべきである。特に、'inherit'値は特別な注意でもって使用されるべきである。しかし、一般にブロックとして表示されることが目的の要素において、'unicode-bidi: embed'の設定は、万が一displayがインラインに変更される場合に備えて　要素とともに保持するのが好ましい（下記の例を参照）。

  以下の例は双方向テキストをもつXML文書を示す。これは重要な設計原則を示す: DTD設計者は適切な言語（要素と属性）と任意の付随スタイルシートの要素を考慮に入れるべきである。スタイルシートは、bidi規則が他のスタイル規則と分けて設計されるべきである。bidi規則は、文書言語やDTDのbidiの振る舞いを保持するためにも、他のスタイルシートによって上書きされるべきではない。

  
    例:

    この例で、小文字は本質的に左から右の文字を表し、大文字は右から左への文字を表す:
    
<HEBREW>
  <PAR>HEBREW1 HEBREW2 english3 HEBREW4 HEBREW5</PAR>
  <PAR>HEBREW6 <EMPH>HEBREW7</EMPH> HEBREW8</PAR>
</HEBREW>
<ENGLISH>
  <PAR>english9 english10 english11 HEBREW12 HEBREW13</PAR>
  <PAR>english14 english15 english16</PAR>
  <PAR>english17 <HE-QUO>HEBREW18 english19 HEBREW20</HE-QUO></PAR>
</ENGLISH>


    これはXMLであるので、スタイルシートが書字方向を設定する責任を持つ。これがスタイルシートである:
    
/* bidi の規則 */
HEBREW, HE-QUO  {direction: rtl; unicode-bidi: embed}
ENGLISH         {direction: ltr; unicode-bidi: embed} 

/* 見栄えの規則 */
HEBREW, ENGLISH, PAR  {display: block}
EMPH                  {font-weight: bold}


    HEBREW要素は右から左の基本方向を持つブロックであり、ENGLISH要素は左から右の基本方向をもつブロックである。PARは親から基本方向を継承するブロックである。したがって、最初の2つのPARは右から読まれ、最後の3つは左から読まれる。HEBREWおよびENGLISHは表現のためだけの要素名であることに注意する。一般に、要素名は言語の参照とは無関係に構造を伝達すべきである。

    EMPH要素はインラインレベルであり、'unicode-bidi'の値は'normal'（初期値）であるので、テキストの順序に影響しない。一方、HE-QUO要素は埋め込みを作成する。

    行の長さが長ければ、このテキストの整形はこのようになるだろう:
    
               5WERBEH 4WERBEH english3 2WERBEH 1WERBEH

                                8WERBEH 7WERBEH 6WERBEH

english9 english10 english11 13WERBEH 12WERBEH

english14 english15 english16

english17 20WERBEH english19 18WERBEH


    HE-QUOの埋め込みがenglish19の右にHEBREW18を引き起こすことに注意する。

    行が改行される場合、このようになる:
    
       2WERBEH 1WERBEH
  -EH 4WERBEH english3
                 5WERB

   -EH 7WERBEH 6WERBEH
                 8WERB

english9 english10 en-
glish11 12WERBEH
13WERBEH

english14 english15
english16

english17 18WERBEH
20WERBEH english19


    HEBREW18はenglish19の前に読まれなければならずHEBREW18はenglish19の上の行となる。単純に早い整形から長い行を改行することにはならない。また、english19からの最初の音節が前の行に収まるようになっていないが、これは右から左へのコンテキストにおける左から右への単語のハイフネーション、およびその逆が、行の途中でハイフンの表示されるのを避けることで抑制されるためである。
  

  10 視覚整形モデル詳細

  
    目次

    10.1 "包含ブロック"の定義

      10.2 内容の幅: 'width'プロパティ

      
        10.3 幅とマージンの計算

        10.3.1 非置換インライン要素の場合

          10.3.2 置換インライン要素の場合

          10.3.3 通常フローでの非置換ブロック要素の場合

          10.3.4 通常フローでの置換ブロック要素の場合

          10.3.5 非置換浮動要素の場合

          10.3.6 置換浮動要素の場合

          10.3.7 絶対配置の非置換要素の場合

          10.3.8 絶対配置の置換要素の場合

          10.3.9 通常フローでの非置換インラインブロック要素の場合

          10.3.10 通常フローでの置換インラインブロック要素の場合
        

      10.4 幅の最大値と最小値: 'min-width'および'max-width'

      10.5 内容の高さ: 'height'プロパティ

      
        10.6 高さとマージンの計算

        10.6.1 非置換インライン要素の場合

          10.6.2 置換インライン要素、通常フローでの置換ブロックレベルおよび置換インラインレベル要素、置換浮動要素の場合

          10.6.3 'overflow'が'visible'時の通常フローでの非置換ブロックレベル要素の場合

          10.6.4 絶対配置の非置換要素の場合

          10.6.5 絶対配置の置換要素の場合

          10.6.6 複雑な事例

          10.6.7 ブロック整形コンテキストルートの'auto'高さ
        

      10.7 高さの最大値と最小値: 'min-height'、'max-height'

      
        10.8 行の高さの計算: 'line-height'、'vertical-align'プロパティ

        10.8.1 行間と半行間
        
    

  10.1 "包含ブロック"の定義

  要素のボックスの位置および大きさは、その要素の包含ブロックと呼ばれる矩形を参照して計算される。要素の包含ブロックを以下のように定義する:

  ルート要素にある包含ブロックは初期包含ブロックと呼ばれる長方形となる。連続メディアにおいて、初期包含ブロックはビューポートの寸法を持ち、キャンバスの原点で固定される。 初期包含ブロックはページメディアのページ領域となる。初期包含ブロックの'direction'プロパティはルート要素に同じである。

    他の要素において、要素の配置が'relative'または'static'の場合、包含ブロックは最も近いブロックコンテナ先祖ボックスの内容辺によって整形される。

    要素が'position: fixed'を持つ場合、包含ブロックは連続メディアの場合またはページメディアのページ領域の場合ビューポートによって設置される。

    要素が'position: absolute'を持つ場合、包含ブロックは'absolute'、'relative'または'fixed'の'position'をもつ最も近い先祖によって以下の方法で確立される:

      先祖がインライン要素である場合、包含ブロックは最初のパディングボックスおよびその要素によって生成される最後のインラインボックスの周りの境界ボックスである。CSS 2.1では、インライン要素が複数行にわたって分割される場合、包含ブロックは未定義である。

        そうでなければ、包含ブロックは先祖のパディング辺によって整形される。
      そのような先祖がない場合、包含ブロックは初期包含ブロックとなる。
    
  ページメディアでは、絶対配置要素は任意のページ改行を（あたかも文書が連続であるかのように）無視するその包含ブロックに対して配置される。要素はその後複数のページに分割されてよい。

  絶対配置されたコンテンツはレイアウトされている（現在のページ）以外のページ上の位置を解決する、またはすでに印刷のために描画された現在のページの位置を解決するために、プリンタは内容を配置してよい

  現在のページの別の場所、

    後続のページ上で、

    内容を除外してよい。
  複数のページに分割されたブロックレベル要素は各ページで異なる幅を持ってよく、デバイス特性による制限を受けてよいことに注意する。

  
    例:

    配置がない状態で、以下の文書の包含ブロックは:
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
   <HEAD>
      <TITLE>Illustration of containing blocks</TITLE>
   </HEAD>
   <BODY id="body">
      <DIV id="div1">
      <P id="p1">This is text in the first paragraph...</P>
      <P id="p2">This is text <EM id="em1"> in the 
      <STRONG id="strong1">second</STRONG> paragraph.</EM></P>
      </DIV>
   </BODY>
</HTML>


    次のように設置される:

    ボックスを生成する要素

          包含ブロックを設定する要素
        html

          初期包含ブロック（UA依存）
        body

          html
        div1

          body
        p1

          div1
        p2

          div1
        em1

          p2
        strong1

          p2
        "div1"を配置する場合:
    
   #div1 { position: absolute; left: 50px; top: 50px }


    その包含ブロックはもはや"body"ではない。それは初期包含ブロックになる（配置される祖先ボックスが存在しないため）。

    さらに"em1"を配置する場合:
    
   #div1 { position: absolute; left: 50px; top: 50px }
   #em1  { position: absolute; left: 100px; top: 100px }


    包含ブロックのテーブルはこのようになる:

    ボックスを生成する要素

          包含ブロックを設定する要素
        html

          初期包含ブロック（UA依存）
        body

          html
        div1

          初期包含ブロック
        p1

          div1
        p2

          div1
        em1

          div1
        strong1

          em1
        "em1"の位置指定によって、その包含ブロックは最も近い位置指定された祖先ボックスになる（すなわち、"div1"によって生成される）。
  

  10.2 内容の幅: 'width'プロパティ

  
    'width'

      
        値:  

              <length> | <percentage> | auto | inherit
            初期値:  

              auto
            適用対象:  

              非置換インライン要素、テーブル列と列グループを除く全要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              パーセンテージまたは'auto'として指定または絶対長さ
            
    

  このプロパティはボックスの内容幅を指定する。

  このプロパティは、非置換インライン要素には適用できない。非置換インライン要素のボックス幅は要素の中で（任意の子供の相対オフセットの前の）表示済み内容の幅である。インラインボックスは行ボックスに流れることを思い出すとよい。行ボックスの幅は包含ブロックによって与えられるが、浮動体のために短縮されてよい。

  値の意味は次のとおり:

  <length>

    長さの単位を用いて内容領域の幅を指定する。

    <percentage>

    パーセント幅を指定する。割合は、生成ボックスの包含ブロックの幅に対して計算される。包含ブロックの幅がこの要素の幅に依存している場合、その結果のレイアウトはCSS 2.1で未定義である。注: 絶対配置要素の包含ブロックはブロックコンテナ要素をもとにするため、割合はその要素のパディングボックスの幅に対して計算される。これはCSS1からの変更であり、パーセント幅は親要素の内容ボックスに対して常に計算されていた。

    auto

    幅は他のプロパティ値に依存する。以下の節を参照のこと。
  'width'での負の値は不正である。

  
    例:

    たとえば、以下の規則は段落の内容幅を100pxに固定している:
    
p { width: 100px }

  

  10.3 幅とマージンの計算

  レイアウトに用いられるある要素の'width'、'margin-left'、'margin-right'、'left'および'right'プロパティの値は、生成するボックスの種類および互いの値に依存する。（レイアウトに使用される値はしばしば使用値とも呼ばれる。）原則として、使用される値は、算出値と同じであり、いくつかの適切な値によって置き換えられた'auto'をもち、包含ブロックに基づいて計算された割合であるが、例外がある。以下の状況では区別する必要がある:

  非置換インライン要素

    置換インライン要素

    通常フローでの非置換ブロックレベル要素

    通常フローでの置換ブロックレベル要素

    非置換浮動要素

    置換浮動要素

    絶対配置の非置換要素

    絶対配置の置換要素

    通常フローでの非置換インラインブロック要素

    通常フローでの置換インラインブロック要素
  ポイント1-6と9、10については、相対配置要素の場合の'left'および'right'の値は、9.4.3節の規則によって決定される。

  注。 'width'の使用値は仮の値であり、何度も計算されてもよく、'min-width'および'max-width'に依存する。下記の幅の最小値と最大値の節を参照のこと。

  10.3.1 非置換インライン要素の場合

  'width'プロパティは適用しない。'margin-left'または'margin-right'による'auto'の算出値は'0'の使用値になる。

  10.3.2 置換インライン要素の場合

  'margin-left'または'margin-right'の'auto'の算出値は'0'の使用値になる。

  'height'および'width'が'auto'の算出値を持ち、かつ要素が固有の幅を持つ場合、固有の幅が'width'の使用値となる。

  'height'および'width'が'auto'の算出値を持ち、かつ要素が固有の幅を持たない場合、固有の高さと固有の幅を持つ。つまり、'width'が'auto'の算出値を持つ場合、'height'は別の算出値を持ち、そしてその要素は固有の比を持つ。その結果'width'の使用値は次のようになる:

  
    (使用高さ) * (固有比)
  

  'height'および'width'が'auto'の算出値を持ち、かつその要素が固有比を持つが固有の高さまたは幅を持たない場合、'width'の使用値はCSS 2.1では未定義である。しかし、その包含ブロックの幅が置換要素の幅に依存しない場合、'width'の使用値は通常フローでの非置換ブロックレベル要素に用いる拘束方程式より計算されることが示唆される。

  そうでなければ、'width'が'auto'の算出値を持つ場合、その要素は固有幅を持ち、その結果その固有幅は'width'の使用値となる。

  そうでなければ、上記の条件に一致ぜず、'width'が'auto'の算出値を持つ場合、'width'の使用値は300pxになる。デバイスにあわせて300pxが広すぎる場合、ユーザーエージェントは2:1の比率を持つ最大の矩形の幅を使用し、代わりにデバイスに収めるべきである。

  10.3.3 通常フローでの非置換ブロック要素の場合

  次の等式はその他のプロパティの使用値で適用できなければならない:

  
    'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' = 包含ブロックの幅
  

  'width'が'auto'でない（その上'margin-left'または'margin-right'のいずれかが'auto'でない）場合、'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width'は包含ブロックの幅より大きくなり、その結果'margin-left'または'margin-right'のいずれかの'auto'値は以下の規則によって0として扱われる。

  上記のすべてが'auto'以外の算出値を持つ場合、値は"制限しすぎ"であるといい、使用値の1つはその算出値と異なる値を持つだろう。包含ブロックの'direction'プロパティが値'ltr'を持つ場合、'margin-right'の指定値は無視され、その値は等式が真になるように計算される。'direction'の値が'rtl'ならば、代わりにこれは'margin-left'に起こる。

  1つの値のみが'auto'に指定される場合、その使用値は等式から得られる。

  'width'が'auto'に設定される場合、それ以外の'auto'の値は'0'になり、'width'は等式から得られる。

  'margin-left'と'margin-right'の両方が'auto'の場合、両者の使用値は等しい。これは、包含ブロックの辺に対して要素を水平に中心に置く。

  10.3.4 通常フローでの置換ブロックレベル要素の場合

  'width'の使用値はインライン置換要素によって決定される。その結果非置換ブロックレベル要素の規則がマージンの決定に適用される。

  10.3.5 非置換浮動要素の場合

  'margin-left'または'margin-right'が'auto'として計算される場合、使用値は'0'となる。

  'width'が'auto'として計算される場合、使用値は"適合するよう縮む"幅となる。

   適合するよう縮む幅の計算は、自動テーブルレイアウトアルゴリズムを使用したテーブルセルの幅の計算に似ている。概略は、明白な改行が起きる場所以外で改行がない整形する内容によって望ましい幅を計算し、また望ましい最小の幅を計算する。すなわち、すべての可能な限りの改行を試みる。CSS 2.1は実際のアルゴリズムを定義しない。そして、利用可能な幅を探す。この場合、これはすべての関連のあるスクロールバーの'margin-left'、'border-left-width'、'padding-left'、'padding-right'、'border-right-width'、'margin-right'および幅の使用値を引いた包含ブロックの幅である。

  その結果適合するよう縮む幅は次のようになる: min(max(望ましい最小の幅, 利用可能な幅), 望ましい幅)。

  10.3.6 置換浮動要素の場合

  'margin-left'または'margin-right'が'auto'として計算される場合、使用値は'0'となる。'width'の使用値はインライン置換要素によって決定される。

  10.3.7 絶対配置の非置換要素の場合

  本節と次節の目的のために、用語（ある要素の）"通常位置"は、おおまかに、要素が通常フロー内にある位置を参照する。より正確には:

  通常位置の包含ブロックとは、仮ボックスの包含ブロックである。この仮ボックスは、'position'の指定値が'static'で、かつ'float'の指定値が'none'であった場合に、最初に要素ボックスであっただろうものである。（9.7節の規則によればこの仮計算は異なる'display'の算出値と仮定することでも要求されるかもしれないことに注意する。）

    その'position'プロパティが'static'かつ'float'が'none'であった場合、'left'の通常位置は包含ブロックの左辺から最初に要素ボックスであった仮ボックスの左マージン辺までの距離である。仮ボックスが包含ブロックの左にある場合、値は負になる。

    'right'の通常位置は上記と同様に包含ブロックの右辺から同じ仮ボックスの右マージン辺までの距離である。仮ボックスが包含ブロック辺より左にある場合、値は正になる。
  しかし、仮ボックスの寸法を実際に計算するよりはむしろ、ユーザーエージェントは自由に可能性のある位置で見当を付けることができる。

  通常位置を計算する目的に対して、固定配置要素の包含ブロックはビューポートの代わりに初期包含ブロックとなり、すべてのスクロール可能なボックスはそれらの原点までスクロールされると仮定されるべきである。

  これらの要素の使用値を決定する制約は:

  
    'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + 'right' = 包含ブロックの幅
  

  'left'、'width'、'right'の3つすべてが'auto'の場合: 最初に'margin-left'と'margin-right'のすべての'auto'値を0に設定する。つぎに、固定位置包含ブロックが設置する要素の'direction'プロパティが通常位置で'left'に設定された'ltr'であり、下記の番号3の規則を適用する。そうでなければ、通常位置に'right'を設定し、下記の番号1の規則を適用する。

  この3つが'auto'でない場合:'margin-left'および'margin-right'の両方が'auto'の場合、2つのマージンが等しい値を得る追加条件の下で式を解き、等式がその3つを負にする場合を除いて、包含ボックスの方向が'ltr'（'rtl'）の場合、'margin-left'（'margin-right'）を0に設定し'margin-right'（'margin-left'）を解く。'margin-left'または'margin-right'の1つが'auto'である場合、その値について等式を解く。値が制限しすぎである場合、（包含ブロックの'direction'プロパティが'rtl'の場合）または'right'（'direction'が'ltr'の場合）の値を無視し、その値について解く。

  そうでなければ、'margin-left'および'margin-right'の'auto'値を0に設定し、 以下の 適用される6つの規則のうちの1つを選ぶ。

  'left'と'width'が'auto'であり'right'が'auto'でないなら、幅は適合するように縮む。'left'について解く。

    'left'と'right'が'auto'であり'width'が'auto'でないなら、通常位置の包含ブロックを確立する要素の'direction'プロパティが通常位置の'left'に設置される'ltr'である。そうでなければ通常位置の'right'に設置される。そして、（'directionが'rtl'の場合）または'right'（'direction'が'ltr'の場合）について解く。

    'width'と'right'が'auto'であり'left'が'auto'でないなら、幅は適合するように縮む。そして'right'について解く。

    'left'が'auto'で'width'と'right'が'auto'でないなら、'left'について解く。

    'width'が'auto'で、'left'と'right'が'auto'でないなら、'width'について解く。

    'right'が'auto'で、'left'と'width'が'auto'でないなら、'right'について解く。
  適合するよう縮む幅の計算は、自動テーブルレイアウトアルゴリズムを使用したテーブルセルの幅の計算に似ている。概略は、明白な改行が起きる場所以外で改行がない整形する内容によって望ましい幅を計算し、また望ましい最小の幅を計算する。すなわち、すべての可能な限りの改行を試みる。CSS 2.1は実際のアルゴリズムを定義しない。次に、利用可能な幅を計算する。これは'left'（1の場合）または'right'（3の場合）を0に設定した後で'width'について解くことにより見つけられる。

  その結果適合するよう縮む幅は次のようになる: min(max(望ましい最小の幅, 利用可能な幅), 望ましい幅)。

  10.3.8 絶対配置の置換要素の場合

  この場合、10.3.7節が制約式を通して適用するが、10.3.7節の残りの部分は以下の規則で置き換えられる:

  'width'の使用値はインライン置換要素によって決定される。'margin-left'または'margin-right'が'auto'として指定される場合、その使用値は以下の規則によって決定される。

    'left'と'right'の両方が値'auto'を持つ場合、通常位置の包含ブロックを設置する要素の'direction'プロパティが'ltr'であるならば、通常位置の'left'に設定される。そうでなければ'direction'が'rtl'であり、通常位置の'right'に設定される。

    'left'または'right'が'auto'の場合、'margin-left'または'margin-right'の任意の'auto'を'0'に置換する。

    この時点で'margin-left'と'margin-right'がまだ'auto'である場合、2つのマージンが等しい値にならなければならないような追加条件のもとで式を解き、これがマージンを負にする場合を除いて、包含ブロックの方向が'ltr'（'rtl'）である場合、'margin-left'（'margin-right'）を0に設定し'margin-right'（'margin-left'）について解く。

    この時点で'auto'がある場合、その値について式を解く。

    この時点で値が制限しすぎである場合、'left'（包含ブロックの'direction'プロパティが'rtl'の場合）または'right'（'direction'が'ltr'の場合）のどちらかの値を無視し、その値について解く。
  10.3.9 通常フローでの非置換インラインブロック要素の場合

  'width'が'auto'の場合、使用値は浮動要素のように適合するように縮む幅になる。

  'margin-left'または'margin-right'の'auto'の算出値は'0'の使用値になる。

  10.3.10 通常フローでの置換インラインブロック要素の場合

  置換インライン要素に同じ。

  10.4 幅の最大値と最小値: 'min-width'、'max-width'

  
    'min-width'

      
        値:  

              <length> | <percentage> | inherit
            初期値:  

              0
            適用対象:  

              非置換インライン要素、テーブル列と列グループを除く全要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              指定値のパーセンテージまたは絶対長さ
            
    

  
    'max-width'

      
        値:  

              <length> | <percentage> | none | inherit
            初期値:  

              none
            適用対象:  

              非置換インライン要素、テーブル列と列グループを除く全要素
            継承:  

              no
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              指定されたパーセンテージまたは絶対長さまたは'none'
            
    

  これらの2つのプロパティは著者にある内容幅で制限することを許可する。値の意味は次のとおり:

  <length>

    固定した値を用いて最小または最大を指定する。

    <percentage>

    パーセンテージで使用値の決定を指定する。割合は、生成ボックスの包含ブロックの幅に対して計算される。包含ブロックの幅が負の場合、使用値は0になる。包含ブロックの幅がこの要素の幅に依存している場合、その結果のレイアウトはCSS 2.1で未定義である。

    none

    （'max-width'にのみ）ボックスの幅を制限しない。
  'min-width'と'max-width'に対する負の値は不正である。

  CSS 2.1において、テーブル、インラインテーブル、テーブルセル、テーブル列、列グループでの'min-width'および'max-width'の効果は未定義である。

  以下のアルゴリズムはどのようにして2つのプロパティが'width'プロパティに影響を及ぼすかを示している:

  暫定的な使用幅は上述の"幅とマージンの計算"のもとで規則に従い計算される（'min-width'と'max-width'なしで）。

    仮の使用値が'max-width'より大きい場合、上記の規則が再び適用されるが、今回は'width'の算出値として'max-width'の算出値を用いる。

    結果の幅が'min-width'より小さい場合、上記の規則を再度適用するが、今回は'width'の算出値として'min-width'を用いる。
  これらのステップは上記のプロパティの実際の算出値に影響しない。

  しかし、置換要素の固有比と'width'および'height'の両方に'auto'が指定されるため、アルゴリズムは次のようになる:

  適切な制限違反に対して解決される高さと幅の値をテーブルから選択する。min ≤ maxが真となるために、max-widthとmax-heightをmax(min, max)として解釈する。このテーブルにおいてwとhは'min-width'、'min-height'、'max-width'、'max-height'プロパティを無視した幅と高さの計算結果を表す。通常、固有の幅と高さを持つが、固有比を伴う置換要素の場合はもたない。

  注: 明確な幅または高さが設定され、他の寸法がautoである場所の場合、auto側の最小または最大の制限を適用することは制限し過ぎの状況を引き起こす。仕様はこの振る舞いで明らかであるが、著者が予期しないことが存在しないわけではない。CSS3 object-fitプロパティはこの状況で異なる結果を得るために使われる。

  制限違反

        解決される幅

        解決される高さ
      none

        w

        h
      w > max-width

        max-width

        max(max-width * h/w, min-height)
      w < min-width

        min-width

        min(min-width * h/w, max-height)
      h > max-height

        max(max-height * w/h, min-width)

        max-height
      h < min-height

        min(min-height * w/h, max-width)

        min-height
      (w > max-width) かつ (h > max-height)、ここで (max-width/w ≤ max-height/h)

        max-width

        max(min-height, max-width * h/w)
      (w > max-width) かつ (h > max-height)、ここで (max-width/w > max-height/h)

        max(min-width, max-height * w/h)

        max-height
      (w < min-width) かつ (h < min-height)、ここで (min-width/w ≤ min-height/h)

        min(max-width, min-height * w/h)

        min-height
      (w < min-width) かつ (h < min-height)、ここで (min-width/w > min-height/h)

        min-width

        min(max-height, min-width * h/w)
      (w < min-width) かつ (h > max-height)

        min-width

        max-height
      (w > max-width) かつ (h < min-height)

        max-width

        min-height
      あたかも'width'がこの値で計算されたかのように、上記の"幅とマージンの計算"のもとで規則を適用する。

  10.5 内容の高さ: 'height'プロパティ

  
    'height'

      
        値:  

              <length> | <percentage> | auto | inherit
            初期値:  

              auto
            適用対象:  

              非置換インライン要素、テーブル行と行グループを除く全要素
            継承:  

              no
            パーセンテージ:  

              文を参照
            メディア:  

              visual
            算出値:  

              パーセンテージまたは'auto'（<percentage>の文を参照）または絶対長さ
            
    

  このプロパティはボックスの内容幅を指定する。

  このプロパティは、非置換インライン要素には適用できない。代わりに使用する規則については非置換インライン要素の高さとマージンの節を参照のこと。

  値の意味は次のとおり:

  <length>

    長さの値を用いて内容領域の高さを指定する。

    <percentage>

    パーセント高さを指定する。割合は生成ボックスの包含ブロックの高さに対して計算される。包含ブロックの高さが明示されておらず（つまり内容の高さに依存し）、この要素が絶対配置でない場合は、値を'auto'として計算する。ルート要素でのパーセント高さは初期包含ブロックに対する高さである。注: 絶対配置要素の包含ブロックはブロックレベル要素をもとにするため、割合はその要素のパディングボックスの高さに対して計算される。これはCSS1からの変更点であり、パーセント高さは親要素の内容ボックスに対して常に計算されていた。

    auto

    高さは他のプロパティの値に依存する。以下の文を参照のこと。
  絶対配置要素の包含ボックスの高さは要素自身の大きさから独立しており、したがってそのような要素でのパーセント高さは常に解決できることに注意する。しかし、それは文書であとに来る要素が処理される時まで高さが未知であってよい。

  'height'での負の値は不正である。

  
    例:

    たとえば、次の規則は段落の高さを100pxに設定している:
    
p { height: 100px }


    100px以上の内容高さを持つ段落は、'overflow'プロパティにしたがってボックスからはみ出す。
  

  10.6 高さとマージンの計算

  'top'、'margin-top'、'height'、'margin-bottom'、'bottom'の値を計算するために、ボックスの種類によって分類する必要がある:

  非置換インライン要素

    置換インライン要素

    通常フローでの非置換ブロックレベル要素

    通常フローでの置換ブロックレベル要素

    非置換浮動要素

    置換浮動要素

    絶対配置の非置換要素

    絶対配置の置換要素

    通常フローでの非置換インラインブロック要素

    通常フローでの置換インラインブロック要素
  ポイント1-6と9、10については、'top'および'bottom'の使用値は、9.4.3節の規則によって決定される。

  注: これらの規則は、任意の他の要素に応じてルート要素に適用する。

  注。 'height'の使用値は仮の値であり、何度も計算されてもよく、'min-height'および'max-height'に依存する。下記の高さの最小値と最大値の節を参照のこと。

  10.6.1 非置換インライン要素の場合

  'height'プロパティは適用しない。内容領域の高さはフォントをもとにすべきであるが、本仕様はその方法を指定しない。たとえば、ユーザーエージェントはemボックスやフォントの最大のアセンダーやディセンダーを用いてよい。（前者は、著者が'line-height'に対する背景スタイルの制御を確実にするだろうが、その内容領域の外側に描くグリフをもたらすだろう。後者は、emボックスの上または下の部分にあるグリフがまだ内容領域内に収まることを保証するが、異なるフォントごとに異なるサイズのボックスをもたらすだろう。）

  注: CSS level 3は、内容高さに用いるフォントの寸法を選択するプロパティがおそらく含まれるだろう。

  非置換インラインボックスのボーダーおよびマージン、垂直方向のパディングは、内容領域の上部と下部で開始し、'line-height'と関係しない。しかし'line-height'に限って、行ボックスの高さの計算時に用いられる。

   1つ以上のフォントが用いられる場合（これはグリフが異なるフォントで発見された場合に起こる）、内容領域の高さは本仕様で定義されない。しかし、高さは内容領域が十分な高さとなるような、要素のすべてのフォントの(1)emボックスまたは(2)最大のアセンダーとディセンダーのいずれかを選択することを示唆する。フォントのベースライン揃えにに応じて、これは関連するフォントの大きさのすべてより大きくてもよいことに注意する。

  10.6.2 置換インライン要素、通常フローでの置換ブロックレベルおよび置換インラインブロック要素、置換浮動要素の場合

  'margin-top'または'margin-bottom'が'auto'の場合、使用値は0になる。

  'height'と'width'が'auto'の算出値と固有の高さの両方である場合、固有の高さが'height'の使用値になる。

  そうでなければ、'height'が'auto'の算出値を持つ場合、その要素は固有比を持ち、結果その'height'の使用値は次のようになる:

  
    (使用幅) / (固有比)
  

  そうでなければ、'height'が'auto'の算出値を持つ場合、その要素は固有高さを持ち、結果その固有高さは'height'の使用値となる。

  そうでなければ、上記の条件に一致しないが、'height'が'auto'の算出値を持つ場合、'height'の使用値は2:1の比を持つ最も大きい矩形の高さに設定されなければならず、150pxより大きくない高さを持ち、かつデバイスの幅より大きくない幅を持つ。

  10.6.3 'overflow'が'visible'計算時の通常フローでの非置換ブロックレベル要素の場合

  本節も'overflow'が'visible'に計算されない場合の通常のフローでの非置換ブロックレベル要素に適用されるが、ビューポートに伝播されている。

  'margin-top'または'margin-bottom'が'auto'の場合、使用値は0になる。'height'が'auto'の場合、高さはその要素が子供ブロックレベル要素を持つかどうか、およびパディングまたはボーダーを持つかどうかによって異なる。

  要素の高さは要素の上内容辺から、以下のうち最初に受け入れ可能なものまでの距離となる:

  ボックスが1行以上のインライン整形コンテキストを設置する場合、、最後の行ボックスの下辺

    子の下マージンが要素のマージンと相殺されない場合、最後のフロー内の子の（相殺可能な）下マージンの下辺

    最後のフロー内の子の下ボーダー辺であって、その子の上マージンがその要素の下マージンと相殺されない

    そうでなければ、0
  通常フローの子供のみを考慮に入れる（すなわち、浮動ボックスと絶対配置ボックスは無視され、相対配置ボックスはオフセットを考慮しない）。子ボックスは匿名ブロックボックスであってもよいことに注意する。

  10.6.4 絶対配置の非置換要素の場合

  本節と次節の目的のために、用語（ある要素の）"通常位置"は、おおまかに、要素が通常フロー内にある位置を参照する。より正確に、'position'の指定値が'static'であり、'float'の指定値が'none'であり、かつ'clear'の指定値が'none'である場合、'top'の通常位置は、包含ブロックの上辺から、要素の最初のボックスの仮定ボックスの上マージン辺までの距離である。（9.7節の規則によれば、この仮計算は異なる'display'の算出値と仮定することでも要求されるかもしれないことに注意する。）仮ボックスが包含ブロックの上にある場合、この値は負になる。

  しかし、仮ボックスの寸法を実際に計算するよりはむしろ、ユーザーエージェントは自由に可能性のある位置で見当を付けることができる。

  通常位置を計算する目的に対して、固定位置要素の包含ブロックはビューポートの代わりに初期包含ブロックとなる。

  絶対配置要素に対して、垂直方向の使用値はこの等式を満たさなければならない:

  
    'top' + 'margin-top' + 'border-top-width' + 'padding-top' + 'height' + 'padding-bottom' + 'border-bottom-width' + 'margin-bottom' + 'bottom' = 包含ブロックの高さ
  

  'top'、'height'、'bottom'の3つすべてがautoの場合、'top'に通常位置を設定し、以下の規則3を適用する。

  3つすべてが'auto'でない場合、'margin-top'と'margin-bottom'の両方が'auto'の場合、2つのマージンが等しい値になるような追加条件のもとで等式を解く。'margin-top'または'margin-bottom'の1つが'auto'である場合、その値について等式を解く。値が制限しすぎの場合、'bottom'の値を無視し、その値について解く。

  そうでなければ、以下の6つの規則のうちの1つを選んで適用する。

  'top'と'height'が'auto'でかつ'bottom'が'auto'でないなら、高さは10.6.7節による内容に基づき、'margin-top'と'margin-bottom'の'auto'値を0に設定し、'top'について解く。

    'top'と'bottom'が'auto'でかつ'height'が'auto'でないなら、'top'に固定位置を設定し、'margin-top'と'margin-bottom'の'auto'値を0に設定し、'bottom'について解く。

    'top'と'bottom'が'auto'でかつ'height'が'auto'でないなら、高さは10.6.7節による内容に基づき、'margin-top'と'margin-bottom'の'auto'値を0に設定し、'bottom'について解く。

    'top'が'auto'で'height'と'bottom'が'auto'でないなら、'margin-top'と'margin-bottom'の'auto'値を0に設定し、'top'について解く。

    'height'が'auto'で、'top'と'bottom'が'auto'でないなら、'margin-top'と'margin-bottom'の'auto'値を0に設定し、'height'について解く。

    'bottom'が'auto'で'top'と'height'が'auto'でないなら、'margin-top'と'margin-bottom'の'auto'値を0に設定し、'bottom'について解く。
  10.6.5 絶対配置の置換要素の場合

  これは、要素が固有高さを持つことを除いて、1つ前の場合と似ている。置換の順序は現状ではこのようになる:

  'height'の使用値はインライン置換要素によって決定される。'margin-left'または'margin-right'が'auto'として指定される場合、その使用値は以下の規則によって決定される。

    'top'と'bottom'の両方が値'auto'を持つ場合、'top'を要素の通常位置に置き換える。

    'bottom'が'auto'の場合、'margin-top'または'margin-bottom'の任意の'auto'を'0'に置き換える。

    この時点でまだ'margin-top'と'margin-bottom'の両方が'auto'の場合、2つのマージンが等しくなるように上の等式を解く。

    この時点でまだ'auto'が1つでも残っていれば、その値について式を解く。

    値が制限しすぎの場合、'bottom'の値を無視し、その値ついて式を解く。
  10.6.6 複雑な事例

  この節は以下に適用する:

  通常フロー内の非置換ブロックレベル要素で、'overflow'が'visible'に計算されない場合（'overflow'プロパティ値がビューポートに伝搬されている場合を除く）。

    非置換インラインブロック要素

    非置換浮動要素
  'margin-top'または'margin-bottom'が'auto'の場合、使用値は0になる。'height'が'auto' の場合、10.6.7節によって要素の子孫に依存する。

  インラインブロック要素に対して、行ボックスの高さの計算時にマージンボックスが用いられる。

  10.6.7 ブロック整形コンテキストルートの'auto'高さ

  ある場合（たとえば、上記の10.6.4節や10.6.6節を参照）、要素がブロック整形コンテキストを設置する高さは以下のように計算される:

  If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.

  その要素がインラインの子供である場合、最上段のブロックレベルの子ボックスの上マージン辺と行ボックスの上辺から最下段の行ボックスの下辺までの距離がheightの算出値になる。

  絶対配置の子供は無視され、相対配置ボックスはオフセットを考慮しない。子ボックスは匿名ブロックボックスであってもよいことに注意する。

  加えて、要素が任意の浮動子孫をもち、その子孫の下マージン辺が要素の下内容辺の下にある場合、高さはそれらの辺を含むよう増加する。このブロック整形コンテキストに参加する唯一の浮動が考慮され、たとえば、絶対配置された子孫の内部で浮動するか、他の浮動はない。

  10.7 高さの最大値と最小値: 'min-height'、'max-height'

  特定の範囲に要素の高さを制限することは便利な場合がある。2つのプロパティがこの機能を提供する：

  
    'min-height'

      
        値:  

              <length> | <percentage> | inherit
            初期値:  

              0
            適用対象:  

              非置換インライン要素、テーブル行と行グループを除く全要素
            継承:  

              no
            パーセンテージ:  

              文を参照
            メディア:  

              visual
            算出値:  

              指定値のパーセンテージまたは絶対長さ
            
    

  
    'max-height'

      
        値:  

              <length> | <percentage> | none | inherit
            初期値:  

              none
            適用対象:  

              非置換インライン要素、テーブル行と行グループを除く全要素
            継承:  

              no
            パーセンテージ:  

              文を参照
            メディア:  

              visual
            算出値:  

              指定されたパーセンテージまたは絶対長さまたは'none'
            
    

  これら2つのプロパティは、著者が特定の範囲にボックスの高さを制限できる。値の意味は次のとおり:

  <length>

    固定の最小値または最大値の計算高さを指定する。

    <percentage>

    パーセンテージで使用値の決定を指定する。割合は生成ボックスの包含ブロックの高さに対して計算される。包含ブロックの高さが明示的に指定されず（すなわち、内容の高さに依存し）、この要素が絶対配置されない場合、パーセント値は0として（'min-height'の場合）または'none'として（'max-height'の場合）扱われる。

    none

    （'max-height'のみ）ボックスの高さを制限しない。
  'min-height'および'max-height'での負の値は不正である。

  CSS 2.1において、テーブル、インラインテーブル、テーブルセル、テーブル行、行グループでの'min-height'および'max-hegiht'の効果は未定義である。

  以下のアルゴリズムはどのようにして2つのプロパティが'height'プロパティに影響を及ぼすかを示している:

  暫定的な使用高さは上述の"高さとマージンの計算"のもとで規則に従い計算される（'min-height'と'max-height'なしで）。

    仮の使用値が'max-height'より大きい場合、上記の規則が再び適用されるが、今回は'height'の算出値として'max-height'の算出値を用いる。

    結果の幅が'min-height'より小さい場合、上記の規則を再度適用するが、今回は'height'の算出値として'min-height'を用いる。
  これらのステップは上記のプロパティの実際の算出値に影響しない。使用される'height'の変化は、"マージンの相殺"（8.3.1節）の'min-height'または'max-height'の規則によって要求される場合を除いて、相殺マージンに影響を与えない。

  しかし、'auto'として計算された'width'と'height'の両方を持つ置換要素の場合、使用幅と高さを見つけるために上記の最小値と最大幅の幅もとでアルゴリズムを使用する。その後、あたかも算出値であるかのように、結果の幅と高さを使用して、上記の"高さとマージンの計算"のもとに規則を適用する。

  10.8 行の高さの計算: 'line-height'、'vertical-align'プロパティ

  インライン整形コンテキストの節で示したとおり、ユーザーエージェントは縦に積み重ねた行ボックスの中にインラインレベルボックスを流す。行ボックスの高さは次のように決定される:

  行ボックスの各インラインレベルボックスの高さが計算される。置換要素、インラインブロック要素、インラインテーブル要素に対して、これはそれらマージンボックスの高さになる。インラインボックスに対しては、これは'line-height'になる。（"高さとマージンの計算"および"行間と半行間"のインラインボックスの高さを参照。）

    インラインレベルボックスの垂直方向の位置を'vertical-align'プロパティにしたがって揃える。インラインレベルボックスが'top'または'bottom'に揃えられる場合、インラインレベルボックスは行ボックス高さの最小として揃えられればならない。そのようなボックスが十分高い場合、複数の解決法が存在し、CSS 2.1は行ボックスのベースラインの位置を定義しない（すなわち、支柱の位置、以下参照）。

    最上部にあるボックスの上から最下部にあるボックスの下までの距離が行ボックスの高さになる。（これは下記の'line-height'のもとで説明されるような支柱を含む。）
  空のインライン要素は空のインラインボックスを生成するが、これらのボックスはマージン、パディング、ボーダー、行の高さを持っているため、内容を持つ要素のようにこれらの計算に影響を与える。

  10.8.1 行間と半行間

  CSSはすべてのフォントが、ベースラインとその下に深さの上側に特性高さを指定したフォントメトリックスを持つことを想定している。本節では、Aを高さ（与えられたサイズでの与えられたフォント）、Dを深さの意味で用いる。またAD = A + Dと定義し、上から下までの距離とする。（TrueTypeおよびOpenTypeフォントでどのようにAおよびDを発見するかについては下記の注を参照のこと。）これらはフォントメトリックのすべてであり、任意の個別のグリフの先祖および子孫と対応するは必要ないことに注意する。

  ユーザーエージェントはそれらの関連のベースラインによって相互に非置換インラインボックス内のグリフを揃えなければならない。それから各グリフに対して、AとDを決定する。1つの要素でグリフは異なるフォントに由来してもよく、ひいては同じAとDをすべて持つ必要もないことに注意する。インラインボックスがすべてにおいてグリフを含んでいない場合、それは要素の最初の利用可能なフォントのAとDをもつ支柱（ゼロ幅の不可視のグリフ）を含むと考える。

  それでも各グリフに対して、追加で行間Lを決定する。ここでL = 'line-height' - AD。半行間は上のAと他の半分の下のD追加される、グリフとその行間の上のA' = A + L/2のベースラインの合計の高さ、D' = D + L/2の合計の深さで与えられる。

  注。 Lは負であってもよい。

  インラインボックスの高さはすべてのグリフと各辺のそれらの半行間を含んでおり、したがってこれは厳密に'line-height'である。子要素のボックスはこの高さに影響しない。

  非置換要素のマージン、パディング、ボーダーは行ボックスの計算の一部ではないが、それでもこれらはインラインボックスの周りに描画される。これは、'line-height'によって指定される高さが包含ボックスの高さより小さい場合、パディングとボーダーの背景と色は隣接する行ボックスにはみだしてよいことを意味する。ユーザーエージェントは文書の順番にボックスを描画すべきである。これは、後続の行のボーダーが前の行のボーダーとテキストを上に描画するようになる。

  注。 CSS 2.1はインラインボックスの内容領域がどのようなものであるかを定義せず（上記10.6.1節参照）、ひいては異なるユーザーエージェントが異なる場所で背景とボーダーを描いてもよい。

  注。AとD（現在の要素のフォントサイズにスケーリングした後の）のためのフォントOS/2テーブルから"sTypoAscender"と"sTypoDescender"のメトリックを用いたOpenTypeまたはTrueTypeフォントを使用する実装を推奨する。これらのメトリックの不足において、HHEAテーブルから"アセント"および"ディセント"メトリックを使用すべきである。

  
    'line-height'

      
        値:  

              normal | <number> | <length> | <percentage> | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              要素自身のフォントの大きさを参照
            メディア:  

              visual
            算出値:  

              <length>と<percentage>は絶対値、そうでなければ指定値に同じ
            
    

  インラインレベル要素からなるブロックコンテナ要素の内容において、'line-height'は要素内の行ブロックの最小の高さを指定する。まさに、あたかも各行ボックスが要素のフォントと'line-height'プロパティとともにゼロ幅の行ボックスで開始されるかのように、最小の高さはベースラインとそれの下の最小深さを超える最小の高さからなる。この架空のボックスを"strut"と呼ぶ（この名前はTeXからアイデアを得ている）。

  上下のベースラインのフォントの高さと深さはフォントにメトリックが含まれていると仮定する。（詳細は、CSS level 3を参照のこと。）

  非置換インライン要素で、'line-height'は行ボックスの高さの計算で使用される高さを指定する。

  このプロパティの値は以下のような意味を持つ:

  normal

    ユーザーエージェントに要素のフォントをもとに"妥当な"値を使用値に設定するよう命じる。この値は<number>と同じ意味を持つ。'normal'には1.0と1.2の間の使用値を推奨する。算出値は'normal'になる。

    <length>

    指定長さは行ボックスの高さの計算で使用される。負の値は不正である。

    <number>

    プロパティの使用値はこの数に要素のフォントサイズを乗じたものである。負の値は不正である。算出値は指定値と同じである。

    <percentage>

    プロパティの算出値はこのパーセンテージに要素の計算されたフォントサイズに乗じたものである。負の値は不正である。
  
    例:

    以下の例で3つの規則はいずれも同じ結果となる:
    
div { line-height: 1.2; font-size: 10pt }     /* number */
div { line-height: 1.2em; font-size: 10pt }   /* length */
div { line-height: 120%; font-size: 10pt }    /* percentage */

  

  要素が1つ以上のフォントで描画されたテキストを含む場合、ユーザーエージェントはもっとも大きなフォントサイズに従って、'通常の''line-height'値を決定してよい。

  注。 ブロックコンテナボックスのすべてのインラインボックスに対して'line-height'の値が1つのみあり、かつそれらがすべて同一のフォント（かつ置換要素やインライン要素などがない）場合、上記は、連続する行のベースラインが正確に別々の'line-height'であることを保証するだろう。たとえばテーブルにおいて、異なるフォントのテキスト列を揃えるときに重要になる。

  
    'vertical-align'

      
        値:  

              baseline | sub | super | top | text-top | middle | bottom | text-bottom | <percentage> | <length> | inherit
            初期値:  

              baseline
            適用対象:  

              インラインレベルとテーブルセル要素
            継承:  

              no
            パーセンテージ:  

              要素自身の'line-height'を参照
            メディア:  

              visual
            算出値:  

              <length>と<percentage>は絶対長さ、そうでなければ指定値に同じ
            
    

  このプロパティは、インラインレベルボックスによって生成された行ボックス内における垂直方向の位置を指定する。

  
    注。 このプロパティの値はテーブルのコンテキストで異なる意味を持つ。詳細はテーブルの高さのアルゴリズムの節を参照のこと。
  

  以下の値は親インライン要素または親ブロックコンテナ要素の支柱に関してのみ意味を持つ。

  以下の定義において、非置換インライン要素に対して、配置に使用するボックスは、ボックスの高さが'line-height'である（包含ボックスのグリフと各辺の半行間は上記を参照）。他のすべての要素に対して、配置に使用するボックスはマージンボックスである。

  baseline

    ボックスのベースラインと親ボックスのベースラインを揃える。ボックスにベースラインが存在しない場合、そのボックスの下辺を親ボックスのベースラインに揃える。

    middle

    ボックスの垂直の中心線を、親のx-heightの半分を加えた親ボックスのベースラインに揃える。

    sub

    ボックスのベースラインを、親ボックスの下付き文字として適切な位置まで下げる。（この値は要素のフォントサイズに影響を与えない。）

    super

    ボックスのベースラインを、親ボックスの上付き文字として適切な位置まで上げる。（この値は要素のフォントサイズに影響を与えない。）

    text-top

    ボックスの上を、親の内容領域の上に揃える。（10.6.1節参照）。

    text-bottom

    ボックスの下を、親の内容領域の下に揃える。（10.6.1 節参照）。

    <percentage>

    （'line-height'の値のパーセント）の距離だけ、ボックスを上に上げる（正の値）または下に下げる（負の値）。'0%'は'baseline'と同じ意味になる。

    <length>

    この距離だけボックスを上に上げる（正の値）または下に下げる（負の値）。値'0cm'は'baseline'と同じ意味になる。
  以下の値は行ボックスに対して要素を揃える。要素はそれに相対的に整列する子供を持ってよいので（順番に子孫がそれらと相対的に整列してよい）、これらの値は整列サブツリーで境界を使用する。インライン要素の整列サブツリーは、要素と、計算された'vertical-align'値が'top'または'bottom'でないすべての子供インライン要素のサブツリーを含む。整形サブツリーの上はサブツリーのボックスの上の最も高いものであり、下も同様である。

  top

    サブツリーの上を、行ボックスの上に揃える。

    bottom

    サブツリーの下を、行ボックスの下に揃える。
  'inline-table'のベースラインは、テーブルの最初の行のベースラインである。

  その'overflow'プロパティが'visible'以外の算出値を持つ、またはそれがどちらか一方のフロー内の行ボックスを持たない場合、'inline-block'のベースラインは通常フローのその最後の行ボックスのベースラインとなる。この場合、ベースラインは下マージン辺となる。

  11 視覚効果

  
    目次

    
        11.1 はみ出しと切り抜き

        11.1.1 はみ出し: 'overflow'プロパティ

          11.1.2 切り抜き: 'clip'プロパティ
        

      11.2 可視性: 'visibility'プロパティ
    

  11.1 はみ出しと切り抜き

  一般に、ブロックボックスの内容はボックスの内容辺の範囲内にとどめられる。場合によっては、ボックスははみ出してもよく、その内容がボックスの外に一部あるいは全部を並べてしまうことを意味する。たとえば:

  行ボックスがブロックボックスより広くなるために、改行できない。

    ブロックレベルボックスの幅が包含ブロックに対して大きすぎる。要素の 'width' プロパティが、生成ブロックボックスが包含ブロックの辺をあふれ出るような値を持つ場合、これは起こることがある。

    要素の高さが、包含ブロックに割り当てられた明示的な高さを越える（すなわち、包含ブロックの高さが内容高さによってではなく、'height'プロパティによって決定される）。

    子孫ボックスは絶対配置であり、ボックスの外に部分的にある。そのようなボックスはそれらの祖先で常にoverflowプロパティによって切り取られるわけではない。特に、それらは自分自身とそれらの包含ブロックの間の任意の祖先のオーバーフローによって切り取られない。

    子孫ボックスは部分的にボックスの外に置かれるために、負のマージンを持つ。

    'text-indent'プロパティは、ブロックボックスの左右のどちらかの辺の後ろの方にいるインラインボックスの原因となる。
  はみ出しが起こるときはいつでも、'overflow'プロパティは、ボックスがパディング辺で切り取られたかどうか、かつ、もしそうだとしたら、スクロールメカニズムが任意の切り取られた内容にアクセスを提供するかどうかを指定する。

  11.1.1 はみ出し: 'overflow'プロパティ

  
    'overflow'

      
        値:  

              visible | hidden | scroll | auto | inherit
            初期値:  

              visible
            適用対象:  

              ブロックコンテナ
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、要素のボックスからはみ出したときに、ブロックコンテナ要素の内容が切り抜かれるかどうかを指定する。それは要素のすべてのコンテンツのクリッピングに影響を与える。ただし、任意の子孫要素（およびそれぞれの内容およびその子孫）の包含ブロックがビューポートまたは要素の祖先である場合を除く。値の意味は次のとおり:

  visible

    この値は内容を切り抜かないよう指示する。すなわち、ブロックボックスの外側に描画されてよい。

    hidden

    この値は、内容が切り抜かれるよう指示する。スクロールなしのユーザーインターフェースが切り抜き要素の外側で内容を閲覧するために提供されるべきである。

    scroll

    この値は、内容が切り抜かれるよう指示する。ユーザーエージェントが画面上で可視のスクロールメカニズム（スクロールバーやパン表示など）を用いる場合、そのメカニズムは、その内容が切り抜かれたどうかに関わらずボックスを表示されるべきである。こうすれば、スクロールバーが動的な環境に現れたり消えたりする問題を回避できる。この値が指定され、対象メディアが'print'の場合、はみ出した内容が印刷されてもよい。

    auto

    'auto'値の振る舞いはユーザーエージェント依存だが、はみ出したボックスにスクロールメカニズムを提供すべきである。
  たとえ'overflow'が'visible'に設定されても、内容はネイティヴな操作環境によってユーザーエージェントのウィンドウを切り抜かれてよい。

  ユーザーエージェントは、ビューポートへルート要素に設定された'overflow'プロパティを適用しなければならない。ルート要素はHTMLの"HTML"要素またはXHTMLの"html"要素であり、その要素は子としてHTMLの"BODY"要素またはXHTMLの"body"要素を持ち、ルート要素の値が'visible'である場合、ユーザエージェントは、そのような子要素の最初からビューポートまで、'overflow'プロパティを代わりに適用しなければならない。ビューポートに使用されるとき'visible'値は'auto'として解釈さればければならない。値が伝播された要素は'visible'の'overflow'の使用値を持たなければならない。

  要素のボックス辺に置かれるスクロールバーの場合、そのスクロールバーは内側のボーダー辺と外側のパディング辺の間に挿入すべきである。スクロールバーによって占有されるすべての領域は、スクロールバーを持つ要素によって整形される包含ブロック（の大きさから減算）から取り出されるべきである。

  
    例:

    次の例を考えてみよう。ブロック引用（<blockquote>）は（<div>によって設置された）包含ブロックが大きすぎる。以下にソースを示す:
    
<div>
<blockquote>
<p>I didn't like the play, but then I saw
it under adverse conditions - the curtain was up.</p>
<cite>- Groucho Marx</cite>
</blockquote>
</div>


    生成ボックスのサイズとスタイルを制御するスタイルシートは次のとおり:
    
div { width : 100px; height: 100px;
      border: thin solid red;
      }

blockquote   { width : 125px; height : 100px;
      margin-top: 50px; margin-left: 50px; 
      border: thin dashed black
      }

cite { display: block;
       text-align : right; 
       border: none
       }


    'overflow'の初期値は'visible'なので、<blockquote>は切り抜かれず、次のように整形されるだろう:

    
         [説明]
    

    一方、<div>の'overflow'プロパティを'hidden'に設定すると、<blockquote>は包含する<div>に切り抜かれる:

    
         [説明]
    

    'scroll'を指定すると、ユーザが切り抜き内容を閲覧できるように、視覚スクロールメカニズムをサポートするユーザーエージェントに対して促す。
  

  
    最後に、絶対配置の要素があふれた親と混ぜられた場合を検討してみる。

    スタイルシートは:
    
  container { position: relative; border: solid; }
  scroller { overflow: scroll; height: 5em; margin: 5em; }
  satellite { position: absolute; top: 0; }
  body { height: 10em; }


    文書断片は:
    
  <container>
   <scroller>
    <satellite/>
    <body/>
   </scroller>
  </container>


    この例では、後者の包含ブロックがあふれを切り取られてスクロールされる要素の外であるため、"scroller"要素は"satellite"要素をスクロールされない。
  

  11.1.2 切り抜き: 'clip'プロパティ

  切り抜き領域は、要素のボーダーボックスの可視部であると定義する。デフォルトで、要素は切り抜かれない。しかし、切り抜き領域は'clip'プロパティの設定で明示してよい。

  
    'clip'

      
        値:  

              <shape> | auto | inherit
            初期値:  

              auto
            適用対象:  

              絶対配置要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              'auto'として指定された、またはそうでなければそれぞれ4つの値を持つ矩形として指定された、または'auto'として指定され、かつそれ以外の場合は算出長さとして指定されれば'auto'
            
    

  'clip'プロパティは、絶対配置要素にのみ適用する。値の意味は次のとおり:

  auto

    要素を切り抜かない。

    <shape>

    
      CSS 2.1では、唯一妥当な<shape>値はrect(<top>, <right>, <bottom>, <left>) である。ここで<top>と<bottom>はボックスの上ボーダー辺からのオフセットを指定し、<right>と<left>はボックスの左ボーダー辺からのオフセットを指定する。著者はオフセット値をコンマで区切るべきである。ユーザーエージェントはコンマ区切りをサポートしなければならないが、コンマなし（組み合わせではない）の区切りをサポートしなくてもよい。本仕様の以前の版がこの点において曖昧であったためである。

      <top>、<right>、<bottom>、<left>は<length>値または'auto'のどちらかを持ってよい。負の値は許可される。値'auto'は、与えられた切り抜き領域の辺が、要素の生成ボーダーボックスの辺と同じになることを意味する（すなわち、'auto'は<top>と<left>が'0'と同じであり、垂直方向のパディングの合計と<bottom>のボーダー幅の合計を加えた高さの使用値と同じで、水平方向のパディングと<right>のボーダー幅の合計を加えた幅の使用値と同じであることを意味し、そのような切り抜き領域での4つの'auto'値の結果は要素のボーダーボックスと同じである）。

      座標がピクセル座標に丸められる場合、<left>と<right>が同じ値を持つ（または<top>と<bottom>が同じ値を持つ）とき、ピクセル表示が残らないよう注意し、逆にこれらの値が'auto'のとき要素のボーダーボックスが非表示のままである。
    
  要素の切り抜き範囲は、切り抜き領域外にある要素の任意のアスペクト（たとえば、もしあれば、内容、子供、背景、ボーダー、テキストの装飾、アウトライン、可視スクロール機構）を切り抜く。切り抜かれた内容は、あふれ出しが起きない。

  要素の祖先がそれらの内容の一部を切り抜いてもよい（たとえば、自分の'clip'プロパティを経由しおよび/または'overflow'プロパティが'visible'でない場合）。レンダリングされたものは、累積する共通集合である。

  切り抜き領域がユーザーエージェントの文書ウィンドウの境界を超えている場合、内容はネイティブの動作環境によってそのウィンドウに切り抜かれてもよい。

  
    例:

    次の2つの規則は:
    p#one { clip: rect(5px, 40px, 45px, 5px); }
p#two { clip: rect(5px, 55px, 45px, 5px); }

    両方の要素が50 * 55pxであると仮定すると、それぞれ、次の図に破線区切りで矩形の切り抜き領域を作成する:

    
         [説明]
    
  

  
    注。 CSS 2.1では、すべての切り抜き領域は矩形である。将来的には矩形でない切り抜き領域も使えるような拡張が望ましい。将来の更新は、各辺から図形を相殺する代わりに、点から相殺するための構文を再導入するかもしれない。
  

  11.2 可視性: 'visibility'プロパティ

  
    'visibility'

      
        値:  

              visible | hidden | collapse | inherit
            初期値:  

              visible
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  'visibility'プロパティは、要素を描画することによって生成されたボックスを表示するかどうかを指定する。不可視のボックスはそれでもレイアウトに影響する（完全にボックス生成を抑制するには'display'プロパティを'none'に設定する）。値の意味は次のとおり:

  visible

    生成ボックスを可視にする。

    hidden

    生成ボックスを不可視（何も描かれず、完全に透明）にするが、レイアウトには影響する。さらに、それが'visibility: visible'を持つ場合、要素の子孫は可視になる。

    collapse

    テーブルについての行や列の動的効果の節を参照のこと。行、行グループ、列、列グループ以外の要素で用いられる場合、'collapse'は'hidden'と同じ意味を持つ。
  このプロパティをスクリプトと組み合わせて動的な効果を生み出すこともできる。

  
    次の例では、どちらかのフォームのボタンを押すと対応するボックスを表示し、もう一方のボックスを非表示にする、著者が定義したスクリプト関数を呼び出す。これらのボックスは同じサイズと位置を持つので、一方が他方を置き換える効果が得られる。（このスクリプトコードは仮想的なスクリプト言語である。CSSを実装したユーザーエージェントが何らかの効果を得るとは限らない。）
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
<HEAD><TITLE>Dynamic visibility example</TITLE>
<META 
 http-equiv="Content-Script-Type"
 content="application/x-hypothetical-scripting-language">
<STYLE type="text/css">
<!--
   #container1 { position: absolute; 
                 top: 2in; left: 2in; width: 2in }
   #container2 { position: absolute; 
                 top: 2in; left: 2in; width: 2in;
                 visibility: hidden; }
-->
</STYLE>
</HEAD>
<BODY>
<P>Choose a suspect:</P>
<DIV id="container1">
   <IMG alt="Al Capone" 
        width="100" height="100" 
        src="suspect1.png">
   <P>Name: Al Capone</P>
   <P>Residence: Chicago</P>
</DIV>

<DIV id="container2">
   <IMG alt="Lucky Luciano" 
        width="100" height="100" 
        src="suspect2.png">
   <P>Name: Lucky Luciano</P>
   <P>Residence: New York</P>
</DIV>

<FORM method="post" 
      action="http://www.suspect.org/process-bums">
   <P>
   <INPUT name="Capone" type="button" 
          value="Capone" 
          onclick='show("container1");hide("container2")'>
   <INPUT name="Luciano" type="button" 
          value="Luciano" 
          onclick='show("container2");hide("container1")'>
</FORM>
</BODY>
</HTML>

  

  12 生成内容、自動番号付け、リスト

  
    目次

    12.1 :beforeと:after疑似要素

      12.2 'content'プロパティ

      
        12.3 引用符

        12.3.1 'quotes'プロパティで引用符を指定

          12.3.2 'content'プロパティで引用符を挿入
        

      
        12.4 自動カウンタと番号付け

        12.4.1 カウンタの入れ子と範囲

          12.4.2 カウンタの形式

          12.4.3 'display: none'の要素でのカウンタ
        

      
        12.5 リスト

        12.5.1 リスト: 'list-style-type'、'list-style-image'、'list-style-position'、'list-style'プロパティ
        
    

  場合によっては、著者はユーザーエージェントに文書ツリーに由来しない内容を描画させたくなることもあってよい。この身近な例は番号付きリストである。著者は明示的に番号を表示したくなく、番号の自動生成をユーザエージェントに求める。同様に、著者はユーザエージェントに、図のキャプションの前に単語"図"を、または第7章のタイトルの前に"第7章"と挿入させることができる。特に音声や点字の場合は、ユーザエージェントはこれらの文字列を挿入を可能にすべきである。

  CSS 2.1では、内容は次の2つのメカニズムによって生成されてよい:

  'content'プロパティ。:beforeと:afterの疑似要素と組み合わせて使う。

    'display'プロパティが'list-item'の値となっている要素。
  12.1  :beforeおよび:after疑似要素

  著者は、:beforeと:after疑似要素で生成内容のスタイルと場所を指定する。その名前が示すように、:beforeと:after擬似要素は、要素の文書ツリー内容の前後にコンテンツの場所を指定する。これらの擬似要素と組み合わせて、'content'プロパティは何を挿入するかを指定する。

  
    例:

    たとえば、次の規則は"class"属性に値"note"を持つすべてのP要素の内容の前に文字列"Note:"を挿入する:
    
p.note:before { content: "Note: " }

  

  要素によって生成された整形オブジェクト（たとえば、ボックス）は、生成コンテンツを含む。たとえば、上のスタイルシートを次のように変更すると:
  
p.note:before { content: "Note: " }
p.note        { border: solid green }


  緑の実線ボーダーが、先頭の挿入文字を含む段落全体の周囲に描画される。

  :before と:after の擬似要素は、擬似要素が伴う文書ツリー内の要素から継承可能なプロパティを継承する。

  
    例:

    たとえば、次の規則はすべてのQ要素の前に開始引用符を挿入する。引用符の色は赤になるが、そのフォントはQ要素の残りの部分のフォントと同じになる:
    
q:before {
  content: open-quote;
  color: red
}

  

  :beforeおよび:after疑似要素の宣言において、非継承のプロパティは初期値を取る。

  
    例:

    たとえば、'display'プロパティの初期値は'inline'なので、前の例の引用符はインラインボックスとして挿入される（すなわち要素の先頭にあるテキスト内容と同じ行に挿入される）。次の例では、'display'プロパティを'block'と明示しているので、挿入されるテキストはブロックになる:
    
body:after {
    content: "The End";
    display: block;
    margin-top: 2em;
    text-align: center;
}

  

  :beforeと:after擬似要素は、擬似要素があたかも擬似要素に関連付けられた要素の内部に挿入された実際の要素であるかのように、他のボックスと相互作用する。

  
    例:

    たとえば、以下の文書断片とスタイルシートで:
    
<p> Text </p>                   p:before { display: block; content: 'Some'; }


    次の文書断片とスタイルシートとまったく同じ方法でレンダリングされる:
    
<p><span>Some</span> Text </p>  span { display: block }


    同様に、以下の文書断片とスタイルシートで:
    
<h2> Header </h2>     h2:after { display: block; content: 'Thing'; }


    次の文書断片とスタイルシートとまったく同じ方法でレンダリングされる:
    
<h2> Header <span>Thing</span></h2>   h2 { display: block; }
                                      span { display: block; }

  

  
    注. 本仕様は、（HTMLのIMGのような）置換要素での:beforeおよび:afterの相互作用を完全に定義しない。これは、将来の仕様書で詳細に定義されるだろう。
  

  12.2  'content'プロパティ

  
    'content'

      
        値:  

              normal | none | [ <string> | <uri> | <counter> | attr(<identifier>) | open-quote | close-quote | no-open-quote | no-close-quote ]+ | inherit
            初期値:  

              normal
            適用対象:  

              :beforeおよび:after擬似要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              all
            算出値:  

              要素では、常に'normal'として計算する。:beforeと:afterでは、'normal'が指定された場合、'none'として計算する。そうでなければ、URI値では絶対URI、attr()値では結果の文字列、他のキーワードでは指定値に同じ。
            
    

  このプロパティは、文書内の内容を生成するために:beforeと:after擬似要素で使用される。値の意味は次のとおり:

  none

    擬似要素を生成しない。

    normal

    :beforeと:after擬似要素を'none'として計算する。

    <string>

    テキスト内容（文字列の節を参照のこと）。

    <uri>

    この値は、（画像などの）外部リソースを指定するURIとなる。ユーザエージェントがリソースを表示できない場合、ユーザーエージェントは、あたかも指定されていないかのようにリソースを除外するか、あるいはリソースを表示不能という印を表示しなければならない。

    <counter>

    カウンタは2種類の異なる関数'counter()'または'counters()'を指定してよい。前者は2つの形式、'counter(name)'または'counter(name, style)'を持つ。生成されるテキストは、この擬似要素で与えられた名前の最も内側のカウンタの値となる。指定したstyleで整形される（デフォルトは'decimal'）。後者もまた2つの形式、'counters(name, string)'または'counters(name, string, style)'を持つ。生成されるテキストは、この擬似要素で与えられた名前の全カウンタの値で、指定された文字で区切られた最も外側から最も内側までである。カウンタは指定したstyleで描画される（デフォルトは'decimal'）。詳細は自動カウンタと番号付けを参照のこと。名前は'none'、'inherit'または'initial'であってはならない。そのような名前は無視される宣言の原因となる。

    open-quoteおよびclose-quote

    これらの値は'quotes'プロパティから適当な文字列に置き換えられる。

    no-open-quoteおよびno-close-quote

    何も挿入しないが、引用レベルは増加（または減少）する。

    attr(X)

    この関数は、セレクタの主体に対する属性Xの値を文字列として返す。文字列はCSSプロセッサによって解析されない。セレクタの主体が属性Xを持たない場合、空文字列が返される。属性名の大小文字の区別は文書言語に依存する。
  
    注。 CSS 2.1では、セレクタの主体とならない要素の持つ属性値は参照できない。
  

  'display'プロパティは、内容がブロックまたはインラインボックスに置くかどうかを制御する。

  
    例:

    次の規則は、文字列"Chapter: "を各H1要素の前に生成する:
    
H1:before { 
  content: "Chapter: ";
  display: inline;
}

  

  著者は　生成内容内にエスケープ文字"\A"を記述すると、文字列型に改行を含めることができる。この挿入される改行はまだ'white-space'プロパティの影響下にある。"\A"エスケープシーケンスについての詳細は文字列うよび文字列と活字ケースを参照のこと。

  
    例:
    
h1:before {
    display: block;
    text-align: center;
    white-space: pre;
    content: "chapter\A hoofdstuk\A chapitre"
}

  

  生成内容は文書ツリーを変更しない。特に、文書言語のプロセッサにフィードバックされることはない（たとえば、再解析）。

  12.3 引用符

  CSS 2.1では、コンテキストに依存した方法で、スタイルに影響され、ユーザエージェントが引用符をレンダリングする方法を、著者は指定してよい。'quotes'プロパティは、埋め込まれた引用箇所の各レベルに対する引用符のペアを指定する。'content'プロパティは、指定した引用符へのアクセスを提供し、引用符を引用箇所の前後に挿入する。

  12.3.1 'quotes'プロパティで引用符を指定

  
    'quotes'

      
        値:  

              [<string> <string>]+ | none | inherit
            初期値:  

              ユーザーエージェントに依存
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、埋め込まれた引用箇所の任意の数の引用符を指定する。値の意味は次のとおり:

  none

    'content'プロパティの'open-quote'および'close-quote'値は引用符を生成しない。

    [<string>  <string>]+

    'content'プロパティの'open-quote'および'close-quote'値に対する値は、このリストから（開きと綴じ）引用符のペアが選ばれる。最初（最も左の）ペアは引用の最も外側のレベルを表し、2番目のペアは埋め込みの1番目のレベルを表す。ユーザエージェントは、埋め込みのレベルに応じて引用符の適切なペアを適用しなければならない。
  
    例:

    たとえば、次のスタイルシートを:
    
/* 2言語の2レベルの引用符のペアを指定する */
q:lang(en) { quotes: '"' '"' "'" "'" }
q:lang(no) { quotes: "«" "»" '"' '"' }

/* Q 要素の内容の前後に引用符を挿入する */
q:before { content: open-quote }
q:after  { content: close-quote }


    以下のHTML断片に適用すると:
    
<HTML lang="en">
  <HEAD>
  <TITLE>Quotes</TITLE>
  </HEAD>
  <BODY>
    <P><Q>Quote me!</Q>
  </BODY>
</HTML>


    ユーザーエージェントはこのように引用符を生成する:
    
"Quote me!"


    一方このようなHTML断片では:
    
<HTML lang="no">
  <HEAD>
  <TITLE>Quotes</TITLE>
  </HEAD>
  <BODY>
    <P><Q>Trøndere gråter når <Q>Vinsjan på kaia</Q> blir deklamert.</Q>
  </BODY>
</HTML>


    このようになる:
    
«Trøndere gråter når "Vinsjan på kaia" blir deklamert.»

  

  
    注。 前の例で'quotes'に指定した引用符は、便利なことにコンピュータのキーボード上に配置されているが、高品質な組版はさまざまなISO 10646の文字が必要になるだろう。以下の参考情報の表はISO 10646の引用符文字の一部である:

    文字

          近似レンダリング

          ISO 10646コード（16進数）

          説明
        "

          "

          0022

          QUOTATION MARK [the ASCII double quotation mark]
        '

          '

          0027

          APOSTROPHE [the ASCII single quotation mark]
        ‹

          <

          2039

          SINGLE LEFT-POINTING ANGLE QUOTATION MARK
        ›

          >

          203A

          SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
        «

          «

          00AB

          LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
        »

          »

          00BB

          RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
        ‘

          `

          2018

          LEFT SINGLE QUOTATION MARK [single high-6]
        ’

          '

          2019

          RIGHT SINGLE QUOTATION MARK [single high-9]
        “

          ``

          201C

          LEFT DOUBLE QUOTATION MARK [double high-6]
        ”

          ''

          201D

          RIGHT DOUBLE QUOTATION MARK [double high-9]
        „

          ,,

          201E

          DOUBLE LOW-9 QUOTATION MARK [double low-9]
        

  12.3.2 'content'プロパティで引用符を挿入する

  引用符は'content'プロパティの'open-quote'や'close-quote'の値によって文書の適切な位置に挿入される。'open-quote'または'close-quote'のそれぞれの出現は、入れ子の深さに基づき、'quotes'の値から文字列の1つと置き換わる。

  'open-quote'は1組の引用符の1つ目を、'close-quote'は2つ目を参照する。どの引用符の組を用いるかは、引用の入れ子レベルに依存する。すべての'open-quote'の出現回数は現在の出現前のテキストが生成され、'close-quote'の出現回数を引いたものである。深さが0の場合、最初の組が使用され、深さが1の場合、2つ目の組が用いられる。深さがペア数より多い場合、最後のペアが繰り返される。深さが負になる'close-quote'または'no-close-quote'は誤ったものであり（レンダリング時に）無視される。深さが0のままであり、引用符はレンダリングされない（'content'プロパティの値の残りがまだ書きこまれているにもかかわらず）。

  
    注。 引用の深さは、ソース文書や書式構造のネストとは無関係である。
  

  一部の印刷スタイルは、複数の段落にまたがる引用の段落ごとの前に繰り返される開始引用符が要求されるが、最後の段落では終了引用符のみで終了する。CSSでは、実体のない終了引用符を挿入することによってこれを実現可能である。キーワード'no-close-quote'は、引用レベルを減らすが、引用符は挿入しない。

  
    例:

    次のスタイルシートはBLOCKQUOTE内のすべての段落で開始引用符を置き、最後に単一の終了引用符を挿入する：
    
blockquote p:before     { content: open-quote }
blockquote p:after      { content: no-close-quote }
blockquote p.last:after { content: close-quote }


    これは、クラス"last"のマーク付けがされた最終段落に依存する。
  

  同様に、'no-open-quote'キーワードも何も挿入しないが、引用深さを1だけ増やす。

  12.4 自動カウンタと番号付け

  CSS 2.1の自動番号付けは、'counter-increment'と'counter-reset'の2つのプロパティで制御される。これらのプロパティによって定義されたカウンタは'content'プロパティのcounter()とcounters()関数とともに用いられる。

  
    'counter-reset'

      
        値:  

              [ <identifier> <integer>? ]+ | none | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              all
            算出値:  

              指定値
            
    

  
    'counter-increment'

      
        値:  

              [ <identifier> <integer>? ]+ | none | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              all
            算出値:  

              指定値
            
    

  'counter-increment'プロパティは、1つ以上のカウンタの名前（識別子）、オプションで各カウンタの後に整数を受け入れる。整数値は、どのくらいカウンタが要素の出現ごとに増やされるかを示す。デフォルトの増加値は1である。0と負の整数は許可される。

  'counter-reset'のプロパティも、1つ以上のカウンタ名と、オプションで各カウンタ名に続く整数値を含む。整数値は、カウンタが要素の出現ごとに設定される値を与える。デフォルトは0である。

  キーワード'none'、'inherit'、'initial'はカウンタ名として使用してはならない。'none'の値はそのままでカウンタがリセットされないことを意味し、それぞれインクリメントされる。'Inherit'はそのままで通常の意味を持つ（6.2.1節参照）。'Initial'は将来のために予約される。

  
    例:

    この例は、"Chapter 1"、"1.1"、"1.2"などの章や節の番号を付ける方法を示す:
    
BODY {
    counter-reset: chapter;      /* 章のカウンタ範囲を作成 */
}
H1:before {
    content: "Chapter " counter(chapter) ". ";
    counter-increment: chapter;  /* 章を1から加える */
}
H1 {
    counter-reset: section;      /* 0節を設定 */
}
H2:before {
    content: counter(chapter) "." counter(section) " ";
    counter-increment: section;
}

  

  要素がカウンタのインクリメントまたはリセットをし、またそれを（その:beforeまたは:after擬似要素の'content'プロパティで）使用する場合、カウンタはリセットまたはインクリメントされた後に使用される。

  要素がカウンタをリセットもインクリメントもする場合、カウンタは最初にリセットし、それからインクリメントする。

  同じカウンタが'counter-reset'と'counter-increment'プロパティの値で1回以上指定される場合、カウンタのリセットまたはインクリメントは指定された順番で処理される。

  
    例:

    以下の例は'section'カウンタを0にリセットする:
    
H1 { counter-reset: section 2 section }


    以下の例は'chapter'カウンタを3ずつインクリメントする:
    
H1 { counter-increment: chapter chapter 2 }

  

  'counter-reset'プロパティはカスケード規則の後に続く。したがって、カスケードによって、以下のスタイルシートは:
  
H1 { counter-reset: section -1 }
H1 { counter-reset: imagenum 99 }


  'imagenum'のみリセットする。両方のカウンタをリセットするためには、同時に指定する必要がある:
  
H1 { counter-reset: section -1 imagenum 99 }


  12.4.1 カウンタの入れ子と範囲

  カウンタは、子孫要素または疑似要素のカウンタをリセットすると、自動的にカウンタの新しいインスタンスを作成するという意味で、"自己入れ子"である。要素が任意の深さに自分自身の内側に入れ子にすることができ、HTMLのリストのような状況のために、これは重要である。各レベルごとに一意の名前のカウンタを定義することは不可能だろう。

  
    例:

    したがって、ネストされたリスト項目には、次で数が十分である。'display:list-item'とLI要素の'list-style: inside'の結果は、非常に似ている。
    
OL { counter-reset: item }
LI { display: block }
LI:before { content: counter(item) ". "; counter-increment: item }

  

  カウンタの範囲は、そのカウンタの'counter-reset'を持ち、それらの子孫とともに要素の子孫とその次の兄弟を含む文書内の最初の要素から始まる。しかし、それは要素の後の兄弟の'counter-reset'や同じ要素の後の'counter-reset'によって作成された同じ名前をもつカウンタの範囲内の任意の要素は含まれない。

  要素または擬似要素の'counter-increment'または'content'が任意の'counter-reset'の範囲にないカウンタ参照する場合、'counter-reset'がその要素または擬似要素でカウンタを0にリセットされたかのように実装は動作すべきである。

  上の例では、OLがカウンタを作成し、OLのすべての子供がそのカウンタを参照する。

  
    item[n]によってn番目の"item"カウンタのインスタンスを表し、"{"と"}"によって範囲の開始と終了を表す場合、その結果、次のHTML断片は指定されたカウンタを使用する。（上記の例で与えられたスタイルシートと仮定する）。
    
<OL>                    <!-- {item[0]=0        -->
  <LI>item</LI>         <!--  item[0]++ (=1)   -->
  <LI>item              <!--  item[0]++ (=2)   -->
    <OL>                <!--  {item[1]=0       -->
      <LI>item</LI>     <!--   item[1]++ (=1)  -->
      <LI>item</LI>     <!--   item[1]++ (=2)  -->
      <LI>item          <!--   item[1]++ (=3)  -->
        <OL>            <!--   {item[2]=0      -->
          <LI>item</LI> <!--    item[2]++ (=1) -->
        </OL>           <!--                   -->
        <OL>            <!--   }{item[2]=0     -->
          <LI>item</LI> <!--    item[2]++ (=1) -->
        </OL>           <!--                   -->
      </LI>             <!--   }               -->
      <LI>item</LI>     <!--   item[1]++ (=4)  -->
    </OL>               <!--                   -->
  </LI>                 <!--  }                -->
  <LI>item</LI>         <!--  item[0]++ (=3)   -->
  <LI>item</LI>         <!--  item[0]++ (=4)   -->
</OL>                   <!--                   -->
<OL>                    <!-- }{item[0]=0       -->
  <LI>item</LI>         <!--  item[0]++ (=1)   -->
  <LI>item</LI>         <!--  item[0]++ (=2)   -->
</OL>                   <!--                   -->

  

  
    例:

    カウンタがネストされない要素で使用される場合、範囲がどのように機能するかを示す別の例は、次のとおりである。上記で与えられたスタイル規則が、章や節の番号にどのように与えられたマークアップに適用するかを示す。
    
                     <!--"chapter" counter|"section" counter -->
<body>               <!-- {chapter=0      |                  -->
  <h1>About CSS</h1> <!--  chapter++ (=1) | {section=0       -->
  <h2>CSS 2</h2>     <!--                 |  section++ (=1)  -->
  <h2>CSS 2.1</h2>   <!--                 |  section++ (=2)  -->
  <h1>Style</h1>     <!--  chapter++ (=2) |}{ section=0      -->
</body>              <!--                 | }                -->

  

  'counters()'関数は、与えられた文字列によって区切られた、範囲内にある同じ名前を持つすべてのカウンタで構成される文字列を生成する。

  
    例:

    次のスタイルシートは、"1"、"1.1"、"1.1.1"などとしてネストされたリスト項目を番号付けする。
    
OL { counter-reset: item }
LI { display: block }
LI:before { content: counters(item, ".") " "; counter-increment: item }

  

  12.4.2 カウンタの形式

  デフォルトでは、カウンタは10進数で整形されるが、'list-style-type'プロパティに使用可能なすべてのスタイルが、カウンタにも利用できる。記法は以下のとおり:
  
counter(name)


  これがデフォルトである。さもなければ:
  
counter(name, <'list-style-type'>)


  'disc'、'circle'、'square'、'none'を含むすべての形式が許可される。

  
    例:
    
H1:before        { content: counter(chno, upper-latin) ". " }
H2:before        { content: counter(section, upper-roman) " - " }
BLOCKQUOTE:after { content: " [" counter(bq, lower-greek) "]" }
DIV.note:before  { content: counter(notecntr, disc) " " }
P:before         { content: counter(p, none) }

  

  12.4.3 'display: none'をもつ要素のカウンタ

  （'display'が'none'に設定されている）表示されない要素は、カウンタの増加や初期化を行うことができない。

  
    例:

    たとえば、次のスタイルシートだと、classが"secret"をもつH2要素は'count2'の数値は増加しない:
    
H2.secret {counter-increment: count2; display: none}

  

  擬似要素は、生成だけでなく、カウンタをインクリメントまたはリセットすることができない。

  
    例:

    たとえば、以下は'heading'をインクリメントしない:
    
h1::before {
    content: normal;
    counter-increment: heading;
}

  

  一方、'visibility'を'hidden'に設定された要素は、カウンタをインクリメントする。

  12.5 リスト

  CSS 2.1は、リストの基本的な視覚的書式を提供する。'display: list-item'をもつ要素は要素の内容のために主ブロックボックスを生成し、'list-style-type'と'list-style-image'の値に依存し、視覚的にマーカーボックスの可能性に応じた要素がリストアイテムであることを指示する。

  リストプロパティはリストの基本的な視覚整形を説明する。これらはスタイルシートにマーカータイプ（画像、グリフ、または数字）および、主ボックスに対するマーカーの位置（外側か内容の前か）の指定を許す。これらは、著者がリストマーカーの異なるスタイル（色、フォント、配置など）を指定することや、主要ボックスに対する位置を調整することはできない。これらは主要ボックスから派生させてもよい。

  背景プロパティは主要ボックスにのみ適用する。'outside'マーカーボックスは透明である。

  12.5.1 リスト: 'list-style-type'、'list-style-image'、'list-style-position'、'list-style'プロパティ

  
    'list-style-type'

      
        値:  

              disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit
            初期値:  

              disc
            適用対象:  

              'display: list-item'をもつ要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、リスト項目マーカーの外観を指定する。ただし、'list-style-image'が値'none'を持つ、またはURIで指示する画像が表示できない場合に限る。値'none'はマーカーを指定しない。そうでなければ、グリフ、数字、アルファベットの3種類のマーカーとなる。

  グリフにはdisc、circle、squareを指定する。これらの正確なレンダリングはユーザーエージェントに依存する。

  番号方式は:

  decimal

    10進数、1から始める。

    decimal-leading-zero

    冒頭を0で詰め物をした10進数（たとえば、01, 02, 03, ..., 98, 99）。

    lower-roman

    小文字のローマ数字（i, ii, iii, iv, v, など）。

    upper-roman

    大文字のローマ数字（I, II, III, IV, V, など）。

    georgian

    伝統的なグルジア数字（an, ban, gan, ..., he, tan, in, in-an, ...）。

    armenian

    伝統的なアルメニア数字。
  アルファベットの種類は:

  lower-latinまたはlower-alpha

    小文字のアスキー（a, b, c, ... z）。

    upper-latinまたはupper-alpha

    大文字のアスキー（A, B, C, ... Z）。

    lower-greek

    小文字の古代ギリシャ文字。アルファ、ベータ、ガンマ...（α, β, γ, ...）
  本仕様は、アルファベットの終わりでどのようにアルファベットシステムの折り返しをするか定義しない。たとえば、26リスト項目のあとで、'lower-latin'のレンダリングは未定義である。したがって、長いリストでは、著者が本物の数字を指定することを推奨する。

  CSS 2.1は、どのようにリスト番号がリセットされ、インクリメントされるかを定義しない。これはCSS List Moduleで定義されることが期待される[CSS3LIST]。

  
    たとえば、以下のHTML文書で:
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
   <HEAD>
     <TITLE>Lowercase latin numbering</TITLE>
     <STYLE type="text/css">
          ol { list-style-type: lower-roman }   
     </STYLE>
  </HEAD>
  <BODY>
    <OL>
      <LI> This is the first item.
      <LI> This is the second item.
      <LI> This is the third item.
    </OL>
  </BODY>
</HTML>


    これは次のように整形されるだろう:
    
  i This is the first item.
 ii This is the second item.
iii This is the third item.


    リストマーカーの揃え（ここでは、右揃え）はユーザーエージェントに依存する。
  

  
    'list-style-image'

      
        値:  

              <uri> | none | inherit
            初期値:  

              none
            適用対象:  

              'display: list-item'をもつ要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              絶対URIまたは'none'
            
    

  このプロパティは、リストマーカーとして用いる画像を設定する。画像が利用可能の場合、'list-style-type'で設定したマーカーと置き換える。

  画像の大きさは以下の規則より計算される:

  画像が固有の幅と高さを持つ場合、使用幅と高さは固有の幅と高さになる。

    そうでなければ、画像が固有比と、固有幅または固有高さのいずれかを持つ場合、使用幅または高さが供給される固有幅または高さと同じで、不足する寸法の使用値が供給される寸法と比から計算される。

    そうでなければ、画像が固有比を持つ場合、使用幅は1emで、使用高さはこの幅と固有比から計算される。これが1emよりも大きな高さを生成したい場合、使用高さは1emの代わりに設定され、使用幅はこの高さと固有比から計算される。

    そうでなければ、固有幅あるいは1emを持つ場合、画像の使用幅は固有幅となる。固有高さあるいは1emを持つ場合、画像の使用高さはその固有高さである。
  
    例:

    以下の例は、画像"ellipse.png"を各リスト項目の先頭にマーカーとして設定する。
    
ul { list-style-image: url("http://png.com/ellipse.png") }

  

  
    'list-style-position'

      
        値:  

              inside | outside | inherit
            初期値:  

              outside
            適用対象:  

              'display: list-item'をもつ要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは主要ブロックボックスに対するマーカーボックスの位置を指定する。値の意味は次のとおり:

  outside

    マーカーボックスは主要ブロックボックスの外側になる。浮動体に隣接するlist-itemマーカーの位置はCSS 2.1で未定義である。CSS 2.1は、マーカーボックスの正確な位置や塗装の順序での位置を指定しないが、リスト項目の'direction'プロパティが'ltr'のものについては、マーカーボックスはコンテンツの左側であることが、および要素の'direction'プロパティが'rtl'であるものについては、マーカーボックスはコンテンツの右側にあることが要求される。マーカーボックスは、主要ブロックボックスのボーダーに対して固定され、主要ボックスの内容に対してスクロールしない。CSS 2.1では、要素の'overflow'が'visible'以外の場合、ユーザーエージェントはマーカーを隠してよい。（これは将来変更することが期待される。）マーカーボックスの大きさや内容は、主要ブロックボックスの高さとその最初の行ボックスの高さの両方またはいずれか一方に影響を与えてよく、場合によっては新しい行ボックスの作成を引き起こしてよい。注: この相互作用は、より正確にはCSSの将来のレベルで定義されている可能性がある。

    inside

    マーカーボックスは、要素の内容の前および任意の:before擬似要素の前に、主要ブロックボックスの最初のインラインボックスとして配置される。CSS 2.1はマーカーボックスの正確な位置を指定しない。
  
    たとえば:
    
<HTML>
  <HEAD>
    <TITLE>Comparison of inside/outside position</TITLE>
    <STYLE type="text/css">
      ul         { list-style: outside }
      ul.compact { list-style: inside }
    </STYLE>
  </HEAD>
  <BODY>
    <UL>
      <LI>first list item comes first
      <LI>second list item comes second
    </UL>

    <UL class="compact">
      <LI>first list item comes first
      <LI>second list item comes second
    </UL>
  </BODY>
</HTML>


    上の例は次のように整形されてよい:

    
         [説明]
    

    テキストが右から左では、マーカーはボックスの右側にくるだろう。
  

  
    'list-style'

      
        値:  

              [ <'list-style-type'> || <'list-style-position'> || <'list-style-image'> ] | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              'display: list-item'をもつ要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  'list-style'は、'list-style-type'、'list-style-image'、'list-style-position'という3つのプロパティを1箇所で設定できる簡略プロパティである。

  
    例:
    
ul { list-style: upper-roman inside }  /* 任意の"ul"要素 */
ul > li > ul { list-style: circle outside } /* 任意の"ul"要素の子"li"の子"ul" */

  

  著者は直接リスト項目の要素の'list-style'情報（例えば、HTMLで"li"）を指定してよいが、それらは慎重に行うべきである。次の規則は似ているが、最初は子孫セレクタを、2番目は（より具体的な）子セレクタを宣言している。
  
ol.alpha li   { list-style: lower-alpha } /* 任意の "ol" の子孫 "li" */ 
ol.alpha > li { list-style: lower-alpha } /* 任意の"ol"の子"li" */


  著者は、子孫セレクタのみを用いて、意図する結果を得られないかもしれない。次の規則を考えてみる:
  
<HTML>
  <HEAD>
    <TITLE>WARNING: Unexpected results due to cascade</TITLE>
    <STYLE type="text/css">
      ol.alpha li  { list-style: lower-alpha }
      ul li        { list-style: disc }
    </STYLE>
  </HEAD>
  <BODY>
    <OL class="alpha">
      <LI>level 1
      <UL>
         <LI>level 2
      </UL>
    </OL>
  </BODY>
</HTML>


  意図するレンダリングは、'lower-alpha'ラベルのレベル1のリスト項目と、'disc'ラベルのレベル2の項目とを持つ。しかし、カスケード順序は（クラス情報を含む）最初の規則で2つ目の規則を隠してしまう。次の規則は、代わりに子セレクタを用いることによって問題を解決する:
  
ol.alpha > li  { list-style: lower-alpha }
ul li   { list-style: disc }


  もう1つの解決法は、リスト型の要素に'list-style'の情報を指定する方法である:
  
ol.alpha  { list-style: lower-alpha }
ul        { list-style: disc }


  継承は、OLとUL要素からLI要素に'list-style'値を転送する。これは、リストのスタイル情報を指定するための推奨される方法である。

  
    例:

    URI値は、他の値と組み合わせてよい:
    
ul { list-style: url("http://png.com/ellipse.png") disc }


    上記の例では、画像が使用できない場合に'disc'が使用される。
  

  'list-style'プロパティ内で'none'の値を設定すると、'list-style-type'と'list-style-image'のいずれかは別な方法で'none'に指定されない。両方が別な方法で指定される場合は、宣言はエラーになる（したがって無視される）。

  
    例:

    たとえば、'list-style'プロパティへの'none'の値は、'list-style-type'と'list-style-image'の両方に'none'に設定する:
    
ul { list-style: none }


    結果、リスト項目のマーカーは表示されない。
  

  13 ページメディア

  
    目次

    13.1 ページメディア概論

      
        13.2 ページボックス: @page規則

        13.2.1 ページのマージン

          13.2.2 ページセレクタ: 左右と最初のページの選択

          13.2.3 ページボックスの外側の内容
        

      
        13.3 改ページ

        13.3.1 改ページプロパティ: 'page-break-before'、'page-break-after'、 'page-break-inside'

          13.3.2 要素の内側での改ページ: 'orphans'、'widows'

          13.3.3 改ページの許可

          13.3.4 強制改ページ

          13.3.5 最適な改ページ
        

      13.4 ページコンテキストにおけるカスケード処理
    

  13.1 ページメディア概論

  ページメディア（たとえば、紙、OHPフィルム、コンピュータ画面に表示されるページなど）は、文書の内容が、1つ以上の離散的なページに分割されるという点で連続メディアとは異なる。ページを処理するために、CSS 2.1は、ページのマージンがページボックスに設定されている方法と、改ページを宣言する方法を説明する。

  ユーザエージェントは、文書が最終的に（紙、OHPフィルム、画面などが）レンダリングされる実際のシートに、文書のページボックスを転送する責任がある。多くの場合ページボックスとシートの間は1対1の関係であるが、常にそうであるとは限らない。転送の可能性は次のとおり:

  1つのページボックスを、1枚のシート（たとえば、片面印刷）に転送する。

    2つのページボックスを、同じシートの両側（たとえば、両面印刷）に転送する。

    N個の（小さな）ページボックスを、1枚のシートに転送する（"n-up"と呼ばれる）。

    1つの（大きな）ページボックスを、N×M枚のシートに転送する（"タイル"と呼ばれる）。

    折り丁を作成する。折り丁は、折りたたんで本のように編集したときに、それらの適切な順序で現れ、シートに印刷されたページのグループである。

    1つの文書を複数の出力トレイに印刷する。

    ファイルに出力する。
  13.2 ページボックス: @page規則

  ページボックスは、次の2つの領域を含む矩形の領域である:

  ページ領域。ページ領域は、そのページにレイアウトされるボックスを含む。最初のページ領域の辺は、文書の初期包含ブロックである矩形を設置する。キャンバスの背景が内部で塗られ、ページ領域をカバーする。

    マージン領域。これがページ領域を取り囲む。ページマージン領域は透明である。
  ページボックスのサイズは、CSS 2.1で指定することはできない。

  著者は、@page規則内のページボックスのマージンを指定可能である。@page規則は、宣言と@規則を含むブロックに続いて、任意のページセレクタ、続いてキーワード"@page"で構成されている。コメントと空白は@pageトークンとページセレクタとの間およびページセレクタとブロックの間に任意で許可される。@page規則の宣言は、ページコンテキスト内にあると言われる。

  注: CSS level 2は、@page内に出現してよい@規則はないが、そのような@規則はlevel 3で定義されることが期待される。

  ページセレクタは、宣言を適用するページを指定する。CSS 2.1では、ページセレクタは、最初のページ、すべての左ページ、またはすべての右ページを指定してよい。

  不正な形式の宣言、不正な形式の文、@page内の妥当でない@規則を扱うための規則は、以下に加えて4.2節で定義される。ユーザーエージェントが予期しないトークンを検出する代わりに、宣言または@規則の開始（すなわち、IDENTトークンまたはATKEYWORDトークン）を予期する場合、そのトークンは不正な形式の宣言の最初のトークンであると考えられる。すなわち、不正な形式の文よりもむしろ不正な形式の宣言のための規則が、そのような場合に無視するトークンを決定するために使用される。

  13.2.1 ページのマージン

  CSS2.1では、マージンプロパティ（'margin-top'、'margin-right'、'margin-bottom'、'margin-left'、および'margin'）のみがページコンテキスト内で適用される。次の図はシート、ページボックス、およびページのマージンとの関係を示している:

  
       [説明]
  

  
    例:

    すべてのページのマージンを設定した簡単な例は次のとおり:
    
@page {
  margin: 3cm;
}

  

  ページコンテキストはフォントの概念を持たないので、'em'と'ex'単位は許可されない。マージンのプロパティのパーセント値は、ページボックスの寸法に対して相対的である。左右のマージンのためにそれらはページボックスの幅を参照し、一方上下のマージンのために、それらはページボックスの高さを参照する。個別のCSS 2.1プロパティに関連付けられた他の単位すべてが許可される。

  負のマージン値（ページボックスまたは要素上のいずれか）または絶対位置決めコンテンツは、ページボックスの外側で終わってもよいが、このコンテンツはユーザエージェント、プリンタ、または最終的には、ペーパーカッターによって"カット"されてよい。

  13.2.2 ページセレクタ: 左右と最初のページの選択

  両面文書を印刷する場合、左右のページでページボックスは異なってよい。これは、ページセレクタで使用してよい2つのCSS疑似クラスを介して表現可能である。

  すべてのページはユーザエージェントによって自動的に:leftまたは:rightどちらかの擬似クラスに分類される。文書の最初のページが:leftか:rightであるかどうかは、ルート要素の主要な書字方向に依存する。たとえば、左から右への主要な書き込み方向の文書の最初のページは:rightになり、右から左への主要な書き込み方向の文書の最初のページは:leftとなる。左または右ページで印刷を開始する文書を明示的に強制することで、著者は最初の生成ボックスの前に改ページを挿入可能である。

  
    例:
    
@page :left {
  margin-left: 4cm;
  margin-right: 3cm;
}

@page :right {
  margin-left: 3cm;
  margin-right: 4cm;
}

  

  別の宣言が左と右のページに付与される場合、ユーザエージェントは、たとえ左右のシート（たとえば、片面印刷のみのプリンタ）にページボックスを転送しない場合でも、ユーザーエージェントは、これらの宣言を尊重しなければならない。

  著者はまた、:first擬似クラスを用いて文書の最初のページのスタイルを指定してよい:

  
    例:
    
@page { margin: 2cm } /* すべてのマージンを2cmに設定 */

@page :first {
  margin-top: 10cm    /* 最初のページの上マージンを10cm */
}

  

  :leftまたは:rightの@page規則で指定したプロパティは、擬似クラス指定のない@page規則で指定されたものを上書きする。:first @page規則で指定されたプロパティは、:leftまたは:rightの@page規則で指定されたものを上書きする。

  強制改行が最初の生成ボックスの前に発生する場合、':first'がその改行の前の空白ページに、またはその後にページに適用されるかどうか、CSS2.1で未定義である。

  左、右、最初のページのマージンの宣言は、別のページ領域の幅になってもよい。実装を簡素化するために、ユーザエージェントは、左、右、最初のページの単一のページ領域幅を使用してよい。このケースでは、最初のページのページ領域幅を使用すべきである。

  13.2.3 ページボックスの外側の内容

  ページモデルで内容を整形する場合、一部の内容は、最後には現在のページボックスの外側になるかもしれない。たとえば、'white-space'プロパティが値'pre'を持つ要素は、ページボックスよりも幅が広いボックスを生成してよい。別の例として、ボックスが相対または絶対配置される場合、それらは最後に"不便な"場所になるかもしれない。たとえば、画像はページボックスの下辺またはページボックスの下100,000メートルに配置されるかもしれない。

  そのような要素の実際の整形は本仕様の範囲外である。しかし、著者やユーザエージェントがページボックス外の内容に関して、以下の一般的な原則を遵守することを推奨する:

  内容は、ページを"はみだし"可能にするためにわずかにページボックスを超えて許可されるべきである。

    ユーザエージェントは、要素の位置を尊重するために空のページボックスの大量生成を回避すべきである（たとえば、100の空白ページを印刷しなくてよい）。

    著者は、それらのレンダリングを避けるために不便な場所に要素を配置すべきでない。

    ユーザエージェントは、それらを捨てる、または文書の最後にそれらのページボックスを作成することをを含むいくつかの方法で、ページボックスの外側に位置するボックスを処理してよい。
  13.3 改ページ

  この節では、CSS 2.1での改ページを説明する。ユーザエージェントは、どこで改ページをしてよいか、またはすべきであるか、およびどの（左または右）ページで後続のコンテンツを再開すべきかを、5つのプロパティが示す。各改ページは、現在のページボックスでレイアウトを終了し、新しいページボックスでのレイアウトを文書ツリーの残りの部分にもたらす。

  13.3.1 改ページプロパティ: 'page-break-before'、'page-break-after'、'page-break-inside'

  
    'page-break-before'

      
        値:  

              auto | always | avoid | left | right | inherit
            初期値:  

              auto
            適用対象:  

              ブロックレベル要素（ただしテキスト参照）
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual, paged
            算出値:  

              指定値
            
    

  
    'page-break-after'

      
        値:  

              auto | always | avoid | left | right | inherit
            初期値:  

              auto
            適用対象:  

              ブロックレベル要素（ただしテキスト参照）
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual, paged
            算出値:  

              指定値
            
    

  
    'page-break-inside'

      
        値:  

              avoid | auto | inherit
            初期値:  

              auto
            適用対象:  

              ブロックレベル要素（ただしテキスト参照）
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual, paged
            算出値:  

              指定値
            
    

  これらのプロパティの値は以下の意味を持つ:

  auto

    生成ボックスの前（後、内部）で改ページを強制も禁止もしない。

    always

    生成ボックスの前（後）で常に改ページを強制する。

    avoid

    生成ボックスの前（後）で常に改ページを避ける。

    left

    次のページが左ページとして整形できるように、生成ボックスの前（後）に1つまたは2つの改ページを強制する。

    right

    次のページが右ページとして整形できるように、生成ボックスの前（後）に1つまたは2つの改ページを強制する。
  適合ユーザエージェントは'always'として'left'と'right'の値を解釈してよい。

  潜在的な改ページの位置は、典型的には　親要素の'page-break-inside'プロパティ、前の要素の'page-break-after'のプロパティ、次の要素の'page-break-before'プロパティの影響のもとにある。これらのプロパティが'auto'以外の値を持つ場合、値'always'、'left'、および'right'は'avoid'よりも優先する。

  ユーザエージェントは、ルート要素の通常のフローのブロックレベル要素にこれらのプロパティを適用しなければならない。ユーザエージェントはまた、他の要素（たとえば、'table-row'要素）にこれらのプロパティを適用してよい。

  改ページがボックスを分割するとき、ボックスのマージン、ボーダー、パディングは、分割が出現する場所で視覚効果を持たない。

  13.3.2 要素の内側での改ページ: 'orphans'、'widows'

  
    'orphans'

      
        値:  

              <integer> | inherit
            初期値:  

              2
            適用対象:  

              ブロックコンテナ要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual, paged
            算出値:  

              指定値
            
    

  
    'widows'

      
        値:  

              <integer> | inherit
            初期値:  

              2
            適用対象:  

              ブロックコンテナ要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual, paged
            算出値:  

              指定値
            
    

  'orphans'プロパティは、ページの下部に残さなければならないブロックコンテナ内の行の最小数を指定する。'widows'プロパティは、ページの上部に残さなければならないブロックコンテナ内の行の最小数を指定する。これらが改ページを制御するために使用される方法の例を以下に示す。

  正の値のみが許可される。

  段落の整形についての詳細は行ボックスを参照のこと。

  13.3.3 改ページの許可される場所

  通常のフローでは、改ページは以下の場所で出現可能である:

  ブロックレベルボックス間の垂直方向のマージンの中。非強制改ページがここに出現する場合、関連する'margin-top'と'margin-bottom'プロパティの使用値は、'0'に設定される。強制改ページがここに出現する場合、関連する'margin-bottom'プロパティの使用値は'0'に設定される。関連する'margin-top'の使用値は'0'に設定されるか保持されてよい。

    ブロックコンテナボックス内の行ボックスの間。

    （0でない）間隔がある場合、ブロックコンテナボックスの内容辺とその子の内容の外辺（インラインレベルの子のためのブロックレベルの子または行ボックス辺のマージン辺）の間。
  注: 強制改ページの後に関連する'margin-top'を適用する（すなわち、'0'に設定されない）ことを、CSS3は指定することが期待される。

  これらの改ページは、次の規則に従う:

  規則A: （1）で改ページすることは、すべての要素のマージンと接触する生成ボックスの'page-break-after'および'page-break-before'プロパティがそれを許可する場合のみ許可される。ただし、それらの少なくとも一つが、値'always'、'left'、または'right'の場合、またはそれらのすべてが'auto'を持つ場合のいずれかであること。

    規則B: しかし、それらのすべてが'auto'であり、すべての要素の共通の祖先が、'page-break-inside'の値'avoid'を持つ場合、改行は許可されない。

    規則C: 改ページと包囲するブロックボックスの開始の間の行ボックスの数が'orphans'以上の値で、改ページとボックスの終わりとの間の行ボックスの数が'widows'以上の値である場合のみ、（2）の改ページは許可される。

    規則D: 加えて、（2）または（3）で改ページすることは、要素の'page-break-inside'プロパティと、そのすべての祖先が'auto'である場合のみ許可される。
  上記が、あふれるページボックスからの内容を維持するための十分な改ページ位置を提供しない場合、追加の改行位置を見つけるために、規則A、B、Dの順番に破棄する。

  それでも満足する改ページ位置につながらない場合、改行位置を見つけるために、同様に規則Cを破棄する。

  13.3.4 強制改ページ

  このマージンに接触するすべての生成ボックスの'page-break-after'と'page-break-before'プロパティの間で、値'always'、'left'、'right'の少なくとも1つがある場合、（1）で改ページは出現しなければならない。

  13.3.5 最適な改ページ

  CSS 2.1は、どの一連の許可される改ページが使用されなければないらないかを定義しない。CSS 2.1は可能な改ページ位置で改ページするか、まったく改行しないことをユーザーエージェントに禁止しない。ただし、CSS 2.1は、ユーザエージェントが以下の経験則を（これがときどき矛盾していることを認識しつつ）を順守することを推奨する:

  できるだけ少ない回数だけ改ページする。

    強制改ページで終わらないすべてのページは、同程度の高さを持つようにする。

    置換要素の内側に改ページを避ける。
  
    例:

    たとえば、スタイルシートが'orphans: 4'、'widows: 2'を含み、現在のページの下部に使用可能な20行（行ボックス）があると仮定する:

    現在のページの末尾に段落が20行以下が含む場合、現在のページに配置されるべきである。

      段落が21か22行を含む場合、段落の後半は'widows'の制約に違反してはならないので、後半は正確に2行を含まなければならない。

      段落が23行以上が含まれている場合、段落の前半は20行で、後半は残りの行を含めるべきである。
    'orphans'が'10'、'widows'が'20'、現在のページの下部にある使用可能な8行であると仮定する:

    現在のページの末尾に段落が8行以下が含む場合、現在のページに配置すべきである。

      段落が9行以上が含まれている場合、改ページはできない（orphanの制約に違反する）ので、次のページへのブロックとして移動すべきである。
    

  13.4 ページコンテキストにおけるカスケード処理

  ページコンテキスト内の宣言は、通常のCSS宣言と同様にカスケード処理に従う。

  
    例:

    以下の例を考えてみる:
    
@page {
  margin-left: 3cm;
}

@page :left {
  margin-left: 4cm;
}


    擬似クラスセレクタの詳細度の高さのために、左ページの左マージンは'4 cm'となり、他のすべてのページ（つまり、右ページ）は'3 cm'の左マージンを持つ。
  

  14 色と背景

  
    目次

    14.1 前景色: 'color'プロパティ

      
        14.2 背景

        14.2.1 背景のプロパティ: 'background-color'、'background-image'、'background-repeat'、'background-attachment'、'background-position'、'background'
        
    

  CSSプロパティは、著者が前景色と要素の背景を指定可能である。背景は色や画像であってよい。背景のプロパティは、著者が背景画像を配置する、背景を繰り返す、背景がビューポートに対して固定または文書と一緒にスクロールするすべきかどうかを宣言可能である。

  妥当な色の値の構文は色の節を参照のこと。

  14.1 前景色: 'color'プロパティ

  
    'color'

      
        値:  

            <color> | inherit
          初期値:  

            ユーザーエージェントに依存
          適用対象:  

            すべての要素
          継承:  

            yes
          パーセンテージ:  

            利用不可
          メディア:  

            visual
          算出値:  

            指定値
          
    

  このプロパティは、要素のテキスト内容の前景色を表現する。赤を指定するいろいろな方法がある:

  
    例:
    
em { color: red }              /* 定義済み色名 */
em { color: rgb(255,0,0) }     /* RGB範囲0-255   */

  

  14.2 背景

  著者は、色または画像のいずれかとして要素の背景（すなわち、レンダリング表面）を指定してよい。ボックスモデルに関して、"background"は内容、パディング、ボーダー領域の背景を参照する。ボーダーの色とスタイルはボーダーのプロパティで設定される。マージンは常に透明である。

  背景プロパティは継承されないが、親ボックスの背景は、'background-color'の初期値が'transparent'のためデフォルトで透けて見えるだろう。

  ルート要素の背景は、キャンバスの背景となり、全部のキャンバスを覆い、それが唯一のルート要素自体のために描かれた場合にそれがあるのと同じ点で（'background-position'に）固定される。ルート要素は、再びこのような背景を描かない。

  しかし、HTML文書において、著者はHTML要素よりもBODY要素の背景を指定することを推奨する。'background-color'の'transparent'と'background-image'の'none'とを値を計算した、ルート要素がHTMLの"HTML"要素またはXHTMLの"html"の要素である文書に対して、ユーザエージェントは、キャンバスの背景を描いたとき、その要素の最初のHTMLの"BODY"要素またはXHTMLの"body"要素の子からの背景プロパティの算出値の代わりに使用しなければならず、その子要素の背景を描画してはならない。これらがルート要素にのみ塗られた場合、それらのように同じ位置にこのような背景も固定しなければならない。

  
    これらの規則に従って、次のHTML文書の下敷きとなるキャンバスは"marble"の背景を持つ:
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <TITLE>Setting the canvas background</TITLE>
    <STYLE type="text/css">
       BODY { background: url("http://example.com/marble.png") }
    </STYLE>
    <P>My background is marble.


    HTMLパーサが存在しないタグを推論するので、BODY要素の規則は、BODYタグがHTMLソースでは省略されているにもかかわらず動作することに注意する。
  

  スタックコンテキスト（'z-index'プロパティを参照）を形成する要素の背景は、そのスタックコンテキストで何かの下の、要素のスタッキングコンテキストの下部に描かれる。

  14.2.1 背景のプロパティ: 'background-color'、'background-image'、'background-repeat'、'background-attachment'、'background-position'、'background'

  
    'background-color'

      
        値:  

            <color> | transparent | inherit
          初期値:  

            transparent
          適用対象:  

            すべての要素
          継承:  

            no
          パーセンテージ:  

            利用不可
          メディア:  

            visual
          算出値:  

            指定値
          
    

  このプロパティは、要素の背景色を設定する。下敷きになる色が透けて見えるようにするには、<color>値または'transparent'キーワードのいずれかを設定する。

  
    例:
    
h1 { background-color: #F00 }

  

  
    'background-image'

      
        値:  

            <uri> | none | inherit
          初期値:  

            none
          適用対象:  

            すべての要素
          継承:  

            no
          パーセンテージ:  

            利用不可
          メディア:  

            visual
          算出値:  

            絶対URIまたはnone
          
    

  このプロパティは要素の背景画像を設定する。背景画像を設定する場合、著者は画像が使用できない場合に使用される背景色を指定すべきである。画像が使用可能である場合、背景色の上にレンダリングされる。（したがって、色は画像の透明部分で表示される）。

  このプロパティの値は、画像を指定する<uri>、または画像が使用されない'none'のいずれかである。

  
    例:
    
body { background-image: url("marble.png") }
p { background-image: none }

  

  パーセンテージとして表される固有の寸法は、'background-position'プロパティの座標系を設置し、矩形の大きさに対して相対的に解決されなければならない。

  画像が固有幅または高さと固有比のいずれか一方を持つ場合、不足している次元が与えられた寸法との比から計算される。

  画像が固有幅または固有高さのいずれか一方を持ち、固有アスペクト比を持たない場合、不足している寸法は'background-position'プロパティの座標系を設置し、矩形の大きさであると見なされる。

  画像が固有の寸法を持たず、固有比を持つ場合、寸法は'background-position'プロパティの座標系を設置する矩形のどちらの寸法を超えないような比率で最大の寸法であると仮定しなければならない。

  画像が固有比を持たない場合、寸法は'background-position'プロパティの座標系を設置し、矩形であると仮定しなければならない。

  
    'background-repeat'

      
        値:  

            repeat | repeat-x | repeat-y | no-repeat | inherit
          初期値:  

            repeat
          適用対象:  

            すべての要素
          継承:  

            no
          パーセンテージ:  

            利用不可
          メディア:  

            visual
          算出値:  

            指定値
          
    

  背景画像が指定される場合、このプロパティは画像が繰り返されるかどうか（タイル状）、そしてどのように繰り返すかを指定する。すべてのタイルは、ボックスの内容、パディングとボーダー領域を覆う。

  インライン要素の背景画像の敷き詰めと配置は、本仕様で未定義である。将来のCSSレベルは、インライン要素に背景画像の敷き詰めと配置を定義するかもしれない。

  値の意味は次のとおり:

  repeat

    画像は水平方向と垂直方向の両方に繰り返される。

    repeat-x

    画像は水平方向にのみ繰り返される。

    repeat-y

    画像は垂直方向にのみ繰り返される。

    no-repeat

    画像は繰り返されない: 1つのみの画像のコピーが描画される。
  
    例:
    
body { 
  background: white url("pendant.png");
  background-repeat: repeat-y;
  background-position: center;
}


    
         [説明]

      背景画像を中央に1枚置き、その上下に同じ画像を敷き詰めて縦帯を形成している
    
  

  
    'background-attachment'

      
        値:  

            scroll | fixed | inherit
          初期値:  

            scroll
          適用対象:  

            すべての要素
          継承:  

            no
          パーセンテージ:  

            利用不可
          メディア:  

            visual
          算出値:  

            指定値
          
    

  背景画像が指定される場合、このプロパティは、ビューポートに関して固定される（'fixed'）、または包含ブロックとともにスクロールする（'fixed'）かどうかを指定する。

  ビューごとに1つのビューポートがあることに注意する。要素がスクロール機構（'overflow'を参照）を持つ場合、'fixed'の背景要素は要素とともに移動せず、'scroll'背景はスクロール機構とともに移動しない。

  たとえ画像が固定されている場合でも、要素の内容、パディングまたはボーダー領域にある場合にのみ表示される。したがって、画像がタイル状の場合（'background-repeat: repeat'）を除き、画像は不可視であってよい。

  ビューポートがないページメディアでは、'fixed'の背景はページボックスに対して固定されているため、ページごとに複製される。

  
    例:

    この例では、要素がスクロールされているビューポートに"接着"のまま無限の縦帯を作成する。
    
body { 
  background: red url("pendant.png");
  background-repeat: repeat-y;
  background-attachment: fixed;
}

  

  'fixed'の背景をサポートしない（たとえばハードウェアプラットフォームの制限に起因するなど）ユーザエージェントは、キーワード'fixed'と宣言を無視すべきである。たとえば:
  
body {
  background: white url(paper.png) scroll; /* すべてのユーザーエージェント */
  background: white url(ledger.png) fixed; /* 固定背景にするユーザーエージェント */
}


  詳細は適合性の節を参照のこと。

  
    'background-position'

      
        値:  

            [ [ <percentage> | <length> | left | center | right ] [ <percentage> | <length> | top | center | bottom ]? ] | [ [ left | center | right ] || [ top | center | bottom ] ] | inherit
          初期値:  

            0% 0%
          適用対象:  

            すべての要素
          継承:  

            no
          パーセンテージ:  

            ボックス自身の大きさを参照
          メディア:  

            visual
          算出値:  

            <length>は絶対値、そうでなければパーセンテージ
          
    

  背景画像が指定されている場合、このプロパティはその背景画像の初期位置を指定する。1つの値だけが指定される場合、2番目の値は'center'を仮定する。少なくとも1つの値がキーワードでない場合は、最初の値は水平方向の位置を表し、2番目は垂直位置を表す。負の<percentage>と<length>値は許可される。

  <percentage>

    あるパーセンテージXは、位置X%横（水平）または下に（垂直方向）要素のパディングボックスとともに、位置X%横（水平）または下に（垂直）画像の位置を調整する。たとえば、'0% 0%'の値のペアで、画像の左上角はパディングボックスの左上角に揃えて配置される。'100%100%'の値のペアは、パディングボックスの右下隅に画像の右下隅を配置する。'14% 84%'の値のペアは、画像の左から14%上から84%の点と、ボックスのパディング領域の左から14%上から84%の点を揃える。

    <length>

    長さLは、画像の左上隅を要素のパディングボックスの左上隅から距離L右（水平）または下（垂直）の位置に調整する。たとえば、'2cm 1cm'の値のペアで、画像の左上隅から右に2cm、パディングボックスの左上隅から下に1cmに配置される。

    top

    垂直位置'0%'に等しい。

    right

    水平位置'100%'に等しい。

    bottom

    垂直位置'100%'に等しい。

    left

    水平位置'0%'に等しい。

    center

    他の方法で与えられない場合は水平位置の'50%'に等しく、または垂直位置の'50%'に等しい。
  しかし、画像が固有の大きさでなく固有の比率を持つ場合、位置はCSS 2.1で未定義である。

  
    例:
    
body { background: url("banner.jpeg") right top }    /* 100%   0% */
body { background: url("banner.jpeg") top center }   /*  50%   0% */
body { background: url("banner.jpeg") center }       /*  50%  50% */
body { background: url("banner.jpeg") bottom }       /*  50% 100% */

  

  インライン要素の背景画像の敷き詰めと配置は、本仕様で未定義である。将来のCSSレベルは、インライン要素に背景画像の敷き詰めと配置を定義するかもしれない。

  背景画像がビューポート（'background-attachment'を参照）内に固定される場合、画像は要素のパディングボックスの代わりにビューポートに対して配置される。たとえば、

  
    例:
    
body { 
  background-image: url("logo.png");
  background-attachment: fixed;
  background-position: 100% 100%;
  background-repeat: no-repeat;
} 


    上記の例では、（単一の）イメージがビューポートの右下隅に配置される。
  

  
    'background'

      
        値:  

            [<'background-color'> || <'background-image'> || <'background-repeat'> || <'background-attachment'> || <'background-position'>] | inherit
          初期値:  

            個々のプロパティを参照
          適用対象:  

            すべての要素
          継承:  

            no
          パーセンテージ:  

            allowed on 'background-position'
          メディア:  

            visual
          算出値:  

            個々のプロパティを参照
          
    

  'background'プロパティは、スタイルシートの同じ場所で個別の背景のプロパティ（すなわち、'background-color'、'background-image'、'background-repeat'、'background-attachment'、'background-position'）を設定するための簡略化プロパティである。

  妥当な宣言と仮定すると、'background'プロパティは、まず初期値にすべての個別の背景のプロパティを設定し、宣言で指定された明示的な値を割り当てる。

  
    例:

    以下の例の最初の規則では、'background-color'の値のみが与えられ、他の個別のプロパティは初期値に設定される。2番目の規則で、すべての個別のプロパティが指定されている。
    
BODY { background: red }
P { background: url("chess.png") gray 50% repeat fixed }

  

  15 フォント

  
    目次

    15.1 概論

      15.2 フォントのマッチングアルゴリズム

      
        15.3 フォントファミリ: 'font-family'プロパティ

        
            15.3.1 総称フォントファミリ

            15.3.1.1 serif

              15.3.1.2 sans-serif

              15.3.1.3 cursive

              15.3.1.4 fantasy

              15.3.1.5 monospace
            
        

      15.4 フォントスタイル: 'font-style'プロパティ

      15.5 スモールキャップ: 'font-variant'プロパティ

      15.6 フォントの太さ: 'font-weight'プロパティ

      15.7 フォントの大きさ: 'font-size'プロパティ

      15.8 フォントの簡略プロパティ: 'font'プロパティ
    

  15.1 概論

  フォントプロパティの設定は、スタイルシートの最も一般的な用途の中の1つである。残念ながら、フォントを分類するための明確に定義された普遍的に受け入れる分類は存在せず、1つのフォントファミリに適用される条件は、他のフォントファミリに適切でないかもしれない。たとえば、'itaric'は一般に傾斜したテキストを分類するために使用されるが、傾斜したテキストは、Oblique、Slanted、Incline、Cursive、Kursivと名付けられてよい。したがって、特定のフォントに標準的なフォント選択プロパティを配置することは単純な問題ではない。

  15.2 フォントのマッチングアルゴリズム

  フォントプロパティの普遍的な分類で一般に認められたものはないので、フォント書体へのプロパティの一致は慎重に行わなければならない。プロパティは、このマッチング処理の結果がユーザーエージェントを横断してできるだけ一貫していることを保証するために十分に定義された順序で照合される（フォント書体の同じライブラリがそれらの各々に提示されると仮定する）。

  ユーザエージェントは、認識するすべてのフォントの関連CSS 2.1のプロパティのデータベースを作成する（またはアクセスする）。2つのフォントがまったく同じ特性を持つ場合、ユーザエージェントはフォントの1つを選択する。

    与えられた要素で、その要素内の各文字に対して、ユーザーエージェントはその要素に適用されるフォントのプロパティを翻訳する。プロパティの完全なセットを使用して、ユーザーエージェントは仮のフォントファミリを選択するために'font-family'プロパティを使用する。残りのプロパティは、各プロパティで記述マッチングの基準に従ってそのフォントファミリに対して検証される。残りのすべてのプロパティの一致がある場合、その特定の要素または文字に一致するフォントとなる。

    ステップ2によって処理される'font-family'内に一致するフォント書体が存在せず、フォントセット内の次の選択肢の'font-family'がある場合は、次の代替'font-family'とともにステップ2を繰り返す。

    マッチングフォント書体があるが、フォントは現在の文字のグリフを含んでおらず、フォントセットの次の選択肢の'font-family'がある場合、次の代替'font-family'とともにステップ2を繰り返す。

    2で選択したファミリ内にフォントが存在しない場合、ユーザーエージェント依存のデフォルトの'font-family'を使用し、手順2を繰り返し、デフォルトのフォントの中で得ることができる最良の一致を使用する。特定の文字がこのフォントを用いて表示できない場合、ユーザーエージェントはその文字に適したフォントを決定するために他の手段を使用してよい。ユーザーエージェントは、選択した可視シンボルへの適切なフォントを持たない各文字をマップをすべきである。その文字はユーザーエージェントに利用可能なフォント書体のいずれかからできれば"欠落文字"のグリフである。
  （上記のアルゴリズムは、各文字のCSS 2.1プロパティを再考することを避けるために最適化することが可能である。）

  上記の（2）から、プロパティごとの一致規則は次のとおり:

  'font-style'を最初に試みる。CSSキーワード'italic'（推奨）または'oblique'に分類されたユーザーエージェントのフォントデータベース内の書体でどちらかがあれば、'Italic'が満たされる。そうでなければ、値は正確に一致しなければならないか、font-styleは失敗する。

    'font-variant'を次に試みる。'small-caps'は、（1）'small-caps'と分類されたフォント、（2）スモールキャップが合成されたフォント、（3）すべての小文字が大文字に置き換えられたフォント、と一致する。スモールキャップフォントは通常のフォントからコンピュータ上でスケーリングした大文字で合成してよい。'normal'は通常の（非スモールキャップの）変体が一致する。フォントは、通常の変体を持つために失敗するはずはない。唯一のスモールキャップとして使用可能なフォントは、'normal'書体または'small-caps'書体のいずれかとして選択されなければならない。

    'font-weight'は次で一致され、決して失敗することはない。（'font-weight'は下記を参照のこと。）

    'font-size'は、許容範囲のユーザーエージェント依存なマージン内で一致されなければならない。（通常、ビットマップフォントの許容範囲は20%だが、スケーラブルフォントのサイズは最も近い整数ピクセルに丸められる。）たとえば、他のプロパティで'em'の値によっての追加的な計算は、'font-size'の算出値に基づく。
  15.3 フォントファミリ: 'font-family'プロパティ

  
    'font-family'

      
        値:  

              [[ <family-name> | <generic-family> ] [, <family-name>| <generic-family>]* ] | inherit
            初期値:  

              ユーザーエージェントに依存
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  プロパティ値は、フォントファミリ名と総称ファミリ名の両方またはいずれか一方の優先順位のリストである。
  
body { font-family: Gill, Helvetica, sans-serif }


  多くのフォントは"欠落文字"のグリフ、典型的には四角を提供するが、その名前が示すように、これはフォントの見つからない文字に一致すると考えるべきではない。（しかし、これは、"欠落文字"の文字コードポイントU+FFFDに一致すると見なされるべきである）。

  フォントファミリ名には2種類ある:

  <family-name>

    最適なフォントファミリの名称。上記の例では、"Gill"と"Helvetica"はフォントファミリである。

    <generic-family>

    
      上記の例では、最後の値は総称ファミリ名である。以下の総称ファミリが定義されている:

      'serif'（たとえば、Times）

        'sans-serif'（たとえば、 Helvetica）

        'cursive'（たとえば、Zapf-Chancery）

        'fantasy'（たとえば、Western）

        'monospace'（たとえば、Courier）
      スタイルシートの設計者は、最後の代替手段として総称フォントファミリを提示することが奨励される。総称フォントファミリ名はキーワードであり、引用符で囲んではならない。
    
  フォントファミリ名は、文字列として与えられ引用符で囲まれる、または1つ以上の識別子のシーケンスとして引用符なしのいずれかでなければならない。これは、各トークンの開始時にほとんどの句読点と数字が、引用符なしのフォントファミリ名にエスケープされなければならないことを意味する。

  たとえば、以下の宣言は妥当でない:
  
font-family: Red/Black, sans-serif;
font-family: "Lucida" Grande, sans-serif;
font-family: Ahem!, sans-serif;
font-family: test@foo, sans-serif;
font-family: #POUND, sans-serif;
font-family: Hawaii 5-0, sans-serif;


  識別子のシーケンスがフォントファミリ名として指定される場合、算出値は単一のスペースによりシーケンス内のすべての識別子を結合することによって文字列に変換される名前となる。

  エスケープのミスを避けるために、空白、数字、またはハイフン以外の句読点を含むフォントファミリの名前を引用符で囲むことを推奨する。
  
body { font-family: "New Century Schoolbook", serif }

<BODY STYLE="font-family: '21st Century', fantasy">


  キーワード値（'inherit'、'serif'、'sans-serif'、'monospace'、'fantasy'、'cursive'）と偶然同じになるフォントファミリ名はキーワードとの混乱を防ぐために、引用符で囲まなければならない。キーワード'initial'と'default'は、将来の使用のために予約されており、フォント名として使用する場合も引用符で囲まなければならない。ユーザーエージェントは、'<family-name>'型に一致するものとしてこれらのキーワードを考慮してはならない。

  15.3.1 総称フォントファミリ

  総称フォントファミリは、フォールバックメカニズムである。これは指定したフォントのいずれも選択することはできないという最悪の場合において、スタイルシートの作成者の意図の一部を維持するための手段である。最適な印刷制御のために、特定の名前付きのフォントはスタイルシートで使用すべきである。

  すべての5つの汎用フォントファミリは、すべてのCSSの実装内に存在するように定義される（5つの異なる実際のフォントには必ずしも対応させる必要はない）。 ユーザーエージェントは、各ファミリの特性だけでなく、可能な限り基本的な技術で許される限度内で表現する総称フォントファミリのために合理的なデフォルトの選択肢を提供すべきである。

  ユーザエージェントは、ユーザーが総称フォントの代替選択肢を選択できるようにすることを奨励する。

  15.3.1.1 serif

  CSSで使用される用語serif（セリフ）フォントのグリフは、ストローク仕上げている、フレア、または先細り端を持つ傾向にある、または実際にセリフ先端を持つ（スラブセリフを含む）。serifフォントは一般的にはプロポーショナルフォントである。serifフォントしばしば'sans-serif'総称フォントファミリが提供するフォントよりも線の太さに大きな違いを表す。Mincho（日本語）、SungまたはSong（中国語）、TotumまたはKodig（韓国語）などの特定のスクリプト名がより身近かもしれないが、CSSは任意のスクリプトフォントに適用する用語'serif'を使用する。このように説明される任意のフォントは、一般的な'serif'ファミリを表すために使用されてもよい。

  この記述に適合するフォントの例は次のとおり:

  ラテン語フォント

        Times New Roman, Bodoni, Garamond, Minion Web, ITC Stone Serif, MS Georgia, Bitstream Cyberbit
      ギリシャ語フォント

        Bitstream Cyberbit
      キリル文字フォント

        Adobe Minion Cyrillic, Excelsior Cyrillic Upright, Monotype Albion 70, Bitstream Cyberbit, ER Bukinist
      ヘブライ語フォント

        New Peninim, Raanana, Bitstream Cyberbit
      日本語フォント

        Ryumin Light-KL, Kyokasho ICA, Futo Min A101
      アラビア語フォント

        Bitstream Cyberbit
      チェロキー語フォント

        Lo Cicero Cherokee
      15.3.1.2 sans-serif

  CSSで使用される用語sans-serif（サンセリフ）フォントのグリフはプレーンなストローク端を持つ傾向がある。ほとんどフレア、クロスストローク、他の装飾はない。sans-serifフォントは一般的にはプロポーショナルフォントである。sans-serifフォントはしばしば'serif'ファミリの提供するフォントに比べて、線の太さの変化はほとんどない。Gothic（日本語）、Kai（中国語）、またはPathang（韓国語）などの特定のスクリプト名がより身近かもしれないが、CSS は任意のスクリプトフォントに適用する用語'sans-serif'を使用する。このように説明される任意のフォントは、一般的な'sans-serif'ファミリを表すために使用されてよい。

  この記述に適合するフォントの例は次のとおり:

  ラテン語フォント

        MS Trebuchet, ITC Avant Garde Gothic, MS Arial, MS Verdana, Univers, Futura, ITC Stone Sans, Gill Sans, Akzidenz Grotesk, Helvetica
      ギリシャ語フォント

        Attika, Typiko New Era, MS Tahoma, Monotype Gill Sans 571, Helvetica Greek
      キリル文字フォント

        Helvetica Cyrillic, ER Univers, Lucida Sans Unicode, Bastion
      ヘブライ語フォント

        Arial Hebrew, MS Tahoma
      日本語フォント

        Shin Go, Heisei Kaku Gothic W5
      アラビア語フォント

        MS Tahoma
      15.3.1.3 cursive

  CSSで使用される用語cursive（カーシヴ）フォントのグリフは、一般的にイタリック体の書体を超えてストローク接合または他の筆記体の特性のいずれかを持つ。グリフは部分的または完全に接続され、その結果多くの印刷されたletterworkよりも手書きのペンや毛筆のように見える。アラビア語など、いくつかのスクリプト用のフォントは、ほとんどがcursiveである。Chancery、Brush、Swing、Scriptなどの他の名前もフォント名に使用されるが、CSSは任意のスクリプトのフォントに適用する用語'cursive'を使用する。

  この記述に適合するフォントの例は次のとおり:

  ラテン語フォント

        Caflisch Script, Adobe Poetica, Sanvito, Ex Ponto, Snell Roundhand, Zapf-Chancery
      キリル文字フォント

        ER Architekt
      ヘブライ語フォント

        Corsiva
      アラビア語フォント

        DecoType Naskh, Monotype Urdu 507
      15.3.1.4 fantasy

  CSSで使用されるFantasyフォントは、文字の表現を含むようにしながら、主に装飾的である（文字を表すものでない、パイフォントまたはピクチャフォントとは対照的）。例を以下に示す:

  ラテン語フォント

        Alpha Geometrique, Critter, Cottonwood, FB Reactor, Studz
      15.3.1.5 monospace

  monospaceフォントの唯一の基準は、すべてのグリフが同じ固定幅を持つことである。（これは、アラビア語などのいくつかのスクリプトをこの上なく奇妙に見えるようにすることになる。）その効果は手動タイプライターに似ており、多くの場合コンピュータコードのサンプルを設定するために使用される。

  この記述に適合するフォントの例は次のとおり:

  ラテン語フォント

        Courier, MS Courier New, Prestige, Everson Mono
      ギリシャ語フォント

        MS Courier New, Everson Mono
      キリル文字フォント

        ER Kurier, Everson Mono
      日本語フォント

        Osaka Monospaced
      チェロキー語フォント

        Everson Mono
      15.4 フォントスタイル: 'font-style'プロパティ

  
    'font-style'

      
        値:  

              normal | italic | oblique | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  'font-style'プロパティは、フォントファミリの通常体（"roman"や"upright"とも呼ばれる）、イタリック体、オブリーク体の書体から選択する。

  'oblique'は'oblique'と分類されるフォントを選択する一方、'normal'の値は、ユーザーエージェントのフォントデータベースで'normal'として分類されるフォントを選択する。'italic'の値は'italic'と分類された、または'italic'が利用できない場合は、'oblique'と分類されたフォントを選択する。

  ユーザーエージェントのフォントデータベースで'oblique'と分類されたフォントは、実際にはコンピュータ上で通常のフォントを斜めにして生成したものであってよい。

  一般的に、Oblique、Slanted、Inclineの名前を持つフォントは、ユーザーエージェントのフォントデータベースで'oblique'と分類される。一般的に、Italic、Cursive、Kursivの名前を持つフォントは、'italic'と分類される。
  
h1, h2, h3 { font-style: italic }
h1 em { font-style: normal }


  上記の例では、'H1'内の強調テキストは、通常の書体として表示される。

  15.5 スモールキャップ: 'font-variant'プロパティ

  
    'font-variant'

      
        値:  

              normal | small-caps | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  フォントファミリ内の変異のもう一つの種類は、スモールキャップである。スモールキャップフォントでの小文字は大文字に似ているが、わずかに異なる縦横比を持つ。'font-variant'プロパティは、そのフォントを選択する。

  'normal'の値は、スモールキャップフォントでないフォントを選択し、'small-caps'は、スモールキャップフォントを選択する。スモールキャップフォントは通常のフォントを取得し、スケーリングされた大文字で小文字に置き換えることによって作成された場合、CSS 2.1で仕様を満たす（要求はされない）。最後の手段として、大文字がスモールキャップフォントの代替として使用される。

  以下の例は、強調を斜体で、'H3'要素をスモールキャップで、'H3'要素の強調をスモールキャップと斜体で表す:
  
h3 { font-variant: small-caps }
em { font-style: oblique }


  古いスタイルの数字、スモールキャップの数字、縮小や拡大された文字などのフォントのような、フォントファミリの別の亜種があってもよい。CSS 2.1はそれらを選択するプロパティを持たない。

  注: このプロパティがテキストを大文字に変換をもたらす場合、'text-transform'が適用される場合と同じ結果となる。

  15.6 フォントの太さ: 'font-weight'プロパティ

  
    'font-weight'

      
        値:  

              normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              テキスト参照
            
    

  'font-weight'プロパティは、フォントの太さを選択する。'100'から'900'までの値は、各数値が少なくとも濃さのウェイトを指示する順番に並べたものである。キーワード'normal'は'400'と同義であり、'bold'は'700'と同義である。'normal'と'bold'以外のキーワードは、フォント名と数値尺度とがしばしば混同されることが示され、したがって9つの値リストが選ばれた。
  
p { font-weight: normal }   /* 400 */
h1 { font-weight: 700 }     /* bold */


  'bolder'および'lighter'値は、親から継承されたウェイトを基準にしてフォントの太さを選択する:
  
strong { font-weight: bolder }


  フォント（フォントデータ）は、通常、フォントの"weight"の記述をもつ名前が値である、1つ以上のプロパティを持つ。これらのウェイトの名前に容認された普遍的な意味は存在しない。これらの主な役割は、単一のフォントファミリ内の濃さの異なる書体を区別することである。フォントファミリにわたって慣用法は非常に異なる。たとえば、太字であると考えられるフォントは、フォントの"normal"書体がデザインでどの程度黒いかによって決まり、Regular、Roman、Book、Medium、Semi-、DemiBold、Bold、Blackとして表されるかもしれない。名前の標準的な使用法がないため、CSS 2.1のウェイトプロパティの値は、値'400'（または'normal'）がそのファミリに'normal'テキスト書体に相当する数値のスケールで与えられる。通常、その書体に関連付けられたウェイト名は、Book、Regular、Roman、Normal、Mediumとなる。

  数値のウェイト値へのファミリ内の他のウェイトの関連は、そのファミリ内の濃さの順序を維持するためのみに意図される。ただし、以下の経験則は、この場合の割り当てをどのように行うかを伝える。

  フォントファミリがすでに9つの値で数値スケールを使用している（たとえば、OpenType がそうしている）場合、フォントのウェイトを直接マッピングすべきである。

    Medium分類される書体およびBook、Regular、Romanに分類されるものが1つまたはNormalの両方がある場合、Mediumは通常'500'に割り当てられる。

    "Bold"と分類されるフォントは、多くの場合、ウェイト値が'700'に対応する。
  フォントファミリのウェイトは、CSSのスケールにマッピングされると、不足したウェイトは次のように選択される。

  所望のウェイトが400未満である場合、所望のウェイト以下のウェイトが一致するものが見つかるまで、昇順で所望のウェイトを上記のウェイトに続いて降順にチェックされる。

    所望のウェイトが500より大きい場合、一致するものが見つかるまで、所望のウェイト以上のウェイトは、降順で所望のウェイト以下のウェイトに続いて昇順にチェックされる。

    所望のウェイトが400であれば、500は最初にチェックされ、目的のウェイトのための規則は、400未満が使用される。

    所望のウェイトが500であれば、400が最初にチェックされ、目的のウェイトのための規則は、400未満が使用される。
  次の2つの例は、典型的なマッピングを示している。

  
    "Rattlesnake"ファミリで、薄いものから濃いものへ4つのウェイトを想定: Regular、Medium、Bold、Heavy。

    
        フォントウェイトのマッピング例(1)
      

      利用可能な書体

          割り当て

          空きの埋め方
        "Rattlesnake Regular"

          400

          100, 200, 300
        "Rattlesnake Medium"

          500

           
        "Rattlesnake Bold"

          700

          600
        "Rattlesnake Heavy"

          800

          900
        

  
    "Ice Prawn"ファミリで6つのウェイトを仮定する: Book、Medium、Bold、Heavy、Black、ExtraBlack. この場合、ユーザーエージェントは"Ice Prawn ExtraBlack"に数値の割り当てを決めないことに注意する。

    
        フォントウェイトのマッピング例(2)
      

      利用可能な書体

          割り当て

          空きの埋め方
        "Ice Prawn Book"

          400

          100, 200, 300
        "Ice Prawn Medium"

          500

           
        "Ice Prawn Bold"

          700

          600
        "Ice Prawn Heavy"

          800

           
        "Ice Prawn Black"

          900

           
        "Ice Prawn ExtraBlack"

          (none)

           
        

  'bolder'と'lighter'値は親要素のウェイトに対する相対値を示す。継承されたウェイト値に基づいて、使用するウェイトは下記のテーブルを使用して計算される。子要素は計算されたウェイトではなく、'bolder'または'lighter'の値を継承する。

  
      'bolder'と'lighter'の意味
    

    継承値

        bolder

        lighter
      100

        400

        100
      200

        400

        100
      300

        400

        100
      400

        700

        100
      500

        700

        100
      600

        900

        400
      700

        900

        400
      800

        900

        700
      900

        900

        700
      上記の表は　薄い書体と濃い書体とともにnormalとbold書体を含むフォントファミリを指定し、次の相対的なbolderまたはlighter書体を選択することと同じである。与えられた要素に使用される正確なウェイト値をより細かく制御を希望する著者は、相対的なウェイトの数値を使用すべきである。

  'font-weight'値のそれぞれにより重いウェイトがあることを保証するものではない。たとえば、一部のフォントはnormalとbold書体のみを持つ一方、8つの書体のウェイトを持つものもある。ユーザーエージェントがウェイトの値にファミリ内のフォント書体にどのようにマッピングするかを保証しない。唯一の保証は与えられた値の書体が、より薄い書体よりも小さいウェイトを持たないことである。

  15.7 フォントの大きさ: 'font-size'プロパティ

  
    'font-size'

      
        値:  

              <absolute-size> | <relative-size> | <length> | <percentage> | inherit
            初期値:  

              medium
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              継承されたフォントサイズを参照
            メディア:  

              visual
            算出値:  

              絶対値
            
    

  フォントサイズは、活版印刷で使用されているem正方形の概念に相当する。特定のグリフがem正方形の外側にあふれることに注意する。値の意味は次のとおり:

  <absolute-size>

    
      <absolute-size>キーワードは、ユーザーエージェントによって計算・保持されるフォントサイズテーブルへのインデックスである。可能な値は以下の通り:

      [ xx-small | x-small | small | medium | large | x-large | xx-large ]

      次の表は、HTMLの見出しと絶対フォントサイズのマッピングのためのユーザーエージェントのガイドラインを提供する。'medium'値は、ユーザの推奨フォントサイズであり、基準の中間値として使用される。

      CSS絶対サイズ値

            xx-small

            x-small

            small

            medium

            large

            x-large

            xx-large

             
          HTMLフォントサイズ

            1

             

            2

            3

            4

            5

            6

            7
          実装者は、'medium'フォントサイズ、特定のデバイスとその特性（例えば、デバイスの解像度）からの相対パス、絶対サイズのキーワードのスケーリング係数のテーブルを構築すべきである。

      異なるメディアは異なるスケーリング係数を必要としてよい。また、テーブルを計算するときにも、ユーザーエージェントはフォントの品質と可用性を考慮に入れるべきである。テーブルは、フォントファミリごとに異なってもよい。

      注1。 読みやすさの維持のために、このガイドラインを適用するユーザーエージェントは、それでもなお、コンピュータのディスプレイ上にem単位で9px未満の結果となるfont-sizeの作成を避けるべきである。

      注2。 CSS1では、隣接するインデックス間の推奨スケーリング係数は1.5であったが、ユーザーエクスペリエンスから大きすぎることが判明した。CSS2では、隣接したインデックスの間のコンピュータの画面のために提案されたスケーリング係数は1.2であったが、まだ小さいサイズの問題を作成している。実装の経験は、隣接する絶対的なサイズのキーワードの間に固定比率が問題であることを実証しており、本仕様はそのような固定比率を推奨しない。
    

    <relative-size>

    <relative-size>キーワードは、フォントサイズや親要素のフォントサイズのテーブルに対して相対的に解釈される。可能な値は次のとおり: [ larger | smaller ]たとえば、親要素が'medium'のフォントサイズを持つ場合、'larger'の値は現在の要素のフォントサイズを'large'にする。親要素のサイズがテーブルのエントリに近くない場合、ユーザーエージェントはテーブルのエントリとの間を補間する、または最も近いものに丸めるのも自由である。数値がキーワードを超えた場合、ユーザーエージェントはテーブル値を推定してよい。
  要素のフォントサイズを計算する場合、長さとパーセンテージの値はフォントサイズ表を考慮すべきではない。

  負の値は許可されない。

  他のすべてのプロパティで、'em'と'ex'長さの値は、現在の要素の計算されたフォントサイズを参照する。'font-size'プロパティでは、これらの長さの単位は親要素の計算されたフォントサイズを参照する。

  アプリケーションは、コンテキストに応じて明示的なサイズを再解釈することに注意する。たとえば、VRシーン内でのフォントための射影歪みの異なるサイズを得ることができる。

  例:
  
p { font-size: 16px; }
@media print {
   p { font-size: 12pt; }
}
blockquote { font-size: larger }
em { font-size: 150% }
em { font-size: 1.5em }


  15.8 フォントの簡略プロパティ: 'font'プロパティ

  
    'font'

      
        値:  

              [ [ <'font-style'> || <'font-variant'> || <'font-weight'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              個々のプロパティを参照
            メディア:  

              visual
            算出値:  

              個々のプロパティを参照
            
    

  'font'プロパティは、下記の場合を除き、'font-style'、'font-variant'、'font-weight'、'font-size'、'line-height'、'font-family'をスタイルシートの同じ場所で設定する簡略プロパティである。このプロパティの構文は、フォントに関連する複数のプロパティを設定する伝統的な活版印刷の簡略表記法に基づくものである。

  すべてのフォント関連のプロパティは、最初に前項に掲げるものを含む彼らの初期値にリセットされる。次に、'font'簡略記法で明示的な値を与えられているプロパティは、その値に設定される。許可される値と初期値の定義については、以前に定義されたプロパティを参照のこと。
  
p { font: 12px/14px sans-serif }
p { font: 80% sans-serif }
p { font: x-large/110% "New Century Schoolbook", serif }
p { font: bold italic large Palatino, serif }
p { font: normal small-caps 120%/120% fantasy }


  2番目の規則で、フォントサイズのパーセント値（'80%'）は親要素のフォントサイズを参照する。3番目の規則で、行の高さのパーセンテージは、要素自体のフォントサイズを参照する。

  最初の3つの規則では、'font-style'、'font-variant'、'font-weight'が明示的に言及されず、これらは初期値（'normal'）が3つすべてに設定されることを意味する。4番目の規則は、'font-weight'を'bold'、'font-style'を'italic'に設定し、暗黙的に'font-variant'を'normal'に設定する。

  5番目の規則は、'font-variant'（'small-caps'）、'font-size'（親のフォントの120%）、'line-height'（フォントサイズの120%）、'font-family'（'fantasy'）に設定する。残りの2つのプロパティ'font-style'と'font-weight'に、キーワード'normal'が適用される。

  次の値は、システムフォントを参照する:

  caption

    キャプションのコントロールに使用されるフォント（たとえば、ボタン、ドロップダウンなど）。

    icon

    アイコンの表示に使用されるフォント。

    menu

    メニューに使用されるフォント（たとえば、ドロップダウンメニューやメニューリスト）。

    message-box

    ダイアログボックスに用いるフォント

    small-caption

    小さなコントロールの表示に使用するフォント

    status-bar

    ステータスバーに用いるフォント
  システムフォントのみが、まとめて設定されてもよい。フォントファミリ、サイズ、ウェイト、スタイルなどは、同時にすべて設定される。必要に応じて、これらの値は個別に変更してよい。指定された特性を持つフォントが指定されたプラットフォーム上に存在しない場合、ユーザエージェントは、インテリジェントな代替（たとえば、'caption'フォントの小型版は'small-caption'フォントに使用されるかもしれない）、またはユーザエージェントのデフォルトフォントのいずれかに置き換えるべきである。システムフォントの個々のプロパティのいずれかがオペレーティングシステムの使用可能なユーザー設定の一部ではない場合、正常ななフォントとして、それらのプロパティは初期値に設定されるべきである。

  このプロパティが"ほぼ"簡略化プロパティであるその理由は: システムフォントは'font-family'自体でなく、このプロパティのみで指定可能であるので、'font'は著者が、そのサブプロパティ以上の操作を行うことができるためである。しかし、'font-weight'などのような個々のプロパティは、まだシステムフォントから取得した値を独立して変化させることができる。

  
    例:
    
button { font: 300 italic 1.3em/1.7em "FB Armada", sans-serif }
button p { font: menu }
button p em { font-weight: bolder }


    特定のシステム上のドロップダウンメニューに使用するフォントが、たとえば、9ptのCharcoalで600ウェイトの場合、あたかもこの規則が有効であったかのようにBUTTONの子孫のP要素は表示される:
    
button p { font: 600 9px Charcoal }


    'font'簡略プロパティは、明示的に初期値に値を与えられていないプロパティをリセットするので、これは以下の宣言と同じ効果がある。
    
button p {
  font-family: Charcoal;
  font-style: normal;
  font-variant: normal;
  font-weight: 600;
  font-size: 9px;
  line-height: normal;
}

  

  16 テキスト

  
    目次

    16.1 インデント: 'text-indent'プロパティ

      16.2 配置: 'text-align'プロパティ

      
        16.3 装飾

        16.3.1 下線、上線、打ち消し線、点滅: 'text-decoration'プロパティ
        

      16.4 文字と単語の間隔: 'letter-spacing'、'word-spacing'プロパティ

      16.5 大文字化: 'text-transform'プロパティ

      
        16.6 空白: 'white-space'プロパティ

        16.6.1 'white-space'処理モデル

          16.6.2 双方向での空白の相殺の例

          16.6.3 制御文字と合成文字の詳細
        
    

  以下の章で定義されるプロパティは、文字、スペース、単語、段落の視覚的な見栄えに影響を与える。

  16.1 インデント: 'text-indent'プロパティ

  
    'text-indent'

      
        値:  

              <length> | <percentage> | inherit
            初期値:  

              0
            適用対象:  

              ブロックコンテナ
            継承:  

              yes
            パーセンテージ:  

              包含ブロックを含む幅を参照
            メディア:  

              visual
            算出値:  

              指定値のパーセンテージまたは絶対長さ
            
    

  このプロパティは、ブロックコンテナ内のテキストの1行目のインデントを指定する。より正確に言えば、このプロパティはブロックの最初の行ボックスに流れ込む最初のボックスのインデントを指定する。ボックスは行ボックスの左辺（右から左へのレイアウトでは右辺）でインデントされる。ユーザエージェントは空白としてこのインデントをレンダリングしなければならない。

  'text-indent'は、要素の最初に整形される行である場合にのみ行に影響を与える。たとえば、それが親要素の最初の子である場合、匿名ブロックボックスの1行目にのみ影響を受ける。

  値の意味は次のとおり:

  <length>

    インデントは固定長さになる。

    <percentage>

    インデントは包含ブロック幅のパーセンテージになる。
  'text-indent'の値は負であってよいが、実装特有の制限があるかもしれない。'text-indent'の値が負であるかまたはブロックの幅を超える場合、上記で説明したその最初のボックスはブロックをあふれてもよい。'overflow'の値はブロックがあふれるそのようなテキストが可視であるかどうかに影響する。

  
    例:

    以下の例は'3em'のテキストインデントが起こる。
    
p { text-indent: 3em }

  

  注: ブロック要素に指定された場合、'text-indent'のプロパティは継承するため、子孫のインラインブロック要素に影響を与える。このため、多くの場合'display:inline-block'に指定された要素で'text-indent: 0'に指定するのが賢明である。

  16.2 配置: 'text-align'プロパティ

  
    'text-align'

      
        値:  

              left | right | center | justify | inherit
            初期値:  

              匿名値は'direction'が'ltr'の場合は'left'として、'direction'が'rtl'の場合は'right'として振る舞う。
            適用対象:  

              ブロックコンテナ
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              初期値または指定値
            
    

  このプロパティは、どのようにブロックコンテナのインラインレベルのコンテンツを配列するかについて表現する。値の意味は次のとおり:

  left, right, center, justify

    インライン整形の節で説明されるようにそれぞれ、左揃え、右揃え、中央揃え、両端揃えにする。
  テキストのブロックは行ボックスの積み重ねである。'left'、'right'、'center'の場合、このプロパティはどのように個々の行ボックス内のインラインレベルボックスが行ボックスの左辺と右辺に関して整列するかを指定する。配置はビューポートに対してではない。'justify'の場合、このプロパティは、可能であればインラインレベルボックスがインラインボックスの内容を拡大または縮小することによって、行ボックスの両側と重なるよう指定する。さもなければ、他の初期値と同様に整列する。（'letter-spacing'と'word-spacing'も参照のこと。）

  要素が'pre'または'pre-wrap'の'white-space'算出値を持つ場合、その要素のテキスト内容のグリフもその空白も行端揃えの目的のために変更することはできない。

  注: 将来的にCSSは、'white-space: pre-wrap'でテキストを行端揃えする方法を追加するかもしれない。

  
    例:

    この例では、'text-align'が継承されるので、'important'のクラス名を持つDIV要素内のすべてのブロックレベル要素は、インラインの内容を中央揃えにすることに注意する。
    
div.important { text-align: center }

  

  
    注。 実際に使用される両端揃えのアルゴリズムは、ユーザエージェントとテキストの言語およびまたはスクリプトに依存する。
  

  適合ユーザエージェントは、要素のデフォルトの書字方向が左から右または右から左かどうかに応じて、それぞれ、'left'または'right'として'justify'を解釈してよい。

  16.3 装飾

  16.3.1 下線、上線、打ち消し線、点滅: 'text-decoration'プロパティ

  
    'text-decoration'

      
        値:  

              none | [ underline || overline || line-through || blink ] | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              なし（文参照）
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、要素の色を用いて要素のテキストに付加する装飾を記述する。インライン要素に指定された、またはインライン要素に伝播する場合、その要素によって生成されるすべてのボックスに影響を与え、さらにインラインを分割するブロックレベルボックスフロー内に任意に伝播される（9.2.1.1節参照）。しかし、CSS2.1で、それは装飾がブロックレベルのテーブルに伝播するかどうかは未定義である。ブロックコンテナがインライン書式コンテキストを設置する場合、装飾は、ブロックコンテナの中のすべてのフロー内のインラインレベルの子を包む匿名インライン要素に伝播される。他のすべての要素に対して、任意のフロー内の子供に伝播される。テキスト装飾が浮動および絶対配置の子孫に伝播せず、そのようなインラインブロックおよびインラインテーブルなどの原子インラインレベル子孫の内容に伝播しないことに注意する。

  下線、上線、取り消し線は、テキスト（空白、文字間隔、単語間隔を含む）にのみ適用され、マージン、ボーダー、パディングは飛ばされる。ユーザエージェントは、テキストでない内容にこれらのテキスト装飾を描画してはならない。たとえば、画像やインラインブロックに下線を引いてはならない。

  
    注。 要素Eが'visibility: hidden'と'text-decoration: underline'の両方を持つ場合、下線は（Eの親のいずれかの装飾が可視であるが）不可視である。しかし、Eの子供で下線が可視または不可視であるかどうかを、CSS 2.1は指定しない:
    
<span style="visibility: hidden; text-decoration: underline">
 <span style="visibility: visible">
  underlined or not? </span>
</span>


    これはCSS level 3で指定されると期待される。
  

  子孫要素の'text-decoration'プロパティは祖先の装飾上の任意の効果を持つことはできない。テキスト装飾線の太さと位置とを決定する際、ユーザエージェントはフォントサイズと子孫の主要なベースラインを考えてもよいが、各行に同じベースラインと太さを使用しなければならない。相対配置の子孫は、子孫のテキストと一緒に影響を与えるすべてのテキスト装飾を移動する。その行の装飾の初期位置の計算に影響しない。

  値の意味は次のとおり:

  none

    テキストの装飾を生成しない。

    underline

    テキストの各行に下線を引く。

    overline

    テキストの各行に上線を引く。

    line-through

    テキストの各行に中央線を引く。

    blink

    テキストを点滅させる（可視と不可視の間で交互に）。適合ユーザーエージェントは単にテキストを点滅させなくてよい。テキストを点滅させないことが、WAI-UAAGのチェックポイント3.3を満たすための1つの手法であることに注意する。
  テキスト装飾に必要な色は'text-decoration'が設定される要素の'color'プロパティ値から算出されなければならない。たとえ子孫要素が異なる'color'値を持つ場合でも、装飾の色は同じままでなければならない。

  一部のユーザエージェントは、上記のように一定の太さと線の位置を維持するのではなく、子孫要素に装飾を伝播することによって、テキストの装飾を実装している。これは間違いなくCSS2においてより緩い表現で許可されていた。SVG1、CSS1のみ、およびCSS2のみのユーザエージェントは、古いモデルを実装してCSS 2.1のこの部分への適合を主張してよい。（これは、本仕様書がリリースされた後に開発されたユーザーエージェントには適用されない。）

  
    例:

    次の例のHTMLでは、（訪問したかどうか）ハイパーリンクとして振る舞うすべてのA要素のテキスト内容に下線が表示される:
    
a:visited,a:link { text-decoration: underline }

  

  
    例:

    次のスタイルシートと文書断片の場合：
    
   blockquote { text-decoration: underline; color: blue; }
   em { display: block; }
   cite { color: fuchsia; }

    
   <blockquote>
    <p>
     <span>
      Help, help!      <em> I am under a hat!</em>
      <cite> —GwieF </cite>
     </span>
    </p>
   </blockquote>


    blockquote要素の下線はspan要素を囲む匿名インライン要素に伝播されて"Help, help!"というテキストを青色にし、その真下の匿名インラインから青色の下線となり、色はblockquote要素から受け継がれている。下線が伝播されるフロー内のブロックのように、emブロックの<em>text</em>も下線が引かれる。テキストの最終行はフクシャだが、その真下の下線はまだ匿名インライン要素が提供する青の下線である。

    

    この図は上記の例で複雑なボックスを示す。丸みを帯びたアクアの線は、段落要素のインラインの内容を囲む匿名のインライン要素を表し、丸みを帯びた青の線はspan要素を表し、オレンジの線はブロックを表す。
  

  16.4 文字と単語の間隔: 'letter-spacing'、'word-spacing'プロパティ

  
    'letter-spacing'

      
        値:  

              normal | <length> | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              'normal'または絶対長さ
            
    

  このプロパティは、テキストの文字間隔の振る舞いを指定する。値の意味は次のとおり:

  normal

    間隔は、現在のフォントでの通常の間隔となる。この値は、ユーザエージェントがテキストを両端揃えするために文字間の空白を変更してよい。

    <length>

    この値は、文字間のデフォルトスペースに加えて、文字間のスペースを指示する。値は負であってもよいが、実装固有の制限があるかもしれない。ユーザーエージェントは、さらにテキストを両端揃えするために文字間のスペースを増減しないかもしれない。
  文字間隔算出のアルゴリズムはユーザエージェント依存である。

  
    例:

    この例では、BLOCKQUOTE要素の文字間のスペースは'0.1em'増加する。
    
blockquote { letter-spacing: 0.1em }


    次の例では、ユーザエージェントは文字間スペースの変更を許可されない。
    
blockquote { letter-spacing: 0cm }   /* '0'と等価 */

  

  二つの文字間に得られたスペースがデフォルトのスペースと同じでない場合、ユーザエージェントはリガチャ（合字）を用いるべきではない。

  
    'word-spacing'

      
        値:  

              normal | <length> | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              'normal'の値が'0'、そうでなければ絶対長さ
            
    

  このプロパティは、単語間の間隔の振る舞いを指定する。値の意味は次のとおり:

  normal

    現在のフォントおよび/またはユーザーエージェントで定義される通常の単語間のスペース。

    <length>

    この値は、単語間のデフォルトスペースに加えて、単語間のスペースを指示する。値は負であってもよいが、実装固有の制限があるかもしれない。
  単語間隔算出のアルゴリズムはユーザエージェント依存である。単語の間隔は、両端揃えの影響を受ける（'text-align'プロパティを参照）。単語の間隔は、それぞれのスペース（U+0020）と空白処理規則が適用された後のテキストに残されたノーブレークスペース（U +00A0）に影響する。他の単語区切り文字でのプロパティの効果は未定義である。しかし、一般的な句読点はゼロの送り幅（幅なしスペースU+200Bなど）と、固定幅スペース（たとえば、U+3000とU+200Aを経由してU+2000など）を持つ文字は影響を受けない。

  
    例:

    この例では、H1要素の各単語の単語間隔は'1em'増加する。
    
h1 { word-spacing: 1em }

  

  16.5 大文字化: 'text-transform'プロパティ

  
    'text-transform'

      
        値:  

              capitalize | uppercase | lowercase | none | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、要素のテキストの大文字化の効果を制御する。値の意味は次のとおり:

  capitalize

    大文字で各単語の最初の文字を置き、他の文字に影響はない。

    uppercase

    大文字で各単語のすべての文字を置く。

    lowercase

    小文字で各単語のすべての文字を置く。

    none

    効果なし。
  それぞれのケースでの実際の変換は、言語に依存して書きこまれる。要素の言語を検索する方法についてはBCP 47（[BCP47]）を参照のこと。

  "大文字と小文字があるアルファベットスクリプト"に属する文字のみは[UNICODE]の影響を受ける。

  
    例:

    この例では、H1要素のすべてのテキストは大文字に変換される。
    
h1 { text-transform: uppercase }

  

  16.6 空白: 'white-space'プロパティ

  
    'white-space'

      
        値:  

              normal | pre | nowrap | pre-wrap | pre-line | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは要素内の空白がどのように処理されるかを宣言する。値の意味は次のとおり:

  normal

    この値は、ユーザエージェントに空白文字列を折りたたみを指示し、行ボックスを埋めるために必要に応じた改行をする。

    pre

    この値は、ユーザーエージェントを空白文字列の折りたたみから防ぐ。行のみが保持され改行文字で改行される。

    nowrap

    この値は'normal'のように空白スペースを折りたたむが、テキスト内の改行を抑制する。

    pre-wrap

    この値は、ユーザーエージェントを空白文字列の折りたたみから防ぐ。行は、行ボックスを埋めるために、必要に応じて保存された改行文字で改行する。

    pre-line

    この値は、空白文字列を折りたたむようユーザエージェントに指示する。行は、行ボックスを埋めるために、必要に応じて保存された改行文字で改行する。
  ソース内の改行は、キャリッジリターン（U+000D）、ラインフィールド（U+000A）、またはその両方（U+000D U+000A）、またはSGMLのRECORD-STARTおよびRECORD-ENDトークンなどのような、文書のセグメントの開始と終了を識別する他のメカニズムによって表されることができる。CSSの'white-space'処理モデルは、すべてのラインフィールドを改行に正規化されていると仮定する。あたかもこの正規化が行われたかのように他の改行表現を認識するユーザーエージェントは、空白の処理規則を適用しなければならない。改行規則が文書言語で指定されない場合、文書テキストの各キャリッジリターン（U+000D）とCRLFシーケンス（U+000D U+000A）は、単一の改行文字として扱われる。このデフォルトの正規化規則は、生成コンテンツにも適用される。

  ユーザーエージェントは、 ラインフィールド（U+000A）を改行文字として認識しなければならない。ユーザーエージェントはさらにUAX14を通じて改行文字のような他の強制改行文字を扱ってよい。

  
    例:

    次の例では、空白の動作がHTMLのPREとP要素と"nowrap"属性から期待されていることを示す。
    
pre        { white-space: pre }
p          { white-space: normal }
td[nowrap] { white-space: nowrap }


    さらに、非標準の"wrap"属性を持つHTMLのPRE要素の効果は、次の例で明示される。
    
pre[wrap]  { white-space: pre-wrap }

  

  16.6.1 'white-space'処理モデル

  各インライン要素（匿名インライン要素を含む）については、次の手順は、双方向の書式設定文字がそこになかったかのように扱い、実行される。

  'white-space'が'normal'、'nowrap'、'pre-line'に設定される場合、ラインフィールド（U+000A）を取り巻くタブ（U+0009）、復帰（U+000D）、スペース（U+0020）の文字は削除される。

    'white-space'が'pre'または'pre-wrap'に設定される場合、要素の境界で連続した空白（U+0020）のいずれかのシーケンスは、非区切りスペースのシーケンスとして扱われる。しかし、'pre-wrap'において、改行の機会はシーケンスの最後に存在する。

    'white-space'が'normal'または'nowrap'に設定される場合、改行文字は、コンテンツのスクリプトに基づいたユーザーエージェント特有のアルゴリズムに従って、空白文字、ゼロ幅スペース文字（U+200B）、または文字なし（すなわち、レンダリングされない）の1つにレンダリングする目的のために変換される。

    'white-space'が'normal'、'nowrap'、'pre-line'に設定される場合、

      すべてのタブ（U+0009）は、スペース（U+0020）に変換され、

        そのスペースも'normal'、'nowrap'、'pre-line'の設定された'white-space'を持つ場合でも、インラインの前のスペース―別のスペース（U+0020）とその後に続くスペース（U+0020）は削除される。
      
  その後、ブロックコンテナのインラインがレイアウトされる。インラインは双方向の並べ替えを考慮し、'white-space'プロパティで指定された包装をし、レイアウトされる。ラッピングする際に、改行の機会は上記の空白折りたたみ手順より前にテキストに基づいて決定される。

  各行がレイアウトされるように、

  行の先頭のスペース（U+0020）が'normal'、'nowrap'または'pre-line'に設定された'white-space'を持つ場合、スペースは削除される。

    すべてのタブ（U+0009）は、次のタブの終了とともに次のグリフの開始端までを整列する水平シフトとしてレンダリングされる。タブストップは8回のブロックの開始、コンテンツの端からブロックのフォントでレンダリングされたスペース（U+0020）の幅の倍数である点で発生する。

    行の末尾のスペース（U+0020）が'normal'、'nowrap'または'pre-line'に設定された'white-space'を持つ場合、そのスペースも削除される。

    行の末尾のスペース（U+0020）またはタブ（U+0009）が'pre-wrap'と'white-space'に設定される場合、ユーザーエージェントは視覚的にそれらを折りたたんでよい。
  フロートと絶対位置の要素は改行の機会を導入しない。

  
    注。 CSS 2.1は改行の機会が出現する場所を完全に定義しない。
  

  16.6.2 双方向での空白の相殺の例

  与えられた次のマークアップ断片で、強調と識別のための多様な背景と枠線とともに）スペースに特別な注意をする:
  
 
     <ltr>A <rtl> B </rtl> C</ltr>



  <ltr>要素は左から右への埋め込みを表し、<rtl>要素は右から左への埋め込みを表し、'white-space'プロパティには'normal'が設定されていると仮定すると、上記の処理モデルの結果は次のようになる:

  Bの前のスペース（ ）がAの後のスペース（ ）と相殺してしまう。

    Cの前のスペース（ ）がBの後のスペース（ ）と相殺してしまう。
  これは、左から右への埋め込みレベルでAの後を1つ、右から左への埋め込みレベルでBの後に1つの、2つのスペースを残す。そして、これは最終的な結果とともに、Unicodeの双方向アルゴリズムに従ってレンダリングされる。
  

     A  BC



  AとBの間に2つのスペースがあり、BとCの間にはスペースがないことに注意する。これは時々文字の代わりに明示的に埋め込みレベルの自然な双方向性を使用することによって回避できる。また、これらは空白の相殺を扱う場合奇妙な事態を起こす傾向があるので、開始タグと終了タグの内側で空白を避けるのがよい。

  16.6.3 制御文字と合成文字の詳細

  U+0009（タブ）、U+000A（ラインフィード）、U+0020（空白）と、U202x（双方向書式設定文字）以外の制御文字は、通常の文字と同じようにレンダリングする文字として扱われる。

  合成文字は、結合することになっていている文字の一部として扱われるべきである。たとえば、"o<span>&#x308;</span>"のようなコンテンツを持っている場合、:first-letterは全体のグリフをデザインする。それだけで基本文字と一致しない。

  17 テーブル

  
    目次

    17.1 テーブル概論

      
        17.2 CSSテーブルモデル

        17.2.1 匿名テーブルオブジェクト
        

      17.3 列

      
        17.4 視覚整形モデルにおけるテーブルの扱い

        17.4.1 キャプションの位置と端揃え
        

      
        17.5 テーブルの内容の視覚レイアウト

        17.5.1 テーブルのレイヤーとその透過性

          
            17.5.2 テーブルの幅のアルゴリズム: 'table-layout'プロパティ

            17.5.2.1 固定テーブルレイアウト

              17.5.2.2 自動テーブルレイアウト
            

          17.5.3 テーブルの高さのアルゴリズム

          17.5.4 列での水平位置揃え

          17.5.5 行や列の動的効果
        

      
        17.6 ボーダー

        
            17.6.1 分離ボーダーモデル

            17.6.1.1 空セル周りのボーダーと背景: 'empty-cells'プロパティ
            

          
            17.6.2 結合ボーダーモデル

            17.6.2.1 ボーダーの競合の解決
            

          17.6.3 ボーダーの種類
        
    

  17.1 テーブル概論

  この章は、CSSでテーブルの処理モデルを定義する。この処理モデルの一部はレイアウトになる。この章では、レイアウトのたの2つのアルゴリズムを紹介する。1つ目の固定テーブルレイアウトアルゴリズムはよく定義されているが、2つ目の自動テーブルレイアウトアルゴリズムは完全にこの仕様で定義されない。

  自動テーブルレイアウトアルゴリズムのために、一部の広く採用されている実装では、比較的近い相互運用性を実現する。

  テーブルレイアウトは、データ間で、テーブル形式の関係を表すために使用することができる。著者は、文書言語でこれらの関係を指定し、CSS 2.1を使用して見栄えを指定できる。

  視覚メディアでは、CSSテーブルは特定のレイアウトを達成するために使用できる。この場合、著者は文書言語のテーブル関連要素を使うべきではないが、必要なレイアウトを実現するために関連する構造要素にCSSを適用すべきである。

  著者は、セルの矩形格子としてテーブルの視覚的な書式を指定してよい。セルの行や列は、行グループや列グループで構成されてよい。行、列、行グループ、列グループ、およびセルは周りに描かれたボーダーを持ってよい（CSS 2.1 では 2つのボーダーモデルがある）。著者は、セル内で垂直方向または水平方向にデータを配置し、行または列のすべてのセルにデータを整列してよい。

  
    例:

    HTML 4で表される単純な3行3列のテーブルは次のとおり:
    
<TABLE>
<CAPTION>This is a simple 3x3 table</CAPTION>
<TR id="row1">
   <TH>Header 1  <TD>Cell 1  <TD>Cell 2
<TR id="row2">
   <TH>Header 2  <TD>Cell 3  <TD>Cell 4
<TR id="row3">
   <TH>Header 3  <TD>Cell 5  <TD>Cell 6
</TABLE>


    このコードは、1つのテーブル（TABLE要素）、3つの行（TR要素）、3つのヘッダセル（TH要素）、および6つのデータセル（TD要素）を作成する。この例の3列は暗黙的に指定されていることに注意する。ヘッダとデータセルによりテーブルに必要に応じて列が存在する。

    次のCSS規則は、ヘッダセルのテキストを水平に中央揃えにし、ヘッダセルのテキストのボールド体の重みを示す:
    
th { text-align: center; font-weight: bold }


    次の規則は、ヘッダセルのテキストをベースライン上に揃え、垂直方向の中央に各データセル内のテキストを揃える:
    
th { vertical-align: baseline }
td { vertical-align: middle }


    次の規則は、一番上の行が3pxの青の実線ボーダーで囲まれ、他の行が1pxの黒の実線ボーダーで囲まれるよう指定する:
    
table   { border-collapse: collapse }
tr#row1 { border: 3px solid blue }
tr#row2 { border: 1px solid black }
tr#row3 { border: 1px solid black }


    ただし、行同士が接触する行の周囲でボーダーが重なることに注意する。row1とrow2の間のボーダーはどのような色（黒または青）と太さ（1pxまたは3px）になるか？これについてはボーダーの競合の解決の節で議論する。

    次のルールは、テーブルの上にテーブルのキャプションを置く：
    
caption { caption-side: top }

  

  前述の例では、CSSがHTML 4の要素とどのように動作するかを示している。HTML 4には、さまざまなテーブル要素（TABLE、CAPTION、THEAD、TBODY、TFOOT、COL、COLGROUP、TH、TD）の意味が明確に定義されている。他の文書言語（XMLアプリケーションなど）では、事前に定義されたテーブルの要素がないかもしれない。したがって、CSS 2.1の著者は文書言語の要素に'display'プロパティを通してテーブル要素に"割り当て"ることができる。たとえば、次の規則は、FOO要素にHTMLのTABLE要素のような役割を、BAR要素にCAPTION要素のような役割を与える。
  
FOO { display : table }
BAR { display : table-caption }


   以下の節でさまざまなテーブルの要素について説明する。本仕様において、テーブル要素とはテーブルの作成に関与する任意の要素を指す。内部のテーブル要素とは、行、行グループ、列、列グループ、またはセルを生成する要素である。

  17.2 CSSテーブルモデル

  CSSのテーブルモデルは、テーブルの構造がテーブルの視覚的なレイアウトと極めて類似するHTML 4のテーブルモデルに基づく。このモデルでは、テーブルは任意の説明文と任意の行数のセルで構成される。テーブルモデルは、著者が文書言語で明示的に列ではなく行を指定するので"行中心"と言われる。いったんすべての行が指定されると列が導出される―各行の最初のセルは最初の列、第2列には2番目のセルなどに属す。行と列は構造的にグループ化されてよく、このグループ化は見栄えに反映される（たとえば、ボーダーが行グループの周りに描画されてよい）。

  したがって、テーブルモデルは、テーブル、キャプション、行、行グループ（ヘッダーとフッターグループグループを含む）、列、列グループ、セルで構成される。

  CSSモデルは、文書言語がこれらの各構成要素に対応する要素を含むことを要求しない。事前定義されたテーブルの要素を持たない文書言語（XMLアプリケーションなど）について、著者は、文書言語の要素をテーブル要素に割り当てなければならない。これは'display'プロパティを用いて行われる。次の'display'の値は、任意の要素にテーブルの書式設定規則を割り当てる:

  table（HTMLでTABLE）

    指定要素がブロックレベルのテーブルを定義する: ブロック整形コンテキストに参加する矩形のブロックとなる。

    inline-table（HTMLでTABLE）

    指定要素がインラインレベルのテーブルを定義する: インライン整形コンテキストに参加する矩形のブロックとなる。

    table-row（HTMLでTR）

    指定要素はセルの行となる。

    table-row-group（HTMLでTBODY）

    指定要素グループが1つ以上の行となる。

    table-header-group（HTMLでTHEAD）

    'table-row-group'と同様だが視覚整形において、行グループは、常にすべての行と行のグループの前に、かつ任意の上部のキャプションの後に表示される。印刷ユーザエージェントはテーブルによって広げられる各ページのヘッダ行を繰り返してよい。テーブルが'display: table-header-group'をもつ複数の要素を含む場合、1行目のみヘッダとして描画される。他の行はあたかも'display: table-row-group'を持つかのように扱われる。

    table-footer-group（HTMLでTFOOT）

    'table-row-group'と同様だが視覚整形において、行グループは、常にすべての行と行のグループの後に、かつ任意の下部のキャプションの前に表示される。印刷ユーザエージェントは、テーブルが複数ページにわたる場合、各ページのフッタ行を繰り返してよい。テーブルが'display: table-footer-group'をもつ複数の要素を含む場合、1行目のみフッタとして描画される。他の行はあたかも'display: table-row-group'を持つかのように扱われる。

    table-column（HTMLでCOL）

    指定要素は、セルの列を記述する。

    table-column-group（HTMLでCOLGROUP）

    要素グループは、1つまたは複数の列があることを指定する。

    table-cell(HTMLでTD、TH）

    要素がテーブルのセルを表すことを指定する。

    table-caption（HTMLでCAPTION）

    テーブルの説明文を指定する。'display: table-caption'をもつすべての要素は、17.4節で説明されるように描画されなければならない。
  これらの'display'値をもつ置換要素は、レイアウト中にその指定されたdisplay型として扱われる。たとえば、'display: table-cell'に設定される画像は使用可能なセル空間を埋め、その寸法は通常のセルと同様に、テーブルのサイズアルゴリズムに貢献するかもしれない。

  'table-column'または'table-column-group'に設定される'display'をもつ要素は、レンダリングされない（'display: none'をもつ場合とまったく同じである）が、それらが表す特定の列のスタイルを風洞する属性を持つかもしれないので、有用である。

  付録のHTML4のデフォルトスタイルシートは、HTML4のためのこれらの値の使用方法を示している:
  
table    { display: table }
tr       { display: table-row }
thead    { display: table-header-group }
tbody    { display: table-row-group }
tfoot    { display: table-footer-group }
col      { display: table-column }
colgroup { display: table-column-group }
td, th   { display: table-cell }
caption  { display: table-caption }


  HTMLテーブルは、下位互換性のあるレンダリングのために意図とは別のアルゴリズムを用いてレンダリングされるかもしれないため、ユーザエージェントは、HTMLテーブル要素のためにこれらの'display'プロパティの値を無視してよい。しかし、これはHTML内の他の非テーブル要素に'display: table'の使用を阻止するものではない。

  17.2.1 匿名テーブルオブジェクト

  HTML以外の文書言語はCSS 2.1のテーブルモデルの要素をすべて含むとは限らない。この場合、"欠落" の要素が動作するようテーブルモデルにおいて仮定しなければならない。任意のテーブル要素は自動的に'table'または'inline-table'要素、'table-row'要素、および'table-cell'の要素に対応する少なくとも3つの入れ子にされたオブジェクトで構成された、必要な匿名テーブルオブジェクトを自体の周りに生成する。不足要素は、以下の規則に従って匿名オブジェクト（例えば、視覚テーブルレイアウトでの匿名ボックス）を生成する:

  これらの規則の目的に対して、次の用語が定義される:

  行グループボックス

    'table-row-group'、'table-header-group'、または'table-footer-group'

    適切なテーブルの子

    'table-row'ボックス、行グループボックス、'table-column'ボックス、'table-column-group'ボックス、または'table-caption'ボックス。

    適切なテーブル行の親

    'table'または'inline-table'または行グループボックス

    内部テーブルボックス

    'table-cell'ボックス、'table-row'ボックス、行グループボックス、'table-column'ボックス、または'table-column-group'ボックス。

    テーブルコンテナ

    'table-row'ボックスまたは適切なテーブル行の親

    連続的な

    任意な空白のみを含む匿名インライン以外の兄弟を介在しない場合、二つの兄弟ボックスは連続的である。シーケンス内の各ボックスがそのシーケンスでその前の1つに連続的な場合、兄弟ボックスのシーケンスは連続的である。
  これらの規則の目的に対して、フロー外の要素はゼロ幅とゼロ高さのインライン要素として表される。それらの包含ブロックは適宜選択される。

  3段階で次の手順が実行される。

  不適切なボックスを削除する:

      'table-column'の親のすべての子ボックスは、あたかも'display: none'を持つかのように扱われる。

        'table-column-group'の親の子Cが'table-column'ボックスでない場合、あたかもCは'display: none'を持つかのように扱われる。

        テーブルコンテナPの子Cが空白のみを含む匿名インラインボックスであり、その直前および直後に続く兄弟が、もしあれば、Pの適切なテーブルの子孫であり、かつ'table-caption'または内部テーブルボックスのいずれかである場合、あたかも'display: none'を持つかのように扱われる。任意の介在する'table'または'inline-table'ボックスの生成を引き起こすことなく、DがAの子孫であることができれば、ボックスDはAの適切なテーブルの子孫である。

        ボックスBが空白のみを含む匿名インラインであり、内部テーブルボックスまたは'table-caption'ボックスのどちらかで、それぞれ2つの直近の兄弟の間にある場合、Bはあたかも'display: none'を持つかのように扱われる。
      

    欠落した子ラッパーを生成する:

      'table'または'inline-table'ボックスの子Cが適切なテーブルの子でない場合、Cの周りに匿名の'table-row'ボックスを生成し、適切なテーブルの子供でないCのすべての連続した兄弟を生成する。

        行グループボックスの子Cが'table-row'ボックスでない場合、Cの周りに匿名の'table-row'ボックスを生成し、'table-row'ボックスでないCのすべての連続した兄弟を生成する。

        'table-row'ボックスの子Cが'table-cell'でない場合、Cの周りに匿名の'table-cell'ボックスを生成し、'table-cell'ボックスでないCのすべての連続した兄弟を生成する。
      

    欠落した親を生成する:

      連続的な内部テーブルのシーケンス内の各'table-cell'ボックスのCおよび各'table-caption'兄弟に対して、Cの親が'table-row'でない場合、Cの周りに匿名'table-row'ボックスを生成し、'table-cell'ボックスであるCのすべての連続的な兄弟を生成する。

        連続的な適切なテーブルの子供のシーケンス内の各適切なテーブルの子Cに対して、Cが親の役目を果たさない場合、Cの周りに匿名の'table'または'inline-table'ボックスTを生成し、適切なテーブルの子であるCのすべての連続した兄弟を生成する。（Cの親が'inline'ボックスである場合、Tは'inline-table'ボックスでなければならない。それ以外の場合は、'table'ボックスでなければならない。）

          親が、行グループボックスでも'table'または'inline-table'ボックスでもない場合、'table-row'は親の役目を果たさない。

            親が'table-column-group'ボックスでも'table'または'inline-table'ボックスでもない場合、'table-column'ボックスは親の役目を果たさない。

            親が'table'でも'inline-table'ボックスでもない場合、行グループボックス、'table-column-group'ボックスは親の役目を果たさない。
          
      
  
    例:

    このXMLの例では、'table'要素は、HBOX要素が含まれていると仮定される:
    
<HBOX>
  <VBOX>George</VBOX>
  <VBOX>4287</VBOX>
  <VBOX>1998</VBOX>
</HBOX>


    なぜなら、関連付けられたスタイルシートが以下のようになるためである:
    
HBOX { display: table-row }
VBOX { display: table-cell }

  

  
    例:

    この例では、3つの'table-cell'要素は、ROWのテキストを含むと仮定される。視覚整形モデルで説明されるように、テキストはさらに匿名インラインボックス内でカプセル化されることに注意する。
    
<STACK>
  <ROW>This is the <D>top</D> row.</ROW>
  <ROW>This is the <D>middle</D> row.</ROW>
  <ROW>This is the <D>bottom</D> row.</ROW>
</STACK>


    スタイルシートは:
    
STACK { display: inline-table }
ROW   { display: table-row }
D     { display: inline; font-weight: bolder }

  

  17.3 列

  テーブルのセルは、行と列の2つのコンテキストに属してよい。ただし、ソース内の文書のセルは、行の子孫であって、決して列ではない。それにもかかわらず、セルは列のプロパティを設定することによって操作可能な面がある。

  以下のプロパティは、列と列グループ要素に適用される:

  'border'

    'border-collapse'がtable要素の'collapse'に設定される場合のみ、様々なボーダーのプロパティが列に適用される。この場合、列と列グループに設定されたボーダーはすべてのセル辺でボーダーのスタイルを選択する競合解決アルゴリズムに入力される。

    'background'

    背景プロパティは列内のセルの背景を設定するが、セルと行の両方が透明な背景を持っている場合に限る。"テーブルのレイヤーと透過性"を参照のこと。

    'width'

    'width'プロパティは、列の最小幅を指定する。

    'visibility'

    列の'visibility'が'collapse'に設定される場合、その列のセルはレンダリングされず、他の列にまたがるセルは切り取られる。さらに、テーブルの幅は列が取り込まれた幅だけ短くなる。以下の"動的効果"を参照のこと。'visibility'への他の値は影響を与えない。
  
    例:

    列のプロパティを設定するスタイル規則の例を示す。最初の2つの規則は、"cols"の値をもつHTML 4の"rules" 属性を一緒に実装している。3番目の規則は、"totals"列を青にし、最後の2つの規則は、固定レイアウトアルゴリズムを用いて、列の固定サイズを作成する方法を示す。
    
col { border-style: none solid }
table { border-style: hidden }
col.totals { background: blue }
table { table-layout: fixed }
col.totals { width: 5em }

  

  17.4 視覚整形モデルにおけるテーブルの扱い

  視覚整形モデルの観点では、テーブルは、ブロックレベル（'display: table'）またはインラインレベル（'display: inline-table'）のように振る舞うことができる。

  どちらの場合も、テーブルボックス自身とキャプションボックス（文書順に）を含むテーブルのラッパーボックスと呼ばれる主要ブロックボックスをテーブルは生成する。テーブルボックスはテーブルの内部テーブルボックスを含むブロックレベルボックスである。キャプションボックスは、独自の内容、パディング、マージン、ボーダー領域を保持し、テーブルのラッパーボックス内の通常のブロックボックスとしてレンダリングされるブロックレベルボックスである。キャプションボックスは、以下のように、テーブルボックスの前または後に配置されるかどうかを'caption-side'プロパティによって決定する。

  テーブルがブロックレベルであれば、テーブルラッパーボックスは'ブロック'ボックスに、テーブルがインラインレベルあれば、'インラインブロック'ボックスとなる。テーブルのラッパーボックスは、ブロック書式コンテキストを設置する。'インラインテーブル'のベースラインの垂直方向の配置を行うとき、テーブルボックス（テーブルのラッパーボックス）が使用される。17.5.2節で説明されるようにテーブルのラッパーボックスの幅は、その内部テーブルボックスのボーダー辺の幅である。テーブルの'width'と'height'のパーセンテージは、テーブルのラッパーボックスの包含ブロックではなく、テーブルのラッパーボックス自身を基準にする。

  プロパティ'position'、'float'、'margin-*'、'top'、'right'、'bottom'、'left'の算出値は、テーブルボックスではなく、テーブルのラッパーボックスを用いる。非継承プロパティの他のすべての値は、テーブルのラッパーボックスではなく、テーブルボックスを使用する。（ここでテーブル要素の値はテーブルとテーブルのラッパーボックスを使用せず、代わりに初期値が使用される。）

  
    

    上部にキャプションをもつテーブル
  

  17.4.1 キャプションの位置と端揃え

  
    'caption-side'

      
        値:  

              top | bottom | inherit
            初期値:  

              top
            適用対象:  

              'table-caption' elements
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、テーブルボックスに対するキャプションボックスの位置を指定する。値の意味は次のとおり:

  top

    テーブルボックスの上にキャプションボックスを配置する。

    bottom

    テーブルボックスの下にキャプションボックスを配置する。
  
    注: CSS2は、異なる幅と水平方向の配置の振る舞いを表現する。その動作は、このプロパティに値'top-outside'と'bottom-outside'を用いてCSS3で導入される。
  

  キャプションボックス内で水平方向にキャプションの内容を整列するには、'text-align'プロパティを使用する。

  
    例:

    この例では、'caption-side'プロパティはテーブルの下にキャプションを配置する。キャプションはテーブルの親と同じ幅になり、キャプションテキストは左揃えになる。
    
caption { caption-side: bottom; 
          width: auto;
          text-align: left }

  

  17.5 テーブルの内容の視覚レイアウト

  内部テーブルの要素は、内容とボーダーをもつ矩形のボックスを生成する。セルは同様にパディングを持つ。内部テーブルの要素は、マージンを持たない。

  これらのボックスの視覚レイアウトは、行と列の不規則な矩形格子によって制御される。各ボックスは、以下の規則に従って決定される整数個のグリッドセルを占める。これらの規則は、HTML 4とそれ以前のHTMLのバージョンには適用されない。HTMLは、行と列のスパンに独自の制限を課している。

  各行ボックスは、グリッドセルの1行を占有する。同時に、行ボックスはソース文書に登場する順番に上から下へテーブルを埋める（すなわち、テーブルは行要素と同数の格子を占有する）。

    行グループは、含まれる行と同じグリッドセルを占有する。

    列ボックスは、格子セルの1つ以上の列を占有する。列ボックスは、出現する順に隣同士に配置される。最初の列のボックスは、テーブルの'direction'プロパティの値に応じて、左右のどちらかにあってもよい。

    列グループボックスは、含まれる列と同じ格子セルを占有する。

    セルは複数の行や列にまたがってもよい。 （CSS 2.1はまたがる行または列の数がどのように決定されるかを定義しないが、ユーザエージェントはソース文書に関する特別な情報を持ってもよい。CSSの将来の改訂は、CSS構文でこの情報を表現する方法を提供するかもしれない。）したがって、各セルは1つ以上の格子セル幅と高さの矩形ボックスとなる。この矩形の一番上の行は、セルの親で指定された行に含まれる。矩形はできるだけ左になければならないが、その矩形が占める最初の列のセルの一部は、他のセルボックス（すなわち、前の行で始まる行にまたがるセル）と重複してならず、かつセルはソース文書内の前の同一行ですべてのセルの右側になければならない。この位置が前の行から行にまたがるセルを重ねるために、列にまたがるセルの原因となる場合、CSSはその結果を定義しない。実装は、いずれかのセルを重ねてもよい（多くのHTMLの実装で行われているように）、またはそれ以降のセルをそのような重複を避けるために右にシフトしてよい。（テーブルの'direction'プロパティが'ltr'の場合、この制約は保持する。'direction'が'rtl'である場合、前の2つの文書で左右を入れ替える。）

    セルボックスは、テーブルまたは行グループの最後の行ボックスを超えて拡張することはできない。セルボックスが合うまでユーザエージェントはセルボックスを短くしなければならない。
  結合ボーダーモデルの行、列、行グループと列グループの辺は、セルのボーダー線がセンタリングされる架空のグリッド線に一致する。(And thus, in this model, the rows together exactly cover the table, leaving no gaps; ditto for the columns.) In the separated borders model, the edges coincide with the border edges of cells. （そして、このモデルでは、'border-spacing'プロパティに対応する行、列、行グループまたは列グループの間にギャップがあってもよい。）

  
    注。 9.7節の規則に従って、テーブルセルの配置と浮動は、もはやテーブルセルではない可能性がある。浮動が使用される場合、匿名のテーブルオブジェクトでの規則は、匿名のセルオブジェクトも同様に作成されてもよい。
  

  
    規則5の例を示す。次のような不正な(X)HTML断片は、矛盾するセルを定義する:
    
<table>
<tr><td>1 </td><td rowspan="2">2 </td><td>3 </td><td>4 </td></tr>
<tr><td colspan="2">5 </td></tr>
</table>


    左図のように、視覚的にセルを重複するか、右図のように、視覚的な重複を避けるためにセルをシフトするか、ユーザエージェントは自由である。

    
         [説明]

      誤りのあるHTMLテーブルの2つの可能なレンダリング。
    
  

  17.5.1 テーブルのレイヤーと透過性

  各テーブルセルの背景を理解する目的に対して、異なるテーブルの要素は6つの重ねたレイヤー上にあるものとして考えてよい。その上のレイヤーが透明な背景を持つ場合、レイヤーのいずれかの要素に設定された背景のみが可視になる。

  
       [説明]

    テーブルのレイヤーのスキーマ
  

  最下位のレイヤーは、テーブルボックス自身を表す単一の平面である。すべてのボックスと同様に、透明であってもよい。

    次のレイヤーは列グループを含む。各列グループは、一番上の行のセルの上から下の行のセルの下まで、かつその左端の列の左辺から右端の列の右辺まで拡張する。たとえ背景が列グループの外側にまたがっても、背景は正確に列グループで由来するすべてのセルの全領域を覆うが、領域でのこの違いは背景画像の位置に影響しない。

    列グループの上は列ボックスを表す領域である。各列は、列グループと同じ高さであり、列の通常のセル（単一の列にまたがる）と同じ幅である。たとえ背景が列の外側にまたがっても、背景は正確に列で由来するすべてのセルの全領域を覆うが、領域でのこの違いは背景画像の位置に影響しない。

    次は、行グループを含むレイヤーである。各行グループは、最初の列の最上位のセルの左上隅から、最後の列のその一番下のセルの右下隅まで拡張する。

    最上位のレイヤーの下は、行を含む。各行は、行グループと同じ幅となり、行の通常のセル（1つの行にまたがる）と同じ高さである。列と同様に、たとえ背景が行の外側にまたがっても、背景は正確に行で由来するすべてのセルの全領域を覆うが、領域でのこの違いは背景画像の位置に影響しない。

    最上位のレイヤーは、セル自身を含む。図に示すように、すべての行が同じ数のセルを含むものの、必ずしもすべてのセルが指定されたコンテンツを持つとは限らない。分離ボーダーモデル（'border-collapse'が'separate'である）では、それらの'empty-cells'プロパティの値が'hide'である場合、これらの"空"セルは、セル、行、行グループ、列、列グループの背景とを介して透過的であり、テーブルの背景が透けて見える。
  "欠落したセル"は、要素または疑似要素によって占有されない行または列格子のセルである。匿名テーブルセルボックスは格子内でその位置を占有していたかのように、欠落したセルはレンダリングされる。

  
    次の例では、1行目は4つの空でないセルを含むが、2行目は1つだけの空でないセルを含むため、1行目からセルがこの行にまたがる場合を除いて、テーブルの背景が現れる。次のHTMLコード及びスタイル規則
    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
  <HEAD>
    <TITLE>Table example</TITLE>
    <STYLE type="text/css">
      TABLE  { background: #ff0; border: solid black;
               empty-cells: hide }
      TR.top { background: red }
      TD     { border: solid black }
    </STYLE>
  </HEAD>
  <BODY>
    <TABLE>
      <TR CLASS="top">
        <TD> 1 
        <TD rowspan="2"> 2
        <TD> 3 
        <TD> 4 
      <TR>
        <TD> 5
        <TD>
    </TABLE> 
  </BODY>
</HTML>


    これは以下のように整形される:

    
         [説明]

      下の行に空セルを含むテーブル
    
  

  テーブルが'border-collapse: separate'を持つ場合、'border-spacing'プロパティによって与えられる領域の背景は常にテーブルの背景であることに注意する。分離ボーダーモデルを参照のこと。

  17.5.2 テーブルの幅のアルゴリズム 'table-layout'プロパティ

  CSSは、テーブルに"最適な"レイアウトを定義しない。なぜなら、多くの場合、何が最適かは好みの問題である。CSSは、テーブルをレイアウトする際、ユーザエージェントが尊重しなければならない制約を定義する。ユーザエージェントは、"固定レイアウトアルゴリズム"が選択される場合を除き、望みの任意のアルゴリズムを使用してよいし、精度上のレンダリング速度を優先するのも自由である。

  この節は、10.3節で説明したように幅を計算に適用する規則を上書きすることに注意する。特に、テーブルのマージンが'0'で幅が'auto'に設定された場合、テーブルは自動的にその包含ブロックを埋めるような大きさにならない。しかし、ひとたびテーブルの'width'の算出値が見つけられれば（適切な場合に、後述のアルゴリズムか、他の一部のユーザーエージェント依存のアルゴリズムを用いて）、10.3節の他の部分が適用される。したがって、たとえばテーブルは、左と右が'auto'のマージンを使用してセンタリング可能である。

  CSSの将来の改訂は自動的に包含ブロックに合わせてテーブルを作る方法を紹介するかもしれない。

  
    'table-layout'

      
        値:  

              auto | fixed | inherit
            初期値:  

              auto
            適用対象:  

              'table'および'inline-table'要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  'table-layout'プロパティは、テーブルのセル、行、列をレイアウトするために用いるアルゴリズムを制御する。値は以下の意味を持つ:

  fixed

    固定テーブルレイアウトアルゴリズムを使用する

    auto

    任意の自動テーブルレイアウトアルゴリズムを使用する
  2つのアルゴリズムを以下に記載する。

  17.5.2.1 固定テーブルレイアウト

  この（高速）アルゴリズムを用いたテーブルの水平方向のレイアウトは、セルの内容に依存しない。レイアウトはテーブルの幅、列の幅、ボーダーやセルの間隔にのみ依存する。

  テーブルの幅は'width'プロパティで明示的に指定してよい。'auto'（'display: table'と'display: inline-table'の両方に対して）の値は、自動テーブルレイアウトアルゴリズムの使用を意味する。ただし、テーブルが通常フローでブロックレベルテーブル（'display: table'）である場合、ユーザーエージェントは　幅を計算するために10.3.3節のアルゴリズムを使用してよく（する必要はない）、たとえ指定幅が'auto'であっても、固定テーブルレイアウトを適用してよい。

  
    例:

    'width'が'auto'であり、ユーザーエージェントは固定テーブルレイアウトをサポートする場合、次の規則は包含ブロックより4em狭くテーブルを作成する:
    
table { table-layout: fixed;
        margin-left: 2em;
        margin-right: 2em }

  

  固定テーブルレイアウトのアルゴリズムでは、各列の幅は次のように決定される:

  'width'プロパティが'auto'以外の値をもつ列要素は、その列幅を設定する。

    それ以外の場合、'width'プロパティが'auto'以外の値をもつ最初の行のセルがその列幅を決定する。セルが複数列にまたがる場合、セル幅は列に対して分割される。

    残りの列は、残りの水平方向のテーブルスペースを（ボーダーまたはセルの間隔を差し引いて）等しく分割する。
  テーブルの幅は、テーブル要素の'width'プロパティの値と、列の幅（セルの間隔やボーダーを加えた）の合計の大きい方となる。テーブルが列よりも広い場合、追加のスペースは列に分配されるべきである。

  後続の行がテーブル列の要素によって決定される数と、最初の行によって決定される数より多くの列がある場合、追加の列がレンダリングされないかもしれない。追加の列がレンダリングされる場合、CSS 2.1は、列とテーブルの幅を定義しない。'table-layout: fixed'を使用する場合、著者は最初の行から列を省略するべきではない。

  このように、ユーザエージェントは最初の行全体を受信した時点で、テーブルのレイアウトを開始可能である。後続の行のセルは列幅に影響しない。あふれる内容を持つ任意のセルは、その内容を切り抜くかどうかを決定するために、'overflow'プロパティを使用する。

  17.5.2.2 自動テーブルレイアウト

  このアルゴリズムでは（一般にわずか2つのパスを必要とする）、テーブルの幅はその列の幅（と間のボーダー）で与えられる。このアルゴリズムは、本仕様書の執筆時点で一般的なHTMLユーザーエージェントの動作を反映する。ユーザーエージェントは、'table-layout'が'auto'である場合、テーブルのレイアウトを決定するために、このアルゴリズムを実装する必要はない。たとえ異なる動作が発生した場合でも、ユーザーエージェントは他のアルゴリズムを使用可能である。

  自動テーブルレイアウトへの入力のみが包含ブロックの幅と内容、設定された任意のCSSプロパティ、テーブルとその子孫のいずれかを含めなければならない。

  
    注。 これはCSS3でより詳細に定義されるだろう。
  

  この節の残りの部分は、非規範的である。

  このアルゴリズムは、最終的なレイアウトを決定する前にテーブル内のすべてのコンテンツへのアクセスを持つことをユーザーエージェントに要求し、1パス以上を要求してよいため、非効率的かもしれない。

  列幅は、次のように決定される:

  
      各セルの最小内容幅（MCW）を計算する。整形内容は任意の数行にわたってよいが、セルボックスをはみ出してはならない。セルの指定の'width'（W）がMCWよりも大きい場合、Wは最小セル幅になる。'auto'の値は、MCWが最小セル幅であることを意味する。

      また、各セルの"最大"セル幅を計算する。明示的な改行が発生する場所以外で改行することなく内容を整形する。
    

    
      各列に対して、その列のみにまたがるセルから最大と最小の列幅を決定する。最小値は、その最大の最小セル幅（またはいずれか大きい方の列の'width'）とともにセルによって要求される。最大値は、最大セル幅のセル（またはいずれか大きい方の列の'width'）によって要求される。
    

    
      複数列にまたがるセルごとに、少なくとも同じセル幅になるように、またがる列の最小幅を増やす。最大幅も、同じ操作を行う。可能であれば、均等にすべてのまたがる列を広げる。
    

    
      'auto'以外の'width'をもつ各列グループ要素に対して、少なくとも同じ列グループの'width'なるように、またがる列の最小幅を増やす。
    
  これが各列の最大値と最小幅を与える。

  キャプションの幅の最小値（CAPMIN）は、各キャプションに"display: block"として整形されたキャプションを含む架空のテーブルセルのMCWとして、最小キャプションの外側の幅を計算することによって決定される。最小キャプションの外側の幅での最大は、CAPMINとなる。

  列とキャプションの幅は、次のように最終のテーブル幅に影響する:

  'table'または'inline-table'要素の'width'プロパティが'auto'以外の算出値（W）を持つ場合、使用幅はW、CAPMIN、すべての列で必要とされる最小幅にセルの間隔またはボーダーを加えたもの（MIN）のうち、大きいものとする。使用幅がMINよりも大きい場合、余分な幅は列を通して分配すべきである。

    'table'または'inline-table'要素が'width: auto'を持つ場合、使用幅はテーブルの包含ブロックの幅、CAPMIN、およびMINのうち大きい方となる。しかし、CAPMINまたは列とセルの間隔またはボーダーで必要とされる最大幅（MAX）のいずれかが包含ブロックよりも小さい場合、max(MAX,CAPMIN)を使用する。
  列幅のパーセント値は、テーブル幅を基準にする。テーブルが'width: auto'を持つ場合、パーセンテージは、ユーザーエージェントが満足するよう試みるべき列の幅の制約を表す。（もちろん、これは常に可能ではない。列の幅が'110%'であれば、制約を満たすことはできない。）

  
    注。 このアルゴリズムでは、行（および行グループ）と列（および列のグループ）の制約の両方と、それらに含まれるセルの寸法によって制限される。列幅を設定すると、間接的に行の高さに影響を与える。またその逆もある。
  

  17.5.3 テーブルの高さのアルゴリズム

  テーブルの高さは、'table'または'inline-table'要素の'height'プロパティによって与えられる。'auto'の値は、高さが行の高さのと任意のセルの間隔またはボーダーの和であることを意味する。他の値は、最小の高さとして扱われる。CSS 2.1は、'height'プロパティが本来のテーブルよりも高い原因となる場合、追加のスペースをどのように分配するかを定義しない。

  注。 CSSの将来の改訂は、これをさらに規定できるようにするだろう。

  ひとたびユーザエージェントが使用可能な行のすべてのセルを持つと、'table-row'要素のボックスの高さが計算される。それは、行の計算'height'と、行の各セルの計算'height'、セルに要求される最小高さ（MIN）の最大値である。'table-row'の'auto'の'height'値は、レイアウトに使用される行の高さがMINであることを意味する。MINはセルボックスの高さとセルボックスの揃え（行ボックスの高さの計算に似ている）に依存する。 CSS 2.1は高さをパーセント値を用いて指定される場合、テーブルのセルとテーブルの行の高さがどのように計算されるかを定義しない。CSS 2.1は、行グループの'height'の意味を定義しない。

  CSS 2.1では、セルボックスの高さは内容によって要求される最小の高さとなる。テーブルセルの'height'プロパティは、行の高さに影響を与えることができる（上記参照）が、セルボックスの高さを増加しない。

  関連する行の高さの合計が、行にまたがるセルを包含するのに十分大きくなければならないことを除いて、CSS 2.1は、複数行にまたがるセルが行の高さの計算にどのように影響するかを指定しない。

  各テーブルのセルの 'vertical-align'プロパティは、行内の揃えを決定する。各セルの内容は、baseline、top、middle、bottomがある。行自身の場合も同様である。テーブルのコンテキストでは、'vertical-align'の値の意味は次のとおり:

  baseline

    セルのベースラインは、セルがまたがる行の最初のベースラインと同じ高さに置く（セルと行のベースラインの定義については下記参照）。

    top

    セルボックスの上部は、セルがまたがる最初の行の上部に揃えられる。

    bottom

    セルボックスの下部は、セルがまたがる最初の行の下部に揃えられる。

    middle

    セルの中心は、セルがまたがる行の中央に揃えられる。

    sub, super, text-top, text-bottom, <length>, <percentage>

    これらの値はセルに適用しない。代わりにベースラインに揃えられる。
  セルのベースラインは、セルの最初のフロー内行ボックス、またはセルの最初のフロー内テーブル行でどちらか早い方のベースラインとなる。そのような行ボックスまたはテーブル行が存在しない場合、ベースラインはセルボックスの内容辺の下になる。ベースラインを見つける目的に対して、スクロール機構をもつフロー内ボックス（'overflow'プロパティを参照）は、あたかもボックスの原点位置にスクロールしたかのように考慮されなければならない。セルのベースラインは、セルの下ボーダーの下になってよいことに注意する。以下の例を参照のこと。

  セルボックスの上部と'vertical-align: baseline'を持つすべてのセル上のベースライン間の最大距離は、行のベースラインを設定するために使用される。以下に例を示す。

  
       [説明]

    セル要素に対する'vertical-align'の効果
  

  セルボックス1と2は、ベースラインで揃えられる。セルボックス2はベースライン上の最大の高さを持つので、その行のベースラインを決定する。

  行がベースラインに揃えられるセルボックスを持たない場合、その行のベースラインは行の最小のセルの下内容辺となる。

  あいまいな状況を避けるため、次の順序でセルの揃えを続行する:

  最初にベースラインに揃えられるセルが配置される。これは、行のベースラインを設置する。次に、'vertical-align: top'をもつセルが配置される。

    これまでのところ、行は上、おそらくベースライン、および配置されたセルの最小の上から下までの距離となる仮の高さを持つ。（下記のセルのパディングの条件を参照のこと。）

    下部または中央に揃えられた残りのセルのいずれかが、行の現在の高さより大きな高さを持つ場合、行の高さは下を下げることによってセルの最大値まで増加される。

    最後に、残りのセルが配置される。
  行の高さよりも小さいセルボックスは、余分な上部または下部パディングを受ける。

  
    この例でセルは、セルの下ボーダーの下にベースラインを持つ:
    
div { height: 0; overflow: hidden; }

<table>
 <tr>
  <td>
   <div> Test </div>
  </td>
 </tr>
</table>

  

  17.5.4 列での水平位置揃え

  セルボックス内のインラインレベルの内容の水平方向の配置は、セルの'text-align'プロパティの値によって指定可能である。

  17.5.5 行や列の動的効果

  'visibility'プロパティの値は行、行グループ、列、列グループ要素の'collapse'を取る。この値は、行または列全体を表示から削除され、スペースは通常、他のコンテンツを利用できるようにする行または列によって占められる。折りたたまれた列または行を横断する、行と列の内容が切り取られる。しかし、行または列の抑制は、他の方法でテーブルのレイアウトに影響しない。これは、動的な効果に、列の制約の潜在的変化を説明するためにテーブルの再レイアウトを強制することなくテーブルの行または列を削除することを認める。

  17.6 ボーダー

  CSSでは、テーブルのセルにボーダーを設定するための2つの異なるモデルがある。一つは、個々のセルの周りに最も適したいわゆる分離ボーダーであり、もう一方はテーブルの端から端まで連続するボーダーに適している。多くのボーダースタイルはどちらのモデルでも達成可能なので、多くの場合どちらを使うかは好みの問題である。

  
    'border-collapse'

      
        値:  

              collapse | separate | inherit
            初期値:  

              separate
            適用対象:  

              'table'および'inline-table'要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  このプロパティは、テーブルのボーダーモデルを選択する。値'separate'は分離ボーダーモデルを選択する。値'collapse'は結合ボーダーモデルを選択する。2つのモデルを以下に記載する。

  17.6.1 分離ボーダーモデル

  
    'border-spacing'

      
        値:  

              <length> <length>? | inherit
            初期値:  

              0
            適用対象:  

              'table'および'inline-table'要素（*注参照）
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              2つの絶対長さ
            
    

  *) 注: ユーザエージェントは'frameset'要素の'border-spacing'プロパティに適用してよい。どの要素が'frameset'要素かは本仕様で定義されず、文書言語次第である。たとえば、HTML4は<FRAMESET>要素を定義し、XHTML 1.0は<frameset>要素を定義する。'frameset'要素の'border-spacing'プロパティは、このように非標準の'framespacing'属性の有効な代替として使用可能である。

  長さは、隣接するセルのボーダーを分離する距離を指定する。1つの長さが指定される場合、水平および垂直の両方の間隔を与える。2つが指定される場合、1つ目は水平間隔を、2つ目は垂直間隔を与える。長さは負であってはならない。

  テーブルのボーダーとテーブルの端にあるセルのボーダー間の距離は、テーブル側面のパディングに加えて、関連するボーダーの間隔の距離となる。.たとえば右側では、距離は padding-right + horizontal border-spacing となる

  テーブルの幅は、左内側のパディング辺から右内側のパディング辺（ボーダーの間隔を含むが、パディングとボーダーを除く）までの距離となる。

  しかし、HTMLとXHTML1で、<table>要素の幅は、左ボーダー辺から右ボーダー辺までの距離である。

  注: CSS3では、この特有の要件はユーザーエージェントのスタイルシートの規則と'box-sizing'プロパティに関して定義される。

  このモデルでは、各セルは個々のボーダーを持つ。'border-spacing'プロパティは、隣接するセルのボーダー間の距離を指定する。In this space, the row, column, row group, and column group backgrounds are invisible, allowing the table background to show through. 行、列、行グループ、列グループはボーダーを持つことはない（すなわち、ユーザエージェントはそれらの要素のボーダープロパティを無視しなければならない）。

  
    例:

    下の図は、次のようなスタイルシートの結果である:
    
table      { border: outset 10pt; 
             border-collapse: separate;
             border-spacing: 15pt }
td         { border: inset 5pt }
td.special { border: inset 10pt }  /* 左上のセル */


    
         [説明]

      'border-spacing'に長さの値を指定したテーブル。各セルは、セル自身のボーダーを持ち、その上テーブルも分離ボーダーを持つことに注意する。
    
  

  17.6.1.1 空セル周りのボーダーと背景: 'empty-cells'プロパティ

  
    'empty-cells'

      
        値:  

              show | hide | inherit
            初期値:  

              show
            適用対象:  

              'table-cell'要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual
            算出値:  

              指定値
            
    

  分離ボーダーモデルでは、このプロパティは可視内容を持たないセルの周りのボーダーや背景のレンダリングを制御する。空のセルと'hidden'に設定された'visibility'プロパティを持つセルが可視内容を持たないと考えられる。セルは、次の1つ以上を含まない限り、空である。

  浮動する内容（空要素を含む）

    'white-space'プロパティの操作によって相殺されている空白以外のフロー内の内容（空要素を含む）。
  このプロパティの値が'show'となる場合、ボーダーおよび背景が空のセル前後に描かれる（通常のセルのように）。

  'hide'の値は、ボーダーや背景が空セルの周囲に描画されないことを意味する（17.5.1節のポイント6を参照）。さらに、行のすべてのセルが'hide'を持ち、可視内容を持たない場合、その行はゼロ高さを持ち、行の片側だけに垂直なボーダーの間隔が存在する。

  
    例:

    次の規則は、全セルの周囲に描画されるボーダーと背景をもたらす:
    
table { empty-cells: show }

  

  17.6.2 結合ボーダーモデル

  結合ボーダーモデルでは、セル、行、行グループ、列、列グループのすべてまたは一部を囲むボーダーを指定可能である。HTMLの"rules"属性のボーダーにこの方法を指定することができる。

  ボーダーは、セル間のグリッド線を中心にされる。不連続単位（画面ピクセル、プリンタドット）の数が奇数の場合、ユーザエージェントは、丸めの一貫した規則を満たさなければならない。

  次の図は、テーブル幅、ボーダー、パディング、およびセル幅がどのように相互作用するかを示す。これらの関係は、テーブルの行ごとに保持し、次式で与えられる:

  
    row-width = (0.5 * border-width0) + padding-left1 + width1 + padding-right1 + border-width1 + padding-left2 +...+ padding-rightn + (0.5 * border-widthn)
  

  ここで、n行のセルの数、padding-leftiおよびpadding-rightiはi番目セルの左（右）パディングを参照し、border-widthiはi番目のセルとi+1番目のセルとの間のボーダーを参照する。

  ユーザーエージェントは、テーブルの最初の行の最初と最後のセルを分析することによって、テーブルの最初の左と右のボーダーの幅を計算しなければならない。テーブルの左ボーダーの幅は、最初のセルの折りたたまれた左ボーダーの半分であり、テーブルの右ボーダーの幅は、最後のセルの折りたたまれた右のボーダーの半分である。後続の行が結合した左および右ボーダーより大きい場合、すべての超過はテーブルの余白領域に出る。

  テーブルの上ボーダーの幅は、テーブルの上ボーダーとの上ボーダーを折りたたむすべてのセルを分析することによって計算される。テーブルの上ボーダーの幅は最も折りたたまれた上ボーダーの半分に等しい。下ボーダーの幅は、テーブルの下とともに下ボーダーをおりたたむすべてのセルを分析することによって計算される。下ボーダーの幅は最も折りたたまれた下ボーダーの半分に等しい。

  テーブルがいくつかの祖先をあふれさせるかどうかを判断する場合（'overflow'参照）、マージンに出る任意のボーダーが考慮される。

  
       [説明]

    セル幅、ボーダー幅、パディング幅の相互関係を表すスキーマ
  

  このモデルでは、テーブル幅がテーブルのボーダーの半分を含むことに注意する。また、このモデルでは、テーブルはパディングを持たない（ただし、マージンを持つ）。

  CSS 2.1は、テーブル要素の背景の辺がどこに位置するかを定義しない。

  17.6.2.1 ボーダーの競合の解決

  結合ボーダーモデルでは、セルごとの辺ごとのボーダーがその辺部（セル、行、行グループ、列、列グループ、およびテーブル自身）で接触するさまざまな要素にボーダープロパティによって指定されてよく、これらのボーダーの幅、スタイル、色が異ってもよい。おおまかなやり方は、各辺で最も"目を引く"ボーダーの種類が選択されることである。ただし、スタイル'hidden'の出現は無条件にボーダーをオフにする。

  次の規則は、ボーダーの種類が競合の場合に"勝つ"ものを決定する:

  'hidden'の'border-style'をもつボーダーは、他のすべての競合するボーダーより優先する。この値をもつ任意のボーダーはこの場所ですべてのボーダーを抑制する。

    'none'の種類をもつボーダーは最も低い優先度を持つ。この辺ですべての要素に接するボーダープロパティが'none'である場合に限り、ボーダーを削除する（ただし、'none'はボーダーの種類のデフォルト値であることに注意する）。

    すべての種類が'hidden'でなく、少なくとも1つが'none'でない場合、細いボーダーは広いボーダーを優先により破棄される。複数が同じ 'border-width'をもつ場合、種類の優先順位は、'double'、'solid'、'dashed'、'dotted'、'ridge'、'outset'、'groove'、'inset'の順になる。

    ボーダーの種類が色のみ異なる場合、セルに設定された種類を取り込み、行グループ、列、列グループ、テーブルの順になる。同じ型の2つの要素が競合する場合、左のさらに1つ左（テーブルの方向が'ltr'である場合。'rtl'である場合は右）と、さらに上が勝つ。
  
    例:

    次の例は、これらの優先規則の適用を示す。このスタイルシートと:
    
table          { border-collapse: collapse;
                 border: 5px solid yellow; }
*#col1         { border: 3px solid black; }
td             { border: 1px solid red; padding: 1em; }
td.cell5       { border: 5px dashed blue; }
td.cell6       { border: 5px solid green; }


    次のHTMLに適用すると:
    
<TABLE>
<COL id="col1"><COL id="col2"><COL id="col3">
<TR id="row1">
    <TD> 1
    <TD> 2
    <TD> 3
</TR>
<TR id="row2">
    <TD> 4 
    <TD class="cell5"> 5
    <TD class="cell6"> 6
</TR>
<TR id="row3">
    <TD> 7
    <TD> 8
    <TD> 9
</TR>
<TR id="row4">
    <TD> 10
    <TD> 11
    <TD> 12
</TR>
<TR id="row5">
    <TD> 13
    <TD> 14
    <TD> 15
</TR>
</TABLE>


    このようになる:

    
         [説明]

      結合ボーダーモデルの例
    
  

  
    例:

    hiddenの結合ボーダーの例は次のとおり:

    
         [説明]

      内部のボーダーを取り払ったテーブル
    

    HTMLは以下のとおり:
    
<TABLE style="border-collapse: collapse; border: solid;">
<TR><TD style="border-right: hidden; border-bottom: hidden">foo</TD>
    <TD style="border: solid">bar</TD></TR>
<TR><TD style="border: none">foo</TD>
    <TD style="border: solid">bar</TD></TR>
</TABLE>

  

  17.6.3 ボーダーの種類

  'border-style'の値の一部は、他の要素と比べてテーブル内で異なる意味を持つ。以下のリストにそれらをアスタリスクでマークする。

  none

    ボーダはない。

    *hidden

    'none'と同じだが、結合ボーダーモデルでは、他のボーダーをを阻害する（ボーダーの競合の節を参照）。

    dotted

    ボーダーを点線にする。

    dashed

    ボーダーを破線にする。

    solid

    ボーダーを実線にする。

    double

    ボーダーを二重線にする。2本の実線とその間の空白との合計幅が'border-width'の値と等しくなる。

    groove

    キャンバスの窪みとしてボーダーを表示する。

    ridge

    'groove'の逆で、キャンバスの隆起としてボーダーを表示する。

    *inset

    分離ボーダーモデルでは、ボーダーは、あたかもキャンバスに埋め込まれたかのように全体のボックスを見せる。結合ボーダーモデルでは、'ridge'と同じように描画される。

    *outset

    分離ボーダーモデルでは、ボーダーはあたかもキャンバスから出てきたかのように全体のボックスを見せる。結合ボーダーモデルでは、'groove'と同じように描画される。
  
  18 ユーザーインタフェース

  
    目次

    18.1 カーソル: 'cursor'プロパティ

      18.2 システム色

      18.3 フォントのユーザー優先権

      
        18.4 動的アウトライン: 'outline'プロパティ

        18.4.1 アウトラインとフォーカス
        

      18.5 拡大表示
    

  18.1 カーソル: 'cursor'プロパティ

  
    'cursor'

      
        値:  

              [ [<uri> ,]* [ auto | crosshair | default | pointer | move | e-resize | ne-resize | nw-resize | n-resize | se-resize | sw-resize | s-resize | w-resize | text | wait | help | progress ] ] | inherit
            初期値:  

              auto
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              visual, interactive
            算出値:  

              指定値のとおり、ただし任意の相対URLは絶対URLに変換
            
    

  このプロパティは、ポインティングデバイスのために表示するカーソルのタイプを指定する。値の意味は次のとおり:

  auto

    ユーザーエージェントが現在のコンテキストに基づいて表示カーソルを決定する。

    crosshair

    単純な十字線（たとえば、"+" 符号に似た短い線分）。

    default

    プラットフォーム依存のデフォルトのカーソル。多くの場合、矢印のようにレンダリングされる。

    pointer

    カーソルはリンクを示すポインタとなる。

    move

    対象を移動させることを示す。

    e-resize, ne-resize, nw-resize, n-resize, se-resize, sw-resize, s-resize, w-resize

    縁を移動させることを示す。たとえば、'se-resize'のカーソルはボックスの右下の隅を動かし始めるときに用いる。

    text

    テキストを選択可能なことを示す。多くの場合、I型のようにレンダリングされる。

    wait

    プログラムがビジー状態でユーザーが待機すべきことを示す。多くの場合、時計や砂時計のようにレンダリングされる。

    progress

    進行状況インジケータ。プログラムは、いくつかの処理を実行し、ユーザーがまだプログラムと対話することができるという点で'wait'とは異なる。多くの場合、回転するビーチボールや、時計や砂時計をもつ矢印のようにレンダリングされる。

    help

    ヘルプが、カーソルの下のオブジェクトで利用できる。多くの場合、疑問符やバルーンとしてレンダリングされる。

    <uri>

    ユーザーエージェントは、URIで指定されたリソースからカーソルを取得する。ユーザーエージェントは、カーソルのリストの最初のカーソルを処理できない場合、2番目の処理を試みるべきである（以降も同様）。ユーザーエージェントは、任意のユーザー定義のカーソルを処理できない場合、リストの最後の一般的なカーソルを使用しなければならない。カーソルの固有サイズは、背景画像として計算される。ただし、ユーザーエージェント定義の矩形は'background-image'プロパティの座標系を設置し、矩形の代わりに使用される。このユーザーエージェント定義の矩形は、ユーザーエージェントのオペレーティングシステム上で典型的なカーソルのサイズに基づくべきである。結果として、カーソルのサイズがこの矩形内に収まらない場合、矩形内に収まるまで、ユーザーエージェントは比例的に結果のカーソルを縮小してよい。
  
    例:
    
:link,:visited { cursor: url(example.svg#linkcursor), url(hyper.cur), pointer }


    この例は、すべてのハイパーリンク（訪問したか否かに関係なく）上のカーソルに外部のSVGカーソルを設定する。SVGカーソルをサポートしないユーザーエージェントは、単純に次の値へ飛び、"hyper.cur"カーソルの使用を試みる。そのカーソルの形式もサポートされない場合、ユーザーエージェントは次の値へ飛び、単純に'pointer'カーソルをレンダリングする。
  

  18.2 システム色

  
    注。 システム色は、CSS3カラーモジュールで廃止予定である。[CSS3COLOR]
  

  テキスト、背景などに事前に定義された色の値を割り当て可能に加えて、CSS2は、著者にオペレーティングシステムのグラフィック環境に統合する方法で色を指定することができる色の値の集合を導入した。

  対応する値を持たないシステムでは、指定値は、最も近いシステム値またはデフォルトの色にマッピングすべきである。

  以下は、色に関連するCSSプロパティと一般的な意味について追加の値を挙げる。任意の色のプロパティ（例えば、'color' や 'background-color'）は、次のいずれかの名前を取ることができる。これらは大文字と小文字が区別しないが、読みやすさのために、以下のような大文字混じりの名前の使用を推奨する。

  ActiveBorder

    アクティブウィンドウのボーダー。

    ActiveCaption

    アクティブウィンドウのキャプション。

    AppWorkspace

    様々な文書インタフェースの背景色。

    Background

    デスクトップの背景。

    ButtonFace

    3次元表示要素の表面色。

    ButtonHighlight

    3次元表示要素（光源から離れて直面している辺の）の色を強調表示する。

    ButtonShadow

    3次元表示要素の影の色。

    ButtonText

    プッシュボタンの文字。

    CaptionText

    キャプション、サイズボックス、スクロールバーの矢印ボックスの文字。

    GrayText

    灰色の（無効な）文字。現在のディスプレイドライバが無地の灰色をサポートしない場合、この色は#000に設定される。

    Highlight

    コントロール内で選択された項目。

    HighlightText

    コントロール内で選択された項目の文字。

    InactiveBorder

    非アクティブウィンドウのボーダー。

    InactiveCaption

    非アクティブウィンドウのキャプション。

    InactiveCaptionText

    非アクティブタイトルキャプションの文字。

    InfoBackground

    ツールチップコントロールの背景色。

    InfoText

    ツールチップコントロールの文字色。

    Menu

    メニューの背景。

    MenuText

    メニューの文字。

    Scrollbar

    スクロールバーの灰色の領域。

    ThreeDDarkShadow

    3次元表示要素の暗い影。

    ThreeDFace

    3次元表示要素の表面色。

    ThreeDHighlight

    3次元表示要素の色を強調表示する。

    ThreeDLightShadow

    3次元表示要素の明るい色（光源に面した辺）。

    ThreeDShadow

    3次元表示要素の暗い影。

    Window

    ウィンドウの背景。

    WindowFrame

    ウィンドウのフレーム。

    WindowText

    ウィンドウの文字。
  
    例:

    たとえば、段落の前景色と背景色をユーザーのウィンドウの前景色と背景色と同じに設定するには、次のように記述する:
    
p { color: WindowText; background-color: Window }

  

  18.3 フォントのユーザー優先権

  色について、著者は、ユーザーのシステムリソースの使用する方法でフォントを指定してよい。詳細は'font'プロパティを参照。

  18.4 動的アウトライン: 'outline'プロパティ

  ときには、スタイルシートの著者は、ボタン、アクティブなフォームフィールド、イメージマップなどをビジュアルオブジェクトを目立つように、周りにアウトラインを作成することができる。CSS 2.1のアウトラインは、以下の点でボーダーと異なる。

  アウトラインは、スペースを取らない。

    アウトラインは、矩形でないかもしれない。
  アウトラインのプロパティは、動的なアウトラインの見栄えを制御する。

  
    'outline'

      
        値:  

              [ <'outline-color'> || <'outline-style'> || <'outline-width'> ] | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual, interactive
            算出値:  

              個々のプロパティを参照
            
    

  
    'outline-width'

      
        値:  

              <border-width> | inherit
            初期値:  

              medium
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual, interactive
            算出値:  

              絶対長さ、アウトラインスタイルが'none'場合は'0'
            
    

  
    'outline-style'

      
        値:  

              <border-style> | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual, interactive
            算出値:  

              指定値
            
    

  
    'outline-color'

      
        値:  

              <color> | invert | inherit
            初期値:  

              invert
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              visual, interactive
            算出値:  

              指定値
            
    

  アウトラインのプロパティで作成したアウトラインはボックスの"上"に描画される。すなわち、アウトラインは常に手前にあり、ボックスまたはその他のボックスの位置や大きさには影響しない。したがって、アウトラインの表示または抑制によって、リフローまたはオーバーフローは発生しない。

  アウトラインはボーダー辺のすぐ外側から描画される。

  アウトラインは、矩形でないかもしれない。たとえば、要素が複数行にまたがる場合、アウトラインはすべての要素ボックスを囲む最小のものとなる。ボーダーとは対照的に、アウトラインは行ボックスの先頭または末尾で開かれていないが、可能であれば、常に完全に接続される。

  'outline-width'プロパティは'border-width'と同じ値を受け入れる。

  'outline-style'プロパティは、'hidden'が正当なアウトラインスタイルでないことを除いて、'border-style'と同じ値を受け入れる。

  'outline-color'は、キーワード'invert'と同様にすべての色も受け入れる。'Invert'は画面上のピクセルの色の反転を実行することを期待する。これは、背景色に関係なくフォーカスのボーダーが可視であることを確認するための一般的なトリックである。

  適合ユーザーエージェントは、画面上のピクセルの色の反転をサポートしないプラットフォーム上の'invert'値を無視してよい。ユーザーエージェントが'invert'値をサポートしない場合、'outline-color'プロパティの初期値は'border-top-color'プロパティの初期値と類似する'color'プロパティの値となる。

  'outline'プロパティは簡略化プロパティで、'outline-style'、'outline-width'、'outline-color'の3つすべてを設定する。

  
    注。 アウトラインはすべての辺で同じである。ボーダーとは対照的に、'outline-top'や'outline-left'プロパティは存在しない。
  

  本仕様は、複数の重複するアウトラインが描画される方法や、またはどのようにアウトラインが他の要素の後ろに隠れているボックスの一部に描かれるかを定義しない。

  
    注。 アウトラインの整形（すなわち、スペースはボックスモデルで除去されない）には影響しないため、ページ上の他の要素と重なってよい。
  

  
    例:

    BUTTON要素の周囲に太いアウトラインを描画する例は次のとおり:
    
button { outline : thick solid}


    スクリプトは、リフローを起こすことなく、動的にアウトラインの幅を変更するために用いられてよい。
  

  18.4.1 アウトラインとフォーカス

  グラフィカルユーザインタフェースは、ページ上の要素がフォーカスを持つことをユーザーに伝えるために要素の周囲にアウトラインを使用してよい。これらのアウトラインは任意のボーダーに加えており、オンとオフのアウトラインを切り替えは、文書にリフローを引き起こすべきではない。フォーカスは、文書のユーザーとの対話の主体となる（たとえば、テキストを入力する、ボタンを選択する、など）。インタラクティブなメディアグループをサポートするユーザーエージェントは、フォーカスがどこにあるかを追跡しなければならず、また、フォーカスを表わさなければならない。これは、 :focus 疑似クラスと組み合わせて動的なアウトラインを使用して行なわれてよい。

  
    例:

    たとえば、フォーカス時に要素の周囲に太い黒線を、アクティブ時に太い赤線を描画するために、以下の規則が使用可能である:
    
:focus  { outline: thick solid black }
:active { outline: thick solid red }

  

  18.5 拡大表示

  CSSワーキンググループは、文書やその一部の拡大が、スタイルシートを使用して指定されるべきではないと考えている。ユーザーエージェントは、さまざまな方法でそのような拡大（たとえば、大きな画像、大きな音など）をサポートしている場合がある。

  ページを拡大するとき、ユーザーエージェントは配置された要素間の関係を維持すべきである。たとえば、漫画はオーバーレイテキスト要素と画像で構成されることがある。このページを拡大する場合、ユーザーエージェントは漫画の吹き出し内のテキストを保持すべきである。

  付録 A. 聴覚スタイルシート

  
    目次

    A.1 メディアタイプ'aural'および'speech'

      
        A.2 聴覚スタイルシートの手引き

        A.2.1 角度

          A.2.2 時間

          A.2.3 周波数
        

      A.3 音量プロパティ: 'volume'

      A.4 声のプロパティ: 'speak'

      A.5 区切りプロパティ: 'pause-before'、'pause-after'、'pause'

      A.6 合図のプロパティ: 'cue-before'、'cue-after'、'cue'

      A.7 ミキシングプロパティ: 'play-during'

      A.8 空間プロパティ: 'azimuth'、'elevation'

      A.9 音声特性プロパティ: 'speech-rate'、'voice-family'、'pitch'、'pitch-range'、'stress'、'richness'

      A.10 話法プロパティ: 'speak-punctuation'、'speak-numeral'

      
        A.11 テーブルの音声レンダリング

        A.11.1 ヘッダの話法: 'speak-header'プロパティ
        

      A.12 HTMLのサンプルスタイルシート

      A.13 Emacspeak
    

  この章は参考情報である。CSS 2.1に準拠するために、ユーザーエージェントはこの章のプロパティの実装を必要としない。

  A.1 メディアタイプ'aural'および'speech'

  我々は、CSSの将来のレベルでの音声出力のために定義される新しいプロパティと値の存在を期待している。したがって、CSS 2.1は'speech'メディアタイプ（7章メディアタイプを参照）​​を予約するが、今までのところどのプロパティが'speech'に適用するのか、しないのかを定義しない。

  この付録のプロパティは、CSS2で導入されたメディアタイプ'aural'に適用される。 'aural'は現在非推奨である。

  
    つまり、このようなスタイルシート
    
@media speech {
  body { voice-family: Paul }
}


    は妥当だが、その意味はCSS 2.1で定義されない。一方
    
@media aural {
  body { voice-family: Paul }
}


    は非推奨であるが、この付録で定義される。
  

  A.2 聴覚スタイルシートの手引き

  すでに視覚障碍者のコミュニティで一般的に使用されている文書の聴覚レンダリングは、音声合成と"聴覚アイコン" を組み合わせたものである。このような聴覚表現はたいてい、文書をプレーンテキストに変換し、これをスクリーンリーダー（単に画面上のすべての文字を読み込むソフトウェアまたはハードウェア）に供給することによって起こる。文書構造が保持された場合に比べ、効果がより少ない表現となる。聴覚表現のスタイルシートのプロパティは、視覚プロパティと一緒に（混合メディア）、または視覚表現の音声代替として使用してよい。

  明らかなアクセシビリティの利点に加え、車載用、工業用および医療用文書システム（イントラネット）、ホームエンターテイメント、読みの学習や読むことが困難な人を支援するなどの情報を聞くことに対する大きな市場が存在する。

  聴覚プロパティを使用する場合、キャンバスは3次元物理空間（音を囲む）と時間空間（別の音の前、間、後の音を指定する）で構成される。またCSSプロパティは、著者が合成音声（音声の種類、周波数、抑揚など）の質を変化させることができる。

  
    例:
    
h1, h2, h3, h4, h5, h6 {
    voice-family: paul;
    stress: 20;
    richness: 90;
    cue-before: url("ping.au")
}
p.heidi { azimuth: center-left }
p.peter { azimuth: right }
p.goat  { volume: x-soft }


    これは、平らなトーンだが非常に声の大きい"paul"と呼ばれる声（ある種の"音声フォント"のようなもの）でヘッダを話すようスピーチシンセサイザーに指示する。ヘッダを話す前に、与えられたURLの音声サンプルを再生する。クラス"heidi"の段落は、左前から（サウンドシステムが空間オーディオに対応している場合）、およびクラス"ピーター"段落が右から聞こえてくる。クラス"goat"の段落は、非常に静かな出力となる。
  

  A.2.1 角度

  角度の値は、テキスト内の<angle>で表される。その形式は、<number>の直後に角度の単位識別子が続くものとなる。

  角度の単位識別子は次のとおり:

  deg: 度

    grad: グラッド

    rad: ラジアン
  角度の値は負であってもよい。ユーザエージェントは-360degの範囲に正規化すべきである。たとえば、-10degと350degは等価である。

  たとえば、右の角度は'90deg'、'100grad'または'1.570796326794897rad'となる。

  <length>のように、値がゼロの場合、単位は省略してよい: '0deg'は'0'として書かれてよい。

  A.2.2 時間

  時間の値は、テキスト内の<time>で表される。その形式は、<number>の直後に時間の単位識別子が続くものとなる。

  時間の単位識別子は次のとおり:

  ms: ミリ秒

    s: 秒
  時間の値は負であってはならない。

  <length>のように、値がゼロの場合、単位は省略してよい: '0s'は'0'として書かれてよい。

  A.2.3 周波数

  周波数の値は、テキスト内の<frequency>で表される。その形式は、<number>の直後に周波数の単位識別子が続くものとなる。

  周波数の単位識別子は次のとおり:

  Hz: ヘルツ

    kHz: キロヘルツ
  周波数の値は負であってはならない。

  たとえば、200Hzは低音域、6kHzは高音域を表す。

  <length>のように、値がゼロの場合、単位は省略してよい: '0Hz'は'0'として書かれてよい。

  A.3 音量プロパティ: 'volume'

  
    'volume'

      
        値:  

              <number> | <percentage> | silent | x-soft | soft | medium | loud | x-loud | inherit
            初期値:  

              medium
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              継承値を参照
            メディア:  

              aural
            算出値:  

              数値
            
    

  音量は、波形の中央値を参照する。言い換えれば、50の音量で大きな抑揚をつけた声は、50より上にピークがあるかもしれない。全体的な値は、たとえば物理ボリューム制御（比例的に0と100の両方の値を増加する）とともに、快適さという点においては、人間が調整可能になるだろう。このプロパティは単にダイナミックレンジを調整する。

  値の意味は次のとおり:

  <number>

    '0'以上'100'以下の任意の数値。'0'は最小可聴音量レベルを表し、100は最大快適音量レベルに対応する。

    <percentage>

    パーセント値は継承値に対する相対値として計算された後、範囲'0'から'100'に切り取られる。

    silent

    まったくの無音。'0'は'silent'と等価という意味ではない。

    x-soft

    '0'と等価。

    soft

    '25'と等価。

    medium

    '50'と等価。

    loud

    '75'と等価。

    x-loud

    '100'と等価。
  ユーザエージェントは、'0'と'100'に対応する値をリスナーによって設定できるようにすべきである。普遍的に適用できる設定はない。適切な値は、使用中の機器（スピーカー、ヘッドホン）、環境（車内、ホームシアター、図書館）および個人の好みに依存する。いくつかの例を挙げる:

  車載用ブラウザでは、雑音だらけの場合の設定がある。'0'はかなり高いレベルに、'100'は非常に高いレベルに変換される。音声は道路の騒音より大きく簡単に聞き取れるが、全体的なダイナミックレンジは圧縮される。優れた遮音性をもつ車はより広いダイナミックレンジを可能にするかもしれない。

    他の音声ブラウザは、夜遅くのアパートまたは共有の研究室で使用されている。'0'は非常に静かなレベル、'100'もかなり静かなレベルに設定される。最初の例と同様に、変化量は低く、ダイナミックレンジは縮小する。実音量は最初の例で高かったのに対し、ここで低くなる。

    静かな一軒家の中で、高価なハイファイホームシアターの設定。'0'はかなり低く、'100'は非常に高く設定される。広いダイナミックレンジとなる。
  同じ著者スタイルシートは、適切にクライアント側で'0'と'100'ポイントを単純に変換することによって、あらゆる場合に使用することができる。

  A.4 声のプロパティ: 'speak'

  
    'speak'

      
        値:  

              normal | none | spell-out | inherit
            初期値:  

              normal
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  このプロパティは、テキストを聴覚系でレンダリングするのかどうか、するならば、どのような方法でするのかを指定する。可能な値は以下の通り:

  none

    要素はレンダリングする時間を必要としないように音声レンダリングを抑制する。ただし、その子孫はこの値を上書きしてよく、その場合出力される。（確実に要素とその子孫の描画を抑制するには、'display'プロパティを使用する）。

    normal

    要素とその子要素をレンダリングするために言語依存の発音規則を使用する。

    spell-out

    1回にテキスト1文字を綴る（頭字語や略語に役立つ）。
  'volume'プロパティが'silent'の値を持つ要素と'speak'プロパティが'none'を持つ要素との違いに注意する。前者は、それが要素の前と後に一時停止を含めて、語られたかのように同じ時間をとるが、音は生成されない。後者は時間を必要とせずレンダリングされない（たとえ子孫があるとしても）。

  A.5 区切りプロパティ: 'pause-before'、'pause-after'、'pause'

  
    'pause-before'

      
        値:  

              <time> | <percentage> | inherit
            初期値:  

              0
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              文を参照
            メディア:  

              aural
            算出値:  

              時間
            
    

  
    'pause-after'

      
        値:  

              <time> | <percentage> | inherit
            初期値:  

              0
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              文を参照
            メディア:  

              aural
            算出値:  

              時間
            
    

  これらのプロパティは要素の内容を話す前（または後）に気づかれるための休止を指定する。値の意味は次のとおり:

  注。 CSS3でpauseは、cueと内容の間でなく周囲に挿入される。詳細は[CSS3SPEECH]を参照のこと。

  <time>

    絶対時間単位（秒およびミリ秒）で休止を表す。

    <percentage>

    'speech-rate'プロパティ値の逆数を指す。たとえば、音声速度が毎分120単語（すなわち、1単語あたり0.5秒もしくは500ミリ秒）である場合、100%の'pause-before'は500ミリ秒で、 20%の'pause-before'は100ミリ秒の休止を意味する。
  休止は、要素の内容と任意の'cue-before'または'cue-after'の内容の間に挿入される。

  著者は、音声速度の大きな変化にかかわらずより堅牢なスタイルシートを作成するために相対単位を使用すべきである。

  
    'pause'

      
        値:  

              [ [<time> | <percentage>]{1,2} ] | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              'pause-before'および'pause-after'の記述を参照
            メディア:  

              aural
            算出値:  

              個々のプロパティを参照
            
    

  'pause'プロパティは'pause-before'と'pause-after'の省略形である。2つの値が指定された場合、最初の値は'pause-before'で、2番目は'pause-after'である。1つの値のみが指定された場合、両方のプロパティに適用される。

  
    例:
    
h1 { pause: 20ms } /* pause-before: 20ms; pause-after: 20ms */
h2 { pause: 30ms 40ms } /* pause-before: 30ms; pause-after: 40ms */
h3 { pause-after: 10ms } /* pause-before未指定; pause-after: 10ms */

  

  A.6 合図のプロパティ: 'cue-before'、'cue-after'、'cue'

  
    'cue-before'

      
        値:  

              <uri> | none | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              絶対URIまたは'none'
            
    

  
    'cue-after'

      
        値:  

              <uri> | none | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              絶対URIまたは'none'
            
    

  聴覚アイコンは、セマンティックな要素を区別する別の方法がある。音は前と後の両方またはいずれか一方で区切る要素を再生されてよい。値の意味は次のとおり:

  <uri>

    URIは聴覚アイコンのリソースを明示しなければならない。URIが画像など音声ファイル以外の何かに解決する場合、リソースは無視され、あたかも値が'none'をなかったかのようにプロパティを扱うべきである。

    none

    聴覚アイコンを指定しない。
  
    例:
    
a {cue-before: url("bell.aiff"); cue-after: url("dong.wav") }
h1 {cue-before: url("pop.au"); cue-after: url("pop.au") }

  

  
    'cue'

      
        値:  

              [ <'cue-before'> || <'cue-after'> ] | inherit
            初期値:  

              個々のプロパティを参照
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              個々のプロパティを参照
            
    

  'cue'プロパティは設定'cue-before'および'cue-after'の設定を簡略化したものである。2つの値が指定された場合、最初の値は'cue-before'で、2番目は'pause-after'である1つの値のみが指定された場合、両方のプロパティに適用される。

  
    例:
    次の2つの規則は等価である:
    
h1 {cue-before: url("pop.au"); cue-after: url("pop.au") }
h1 {cue: url("pop.au") }

  

  ユーザエージェントが聴覚アイコンをレンダリングできない（たとえば、ユーザー環境が許可しない）場合は、別の合図を生成することを推奨する。

  他の内容生成技術については、:beforeおよび:after疑似要素の節を参照のこと。'cue-before'の音と'pause-before'の空白は':before'疑似要素より内容の前に挿入される。同様に、'pause-after'の空白と'cue-after'の音は':after'疑似要素より内容の後に挿入される。

  A.7 ミキシングプロパティ: 'play-during'

  
    'play-during'

      
        値:  

              <uri> [ mix || repeat ]? | auto | none | inherit
            初期値:  

              auto
            適用対象:  

              すべての要素
            継承:  

              no
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              絶対URI、残りは指定値
            
    

  'cue-before'と'cue-after'プロパティと同様に、このプロパティは要素の内容が話される間にバックグラウンドとして再生する音を指定する。値の意味は次のとおり:

  <uri>

    要素の内容が話される間にこの<uri>によって指定された音がバックグラウンドとして再生される。

    mix

    存在する場合、このキーワードは、親要素の'play-during'プロパティから継承した音が再生され続け、<uri>によって指定された音と混合されることを意味する。'mix'が指定されていない場合、要素のバックグラウンド音は親を置き換える。

    repeat

    存在する場合、このキーワードは、要素の全体の期間を埋めるために音が短すぎる場合繰り返されることを意味する。そうでなければ、音は一度再生し、その後停止する。これは、'background-repeat'プロパティに似ている。音が要素に対して長すぎる場合、要素が話された後切り取られる。

    auto

    親要素の音を再生し続ける（このプロパティが継承されていた場合のように、頭から始まらない）。

    none

    このキーワードは、沈黙があることを意味する。親要素の音が（もしあれば）現在の要素の間は静かであり、現在の要素の後に続ける。
  
    例:
    
blockquote.sad { play-during: url("violins.aiff") }
blockquote Q   { play-during: url("harp.wav") mix }
span.quiet     { play-during: none }

  

  A.8 空間プロパティ: 'azimuth'、'elevation'

  空間的な音声は聴覚プレゼンテーションのための重要なスタイルのプロパティである。それは（人々はほとんどすべての部屋で同じ場所に立っていない）実際の生活のように、離れて複数の声を伝えるために自然な方法を提供する。ステレオスピーカーは、左右の音響舞台を生成する。ステレオヘッドフォンや、ますます人気の5スピーカーホームシアターは、完全なサラウンドサウンドを生成することができ、マルチスピーカーは、真の3次元の音響舞台を作成できる。 VRML 2.0はまた、やがて消費者の手の届く空間オーディオハードウェアがより広く利用できるようになることを暗示する空間オーディオを含む。

  
    'azimuth'

      
        値:  

              <angle> | [[ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards | inherit
            初期値:  

              center
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              規格化した角度
            
    

  値の意味は次のとおり:

  <angle>

    位置は'360deg'から'-360deg'までの範囲内の角度を単位として記述される。値'0deg'は、サウンドステージの中央の真正面を意味する。'90deg'は右、'180deg'は背後、'270deg'（または、同等だが使いやすい'-90deg'）は左となる。

    left-side

    '270deg'と等価。'behind'が付く場合は'270deg'と等価。

    far-left

    '300deg'と等価。'behind'が付く場合は'240deg'と等価。

    left

    '320deg'と等価。'behind'が付く場合は'220deg'と等価。

    center-left

    '340deg'と等価。'behind'が付く場合は'200deg'と等価。

    center

    '0deg'と等価。'behind'が付く場合は'180deg'と等価。

    center-right

    '20deg'と等価。'behind'が付く場合は'160deg'と等価。

    right

    '40deg'と等価。'behind'が付く場合は'140deg'と等価。

    far-right

    '60deg'と等価。'behind'が付く場合は'120deg'と等価。

    right-side

    '90deg'と等価。'behind'が付く場合は'90deg'と等価。

    leftwards

    現在の角度に対して相対的に、左に音を移動する。より正確には、20度を減算する。演算は360度を法として実施される。たとえ継承された方位角が既にリスナーの後ろにある場合（この場合、音が実際には右に移動するように聞こえる）でも、常に20度を減算するため、'leftwards'はより正確には"反時計回りに移動する"と説明されることに注意する。

    rightwards

    現在の角度に対して相対的に右に音を移動する。より正確には、20度を加算する。算術演算については'leftwards'を参照のこと。
  このプロパティは、異なるボリュームに別のチャンネルに同じ信号を混合することによって実装される可能性が最も高い。また、サウンドステージのような錯覚を提供するために、デジタル遅延、および他のそのような記述を位相シフトを使用することもあるだろう。この効果と行うために使用スピーカーの数を達成するために使用される正確な手段は、ユーザエージェントに依存する。このプロパティは、単に期待する最終結果を特定する。

  
    例:
    
h1   { azimuth: 30deg }
td.a { azimuth: far-right }          /*  60deg */
#12  { azimuth: behind far-right }   /* 120deg */
p.comment { azimuth: behind }        /* 180deg */

  

  空間的方位角が指定され、出力装置が聴取位置の背後に音を出すことができない場合、ユーザエージェントは転送半球の値に後方半球内の値を変換すべきである。1つの方法は次のとおり:

  90deg < x <= 180deg ならば x := 180deg - x

    180deg < x <= 270deg ならば x := 540deg - x
  
    'elevation'

      
        値:  

              <angle> | below | level | above | higher | lower | inherit
            初期値:  

              level
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              規格化した角度
            
    

  このプロパティの値の意味は次のとおり:

  <angle>

    '-90deg'と'90deg'の間の角度として仰角を指定する。'0deg'は、大まかにリスナーと一緒の高さで、前方に水平を意味する。'90deg'は真上を意味し、'-90deg'は真下を意味する。

    below

    '-90deg'と等価。

    level

    '0deg'と等価。

    above

    '90deg'と等価。

    higher

    現在の仰角に10度加算する。

    lower

    現在の仰角から10度減算する。
  この効果は、そうするために使用されるスピーカーの数を達成するために使用される正確な手段は未定義である。このプロパティは、単に期待する最終結果を特定する。

  
    例:
    
h1   { elevation: above }
tr.a { elevation: 60deg }
tr.b { elevation: 30deg }
tr.c { elevation: level }

  

  A.9 音声特性プロパティ: 'speech-rate'、'voice-family'、'pitch'、'pitch-range'、'stress'、'richness'

  
    'speech-rate'

      
        値:  

              <number> | x-slow | slow | medium | fast | x-fast | faster | slower | inherit
            初期値:  

              medium
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              数値
            
    

  このプロパティは、発話速度を指定する。絶対と相対の両方のキーワード値が許可されていることに注意する（'font-size'と比較）。値の意味は次のとおり:

  <number>

    分あたりの単語の発話速度、言語によって多少異なるが、それにもかかわらず、広く音声合成装置でサポートされている量を指定する。

    x-slow

    毎分80語と同じ。

    slow

    毎分120語と同じ。

    medium

    毎分180-200語と同じ。

    fast

    毎分300語と同じ。

    x-fast

    毎分500語と同じ。

    faster

    現在の速度に毎分40語を加算する。

    slower

    現在の速度から毎分40語を減算する。
  
    'voice-family'

      
        値:  

              [[<specific-voice> | <generic-voice> ],]* [<specific-voice> | <generic-voice> ] | inherit
            初期値:  

              ユーザーエージェントに依存
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  値はボイスファミリ名の優先順位をコンマ区切りにしたリストである（'font-family'と比較）。値の意味は次のとおり:

  <generic-voice>

    値はボイスファミリである。利用可能な値は'male'、'female'、'child'である。

    <specific-voice>

    値は具体的な例となる（たとえば、comedian、trinoids、carlos、lani）。
  
    例:
    
h1 { voice-family: announcer, male }
p.part.romeo  { voice-family: romeo, male }
p.part.juliet { voice-family: juliet, female }

  

  特定の声の名前は引用符で囲んでよく、名前を構成する単語のいずれかの識別子の構文規則に準拠していない場合、実際に引用符で囲まなければならない。また、複数の単語から成る名前を持つ特定の声を引用符でくくることを推奨する。引用符が省略された場合、ボイスファミリ名の前後にある任意の空白文字は無視され、ボイスファミリ名内の空白文字の任意のシーケンスは、単一の空白に変換される。

  
    'pitch'

      
        値:  

              <frequency> | x-low | low | medium | high | x-high | inherit
            初期値:  

              medium
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              frequency
            
    

  話し声の平均ピッチ（周波数）を指定する。音声の平均ピッチはボイスファミリに依存する。たとえば、標準的な男性の声の平均ピッチは120Hz程度であるが、女性の声は約210Hzとなる。

  値の意味は次のとおり:

  <frequency>

    ヘルツ（Hz）で話し声の平均ピッチを指定する。

    x-low, low, medium, high, x-high

    これらの値はボイスファミリに依存しているため、絶対的な周波数に対応していない。ユーザエージェントは音声ファミリとユーザーの環境に基づいて適切な周波数にこれらの値を変換しなければならない。ただし、ユーザーエージェントは順序正しくこれらの値を変換しなければならない（すなわち、 'x-low'は'low'より低い周波数となるなど）。
  
    'pitch-range'

      
        値:  

              <number> | inherit
            初期値:  

              50
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  平均的なピッチの変化を指定します。人間の声の知覚ピッチは基本周波数によって決定され、一般的に女性の声の男性の声と210Hzのために120Hzの値を持っています。人間の言語は抑揚やピッチを変化させて話されて、これらの変化は、追加の意味と強調を伝える。したがって、非常にアニメーション、音声、すなわち、大きく抑揚されているものは、高ピッチの範囲を表示する。このプロパティは、変動が発生する範囲、すなわち、どのくらい基本周波数の平均ピッチから外れるかを指定する。

  値の意味は次のとおり:

  <number>

    '0 'と'100'の間の値。 '0'のピッチの範囲は、フラットで単調な音声を生成する。 50のピッチの範囲は、通常の抑揚を生成する。50以上のピッチの範囲は、生き生きとした声を生成する。
  
    'stress'

      
        値:  

              <number> | inherit
            初期値:  

              50
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  音声のイントネーション曲線における"局所ピーク"の高さを指定する。たとえば、英語はアクセント言語であり、文の異なる部分は、第1、第2、第3アクセントが割り当てられる。'stress'の値はこれらのアクセント標識に由来する抑揚の量を制御する。このプロパティは、'pitch-range''プロパティと対をなし、開発者がハイエンド聴覚表現を活用可能にするために提供される。

  値の意味は次のとおり:

  <number>

    '0 'と'100'の間の値。 値の意味は、話される言語によって異なる。たとえば、'50'の標準レベルで、通常のイントネーションと強調で話す標準英語を話す男性の声（平均ピッチ=122Hz）とイタリア語では'50'は異なる意味を持つだろう。
  
    'richness'

      
        値:  

              <number> | inherit
            初期値:  

              50
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  話す声の豊かさや、明るさを指定する。豊かな声はスムーズな声ではないが、大きな部屋で"伝わる"。（用語"スムーズ"は描画された場合に波形がどのように見えるかを指す。）

  値の意味は次のとおり:

  <number>

    '0 'と'100'の間の値。 値が大きいほど、声が伝わるだろう。低い値は、軽くて流暢な声を生成する。
  A.10 話法プロパティ: 'speak-punctuation'、 'speak-numeral'

  追加の音声プロパティ、'speak-header'は以下に記載される。

  
    'speak-punctuation'

      
        値:  

              code | none | inherit
            初期値:  

              none
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  このプロパティは、句読点を伝える方法を指定する。値の意味は次のとおり:

  code

    セミコロン、括弧などの句読点を文字通り伝える。

    none

    句読点は伝えず、代わりに多彩な一時停止によって自然にレンダリングする。
  
    'speak-numeral'

      
        値:  

              digits | continuous | inherit
            初期値:  

              continuous
            適用対象:  

              すべての要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  このプロパティは、数字を伝える方法を制御する。値の意味は次のとおり:

  digits

    個々の数字として数字を伝える。したがって、"237"を"に・さん・なな"と伝える。

    continuous

    完全な数として数字を伝える。したがって、"237"を"にひゃくさんじゅうなな"と伝える。単語の表現は言語に依存する。
  A.11 テーブルの音声レンダリング

  テーブルを音声ジェネレータによって伝える場合、データセルとヘッダセルの関係は水平方向と垂直方向の配置によっては異なる方法で表現しなければならない。一部の音声ブラウザは、ユーザが2次元空間内を移動することを可能にし、セルを空間的に表現された関係を変換する機会を与える。それができない場合、スタイルシートがどの時点でヘッダを伝えるかを指定しなければならない。

  A.11.1 ヘッダの話法: 'speak-header'プロパティ

  
    'speak-header'

      
        値:  

              once | always | inherit
            初期値:  

              once
            適用対象:  

              テーブルヘッダ情報を持つ要素
            継承:  

              yes
            パーセンテージ:  

              利用不可
            メディア:  

              aural
            算出値:  

              指定値
            
    

  このプロパティは、テーブルヘッダはすべてのセルの前にのみ、またはそのセルが前のセルと異なるヘッダに関連付けられているセルの前に伝えるかどうかを指定する。値の意味は次のとおり:

  once

    ヘッダは、一連のセルの前に、一度伝えられる。

    always

    ヘッダはすべての適切なセルの前に伝えられる。
  各文書言語は、著者がヘッダを指定することができる異なるメカニズムを持ってよい。たとえば、HTML4で（[HTML4]）、3つの異なる属性（"headers"、 "scope"、"axis"）でヘッダ情報を指定することが可能であり、仕様では、これらの属性が指定されていない時にヘッダ情報を決定するアルゴリズムを与える。

  
    
         [説明]

      ヘッダとそれに対応するデータが違う行・列に含まれているテーブル
    

    このHTMLの例は、数日間の2つの場所（サンノゼとシアトル）で食事、ホテル、交通費を提示する。概念的には、n次元空間の観点からテーブルと考えることができる。この空間ヘッダは場所、日、カテゴリ、および小計となる。一部のセルは軸に沿ってマークを定義する一方、他はこの空間内の点で費用を与える。このテーブルのマークアップは以下の通り:
    
<TABLE>
<CAPTION>Travel Expense Report</CAPTION>
<TR>
  <TH></TH>
  <TH>Meals</TH>
  <TH>Hotels</TH>
  <TH>Transport</TH>
  <TH>subtotal</TH>
</TR>
<TR>
  <TH id="san-jose" axis="san-jose">San Jose</TH>
</TR>
<TR>
  <TH headers="san-jose">25-Aug-97</TH>
  <TD>37.74</TD>
  <TD>112.00</TD>
  <TD>45.00</TD>
  <TD></TD>
</TR>
<TR>
  <TH headers="san-jose">26-Aug-97</TH>
  <TD>27.28</TD>
  <TD>112.00</TD>
  <TD>45.00</TD>
  <TD></TD>
</TR>
<TR>
  <TH headers="san-jose">subtotal</TH>
  <TD>65.02</TD>
  <TD>224.00</TD>
  <TD>90.00</TD>
  <TD>379.02</TD>
</TR>
<TR>
  <TH id="seattle" axis="seattle">Seattle</TH>
</TR>
<TR>
  <TH headers="seattle">27-Aug-97</TH>
  <TD>96.25</TD>
  <TD>109.00</TD>
  <TD>36.00</TD>
  <TD></TD>
</TR>
<TR>
  <TH headers="seattle">28-Aug-97</TH>
  <TD>35.00</TD>
  <TD>109.00</TD>
  <TD>36.00</TD>
  <TD></TD>
</TR>
<TR>
  <TH headers="seattle">subtotal</TH>
  <TD>131.25</TD>
  <TD>218.00</TD>
  <TD>72.00</TD>
  <TD>421.25</TD>
</TR>
<TR>
  <TH>Totals</TH>
  <TD>196.27</TD>
  <TD>442.00</TD>
  <TD>162.00</TD>
  <TD>800.27</TD>
</TR>
</TABLE>


    このようにデータモデルを提供することにより、著者は豊富な方法で、たとえば、テーブルを探索するための音声対応 - ブラウザのためにそれが可能になり、各セルは、各データセルの前に適用されるヘッダを繰り返して、リストとして伝えることもできる:
    
  San Jose, 25-Aug-97, Meals:  37.74
  San Jose, 25-Aug-97, Hotels:  112.00
  San Jose, 25-Aug-97, Transport:  45.00
 ...


    ヘッダが変更する場合にのみ、ブラウザがヘッダを伝えることもできる:
    
San Jose, 25-Aug-97, Meals: 37.74
    Hotels: 112.00
    Transport: 45.00
  26-Aug-97, Meals: 27.28
    Hotels: 112.00
...

  

  A.12 HTMLのサンプルスタイルシート

  このスタイルシートは、HTML 4の可能なレンダリングについて説明する:
  
@media aural {
h1, h2, h3, 
h4, h5, h6    { voice-family: paul, male; stress: 20; richness: 90 }
h1            { pitch: x-low; pitch-range: 90 }
h2            { pitch: x-low; pitch-range: 80 }
h3            { pitch: low; pitch-range: 70 }
h4            { pitch: medium; pitch-range: 60 }
h5            { pitch: medium; pitch-range: 50 }
h6            { pitch: medium; pitch-range: 40 }
li, dt, dd    { pitch: medium; richness: 60 }
dt            { stress: 80 }
pre, code, tt { pitch: medium; pitch-range: 0; stress: 0; richness: 80 }
em            { pitch: medium; pitch-range: 60; stress: 60; richness: 50 }
strong        { pitch: medium; pitch-range: 60; stress: 90; richness: 90 }
dfn           { pitch: high; pitch-range: 60; stress: 60 }
s, strike     { richness: 0 }
i             { pitch: medium; pitch-range: 60; stress: 60; richness: 50 }
b             { pitch: medium; pitch-range: 60; stress: 90; richness: 90 }
u             { richness: 0 }
a:link        { voice-family: harry, male }
a:visited     { voice-family: betty, female }
a:active      { voice-family: betty, female; pitch-range: 80; pitch: x-high }
}


  A.13 Emacspeak

  これは、Emacsエディタの音声サブシステムによって実装されるプロパティのリストである。

  voice-family

    stress（ただし、値の異なる範囲で）

    richness（ただし、値の異なる範囲で）

    pitch（ただし、異なる名前の値）

    pitch-range（ただし、値の異なる範囲で）
  (We thank T. V. Raman for the information about implementation status of aural properties.)

  付録 B. 参考文献一覧

  
    目次

    B.1 標準情報

      B.2 参考情報
    

  B.1 標準情報

  [COLORIMETRY]

    "Colorimetry", Third Edition, Commission Internationale de l'Eclairage, CIE Publication 15:2004, ISBN 3-901-906-33-9.
    Available at http://www.cie.co.at/publ/abst/15-2004.html

    [FLEX]

    "Flex: The Lexical Scanner Generator", Version 2.3.7, ISBN 1882114213.

    [HTML4]

    "HTML 4.01 Specification", D. Raggett, A. Le Hors, I. Jacobs, 24 December 1999.
    The latest version of the specification is available at http://www.w3.org/TR/html4/. The Recommendation defines three document type definitions: Strict, Transitional, and Frameset, all reachable from the Recommendation.

    [ICC42]

    Specification ICC.1:2004-10 (Profile version 4.2.0.0) Image technology colour management – Architecture, profile format, and data structure.
    Available at http://www.color.org/icc_specs2.html

    [ISO8879]

    "ISO 8879:1986(E): Information processing - Text and Office Systems - Standard Generalized Markup Language (SGML)", International Organization for Standardization (ISO), 15 October 1986.

    [ISO10646]

    "Information Technology - Universal Multiple- Octet Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane", ISO/IEC 10646-1:2003. Useful roadmap of the BMP and plane 1 documents show which scripts sit at which numeric ranges.

    [PNG]

    "Portable Network Graphics (PNG) Specification (Second Edition)", David Duce, ed., 10 November 2003.
    Available at http://www.w3.org/TR/PNG/.

    [RFC3986]

    "Uniform Resource Identifier (URI): Generic Syntax," T. Berners-Lee, R. Fielding, L. Masinter, January 2005.
    Available at http://www.ietf.org/rfc/rfc3986.

    [RFC2045]

    "Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies", N. Freed and N. Borenstein, November 1996.
    Available at http://www.ietf.org/rfc/rfc2045.txt. Note that this RFC obsoletes RFC1521, RFC1522, and RFC1590.

    [RFC2616]

    "HTTP Version 1.1 ", R. Fielding, J. Gettys, J. Mogul, et al., June 1999.
    Available at http://www.ietf.org/rfc/rfc2616.txt.

    [RFC2119]

    "Key words for use in RFCs to Indicate Requirement Levels", S. Bradner, March 1997.
    Available at http://www.ietf.org/rfc/rfc2119.txt.

    [RFC2318]

    "The text/css Media Type", H. Lie, B. Bos, C. Lilley, March 1998.
    Available at http://www.ietf.org/rfc/rfc2318.txt.

    [SRGB]

    IEC 61966-2-1 (1999-10) - "Multimedia systems and equipment - Colour measurement and management - Part 2-1: Colour management - Default RGB colour space - sRGB, ISBN: 2-8318-4989-6 - ICS codes: 33.160.60, 37.080 - TC 100 - 51 pp.
    Available at http://domino.iec.ch/webstore/webstore.nsf/artnum/025408

    [UAAG10]

    "User Agent Accessibility Guidelines 1.0." Ian Jacobs, Jon Gunderson, Eric Hansen (editors). 17 December 2002.
    Available at http://www.w3.org/TR/2002/REC-UAAG10-20021217

    [UAX9]

    "Unicode Bidirectional Algorithm", Mark Davis. (Unicode Standard Annex #9.) 27 September 2010.
    Available at http://www.unicode.org/reports/tr9/

    [UNICODE]

    The Unicode Consortium. The Unicode Standard, Version 6.0.0, (Mountain View, CA: The Unicode Consortium, 2011. ISBN 978-1-936213-01-6) and as updated from time to time by the publication of new versions. (See http://www.unicode.org/unicode/standard/versions/ for the latest version and additional information on versions of the standard and of the Unicode Character Database).
    Available at http://www.unicode.org/versions/Unicode6.0.0/

    [XML10]

    "Extensible Markup Language (XML) 1.0 (fifth edition)" T. Bray, J. Paoli, C.M. Sperberg-McQueen, Eve Maler, François Yergeau, editors, 26 November 2008.
    Available at http://www.w3.org/TR/REC-xml/.

    [YACC]

    "YACC - Yet another compiler compiler", S. C. Johnson, Technical Report, Murray Hill, 1975.
  B.2 参考情報

  [CHARSETS]

    Registered charset values. Download a list of registered charset values from http://www.iana.org/assignments/character-sets.

    [CSS1]

    "Cascading Style Sheets, level 1", H. W. Lie and B. Bos, 17 December 1996, revised 11 January 1999
    The latest version is available at http://www.w3.org/TR/CSS1

    [CSS2]

    "Cascading Style Sheets, level 2, CSS2 Specification", B. Bos, H. W. Lie, C. Lilley and I. Jacobs, 12 May 1998 (revised 11 April 2008),http://www.w3.org/TR/2008/REC-CSS2-20080411/

    [CSS3COLOR]

    "CSS3 Color Module," Tantek Çelik, Chris Lilley, 28 October 2010, W3C Proposed Recommendation. Available at http://www.w3.org/TR/2010/PR-css3-color-20101028/

    [CSS3LIST]

    "CSS3 module: lists," Tantek Çelik, Ian Hickson, 7 November 2002, W3C working draft (work in progress). Available at http://www.w3.org/TR/2002/WD-css3-lists-20021107

    [CSS3SEL]

    "Selectors", D. Glazman, T. Çelik, I. Hickson, 15 December 2009
    Available at http://www.w3.org/TR/2009/PR-css3-selectors-20091215/

    [CSS3SPEECH]

    "CSS3 Speech Module", David Raggett, Daniel Glazman, Claudio Santambrogio, Daniel Weck, 19 April 2011, W3C Working Draft (work in progress). Available at http://www.w3.org/TR/2011/WD-css3-speech-20110419/

    [DOM-LEVEL-3-CORE]

    "Document Object Model (DOM) Level 3 Core Specification", A. Le Hors, P. Le Hégaret, et al. (eds.), 7 April 2004, W3C Recommendation. Available at http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/.

    [MATH30]

    "Mathematical Markup Language (MathML) Version 3.0", D. Carlisle, P. Ion, R. Miner, 21 October 2010
    Available at http://www.w3.org/TR/2010/REC-MathML3-20101021/

    [MEDIAQ]

    "Media Queries", Håkon Wium Lie, Tantek Çelik, Daniel Glazman, Anne van Kesteren, 27 July 2010
    (Work in progress.) Available at http://www.w3.org/TR/2010/CR-css3-mediaqueries-20100727/

    [P3P]

    "The Platform for Privacy Preferences 1.0 (P3P1.0) Specification", L. Cranor, M. Langheinrich, M. Marchiori, M. Presler-Marshall, J. Reagle, 16 April 2002
    Available at http://www.w3.org/TR/2002/REC-P3P-20020416

    [BCP47]

    "Tags for Identifying Languages", A. Phillips, M. Davis, September 2009.
    Available at http://www.rfc-editor.org/rfc/bcp/bcp47.txt.

    [SVG11]

    "Scalable Vector Graphics (SVG) 1.1 Specification", J. Ferraiolo, et.al. 14 January 2003
    Available at http://www.w3.org/TR/2003/REC-SVG11-20030114

    [WVAG20]

    "Web Content Accessibility Guidelines (WCAG) 2.0", Ben Caldwell, Michael Cooper, Loretta Guarino Reid, Gregg Vanderheiden, 11 December 2008.
    Available at: http://www.w3.org/TR/2008/REC-WCAG20-20081211/.

    [XHTML]

    "XHTML 1.0 The Extensible HyperText Markup Language", various authors,
    Available at: http://www.w3.org/TR/xhtml1/.

    [XMLID]

    "xml:id Version 1.0", J. Marsh, D. Veillard N. Walsh, 9 September 2005, W3C Recommendation. Available at: http://www.w3.org/TR/2005/REC-xml-id-20050909/.

    [XMLNAMESPACES]

    "Namespaces in XML 1.0 (third edition)", T. Bray, D. Hollander, A. Layman, R. Tobin, H. S. Thompson, 8 December 2009
    Available at: http://www.w3.org/TR/2009/REC-xml-names-20091208/.
  
  付録 C. 変更点

  
    目次

    
        C.1 Additional property values

        C.1.1 Section 4.3.6 Colors

          C.1.2 Section 9.2.4 The 'display' property

          C.1.3 Section 12.2 The 'content' property

          C.1.4 Section 16.6 White space: the 'white-space' property

          C.1.5 Section 18.1 Cursors: the 'cursor' property
        

      
        C.2 Changes

        C.2.1 Section 1.1 CSS 2.1 vs CSS 2

          C.2.2 Section 1.2 Reading the specification

          C.2.3 Section 1.3 How the specification is organized

          C.2.4 Section 1.4.2.1 Value

          C.2.5 Section 1.4.2.6 Media groups

          C.2.6 Section 1.4.2.7 Computed value

          C.2.7 Section 1.4.4 Notes and examples

          C.2.8 Section 1.5 Acknowledgments

          C.2.9 Section 3.2 Conformance

          C.2.10 Section 3.3 Error Conditions

          C.2.11 Section 4.1.1 Tokenization

          C.2.12 Section 4.1.3 Characters and case

          C.2.13 Section 4.2 Rules for handling parsing errors

          C.2.14 Section 4.3 Values

          C.2.15 Section 4.3.2 Lengths

          C.2.16 Section 4.3.4 URLs and URIs

          C.2.17 Section 4.3.5 Counters

          C.2.18 Section 4.3.6 Colors

          C.2.19 Section 4.3.8 Unsupported Values

          C.2.20 Section 4.4 CSS style sheet representation

          C.2.21 Section 5.8.1 Matching attributes and attribute values

          C.2.22 Section 5.8.3 Class selectors

          C.2.23 Section 5.9 ID selectors

          C.2.24 Section 5.10 Pseudo-elements and pseudo-classes

          C.2.25 Section 5.11.2 The link pseudo-classes: :link and :visited

          C.2.26 Section 5.11.4 The language pseudo-class: :lang

          C.2.27 Section 5.12.1 The :first-line pseudo-element

          C.2.28 Section 5.12.2 The :first-letter pseudo-element

          C.2.29 Section 6.1 Specified, computed, and actual values

          C.2.30 Section 6.4.1 Cascading order

          C.2.31 Section 6.4.3 Calculating a selector's specificity

          C.2.32 Section 6.4.4 Precedence of non-CSS presentational hints

          C.2.33 Section 7.3 Recognized Media Types

          C.2.34 Section 7.3.1 Media Groups

          C.2.35 Section 8.3 Margin properties

          C.2.36 Section 8.3.1 Collapsing margins

          C.2.37 Section 8.4 Padding properties

          C.2.38 Section 8.5.2 Border color

          C.2.39 Section 8.5.3 Border style

          C.2.40 Section 8.6 The box model for inline elements in bidirectional context

          C.2.41 Section 9.1.2 Containing blocks

          C.2.42 Section 9.2.1.1 Anonymous block boxes

          C.2.43 Section 9.2.2.1 Anonymous inline boxes

          C.2.44 Section 9.2.3 Run-in boxes

          C.2.45 Section 9.2.4 The 'display' property

          C.2.46 Section 9.3.1 Choosing a positioning scheme

          C.2.47 Section 9.3.2 Box offsets

          C.2.48 Section 9.4.1 Block formatting contexts

          C.2.49 Section 9.4.2 Inline formatting context

          C.2.50 Section 9.4.3 Relative positioning

          C.2.51 Section 9.5 Floats

          C.2.52 Section 9.5.1 Positioning the float

          C.2.53 Section 9.5.2 Controlling flow next to floats

          C.2.54 Section 9.7 Relationships between 'display', 'position', and 'float'

          C.2.55 Section 9.9 Layered presentation

          C.2.56 Section 9.10 Text direction

          C.2.57 Chapter 10 Visual formatting model details

          C.2.58 Section 10.1 Definition of "containing block"

          C.2.59 Section 10.2 Content width

          C.2.60 Section 10.3 Calculating widths and margins

          C.2.61 Section 10.3.2 Inline, replaced elements

          C.2.62 Section 10.3.3 Block-level, non-replaced elements in normal flow

          C.2.63 Section 10.3.4 Block-level, replaced elements in normal flow

          C.2.64 Section 10.3.5 Floating, non-replaced elements

          C.2.65 Section 10.3.6 Floating, replaced elements

          C.2.66 Section 10.3.7 Absolutely positioned, non-replaced elements

          C.2.67 Section 10.3.8 Absolutely positioned, replaced elements

          C.2.68 Section 10.4 Minimum and maximum widths

          C.2.69 Section 10.5 Content height

          C.2.70 Section 10.6 Calculating heights and margins

          C.2.71 Section 10.6.1 Inline, non-replaced elements

          C.2.72 Section 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, 'inline-block' replaced elements in normal flow and floating replaced elements

          C.2.73 Section 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'

          C.2.74 Section 10.6.4 Absolutely positioned, non-replaced elements

          C.2.75 Section 10.6.5 Absolutely positioned, replaced elements

          C.2.76 Section 10.7 Minimum and maximum heights

          C.2.77 Section 10.8 Line height calculations

          C.2.78 Section 10.8.1 Leading and half-leading

          C.2.79 Section 11.1 Overflow and clipping

          C.2.80 Section 11.1.1 Overflow

          C.2.81 Section 11.1.2 Clipping: the 'clip' property

          C.2.82 Section 11.2 Visibility

          C.2.83 Chapter 12 Generated content, automatic numbering, and lists

          C.2.84 Section 12.1 The :before and :after pseudo-elements

          C.2.85 Section 12.2 The 'content' property

          C.2.86 Section 12.3.2 Inserting quotes with the 'content' property

          C.2.87 Section 12.4 Automatic counters and numbering

          C.2.88 Section 12.4.1 Nested counters and scope

          C.2.89 Section 12.5 Lists

          C.2.90 Section 12.5.1 Lists

          C.2.91 Chapter 13 Paged media

          C.2.92 Section 13.2.2 Page selectors

          C.2.93 Section 13.3.1 Page break properties

          C.2.94 Section 13.3.3 Allowed page breaks

          C.2.95 Section 14.2.1 Background properties

          C.2.96 Section 14.3 Gamma correction

          C.2.97 Chapter 15 Fonts

          C.2.98 Section 15.2 Font matching algorithm

          C.2.99 Section 15.2.2 Font family

          C.2.100 Section 15.5 Small-caps

          C.2.101 Section 15.6 Font boldness

          C.2.102 Section 15.7 Font size

          C.2.103 Chapter 16 Text

          C.2.104 Section 16.2 Alignment

          C.2.105 Section 16.3.1 Underlining, over lining, striking, and blinking

          C.2.106 Section 16.4 Letter and word spacing

          C.2.107 Section 16.5 Capitalization

          C.2.108 Section 16.6 White space

          C.2.109 Chapter 17 Tables

          C.2.110 Section 17.2 The CSS table model

          C.2.111 Section 17.2.1 Anonymous table objects

          C.2.112 Section 17.4 Tables in the visual formatting model

          C.2.113 Section 17.4.1 Caption position and alignment

          C.2.114 Section 17.5 Visual layout of table contents

          C.2.115 Section 17.5.1 Table layers and transparency

          C.2.116 Section 17.5.2.1 Fixed table layout

          C.2.117 Section 17.5.2.2 Automatic table layout

          C.2.118 Section 17.5.3 Table height algorithms

          C.2.119 Section 17.5.4 Horizontal alignment in a column

          C.2.120 Section 17.6 Borders

          C.2.121 Section 17.6.1 The separated borders model

          C.2.122 Section 17.6.1.1 Borders and Backgrounds around empty cells

          C.2.123 Section 17.6.2 The collapsing border model

          C.2.124 Section 17.6.2.1 Border conflict resolution

          C.2.125 Section 18.1 Cursors: the 'cursor' property

          C.2.126 Section 18.4 Dynamic outlines

          C.2.127 Chapter 12 Generated content, automatic numbering, and lists

          C.2.128 Appendix A. Aural style sheets

          C.2.129 Appendix A Section 5 Pause properties

          C.2.130 Appendix A Section 6 Cue properties

          C.2.131 Appendix A Section 7 Mixing properties

          C.2.132 Appendix B Bibliography

          C.2.133 Other
        

      
        C.3 Errors

        C.3.1 Shorthand properties

          C.3.2 Applies to

          C.3.3 Section 4.1.1 (and G2)

          C.3.4 Section 4.1.3 Characters and case

          C.3.5 Section 4.3 (Double sign problem)

          C.3.6 Section 4.3.2 Lengths

          C.3.7 Section 4.3.3 Percentages

          C.3.8 Section 4.3.4 URLs and URIs

          C.3.9 Section 4.3.5 Counters

          C.3.10 Section 4.3.6 Colors

          C.3.11 Section 4.3.7 Strings

          C.3.12 Section 5.10 Pseudo-elements and pseudo-classes

          C.3.13 Section 6.4 The cascade

          C.3.14 Section 8.1 Box Dimensions

          C.3.15 Section 8.2 Example of margins, padding, and borders

          C.3.16 Section 8.5.4 Border shorthand properties

          C.3.17 Section 9.2.1 Block-level elements and block boxes

          C.3.18 Section 9.3.1 Choosing a positioning scheme

          C.3.19 Section 9.3.2 Box offsets

          C.3.20 Section 9.4.1 Block formatting contexts

          C.3.21 Section 9.4.2 Inline formatting context

          C.3.22 Section 9.4.3 Relative positioning

          C.3.23 Section 9.5 Floats

          C.3.24 Section 9.5.1 Positioning the float

          C.3.25 Section 9.5.2 Controlling flow next to floats

          C.3.26 Section 9.6 Absolute positioning

          C.3.27 Section 9.7 Relationships between 'display', 'position', and 'float'

          C.3.28 Section 9.10 Text direction

          C.3.29 Section 10.1 Definition of "containing block"

          C.3.30 Section 10.3.3 Block-level, non-replaced elements in normal flow

          C.3.31 Section 10.4 Minimum and maximum widths

          C.3.32 Section 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'

          C.3.33 Section 10.7 Minimum and maximum heights

          C.3.34 Section 11.1.1 Overflow

          C.3.35 Section 11.1.2 Clipping: the 'clip' property

          C.3.36 Section 11.2 Visibility

          C.3.37 Section 12.4.2 Counter styles

          C.3.38 Section 12.6.2 Lists

          C.3.39 Section 14.2 The background

          C.3.40 Section 14.2.1 Background properties

          C.3.41 Section 15.2 Font matching algorithm

          C.3.42 Section 15.7 Font size

          C.3.43 Section 16.1 Indentation

          C.3.44 Section 16.2 Alignment

          C.3.45 Section 17.2 The CSS table model

          C.3.46 Section 17.2.1 Anonymous table objects

          C.3.47 Section 17.4 Tables in the visual formatting model

          C.3.48 Section 17.5 Visual layout of table contents

          C.3.49 Section 17.5.1 Table layers and transparency

          C.3.50 Section 17.6.1 The separated borders model

          C.3.51 Section 18.2 System Colors

          C.3.52 Section E.2 Painting order
        

      
        C.4 Clarifications

        C.4.1 Section 2.1 A brief CSS 2.1 tutorial for HTML

          C.4.2 Section 2.2 A brief CSS 2.1 tutorial for XML

          C.4.3 Section 2.3 The CSS 2.1 processing model

          C.4.4 Section 3.1 Definitions

          C.4.5 Section 4.1 Syntax

          C.4.6 Section 4.1.1 Tokenization

          C.4.7 Section 4.1.3 Characters and case

          C.4.8 Section 4.1.7 Rule sets, declaration blocks, and selectors

          C.4.9 Section 4.2 Rules for handling parsing errors

          C.4.10 Section 4.3.1 Integers and real numbers

          C.4.11 Section 4.3.2 Lengths

          C.4.12 Section 4.3.4 URLs and URIs

          C.4.13 Section 5.1 Pattern matching

          C.4.14 Section 5.7 Adjacent sibling selectors

          C.4.15 Section 5.8.1 Matching attributes and attribute values

          C.4.16 Section 5.8.2 Default attribute values in DTDs

          C.4.17 Section 5.9 ID selectors

          C.4.18 Section 5.11.3 The dynamic pseudo-classes: :hover, :active, and :focus

          C.4.19 Section 5.11.4 The language pseudo-class: :lang

          C.4.20 Section 5.12.2 The :first-letter pseudo-element

          C.4.21 Section 6.2 Inheritance

          C.4.22 Section 6.2.1 The 'inherit' value

          C.4.23 Section 6.3 The @import rule

          C.4.24 Section 6.4 The Cascade

          C.4.25 Section 6.4.1 Cascading order

          C.4.26 Section 6.4.3 Calculating a selector's specificity

          C.4.27 Section 7.2.1 The @media rule

          C.4.28 Section 7.3 Recognized media types

          C.4.29 Section 7.3.1 Media groups

          C.4.30 Section 8.1 Box dimensions

          C.4.31 Section 8.3 Margin properties

          C.4.32 Section 8.3.1 Collapsing margins

          C.4.33 Section 8.5.3 Border style

          C.4.34 Section 9.1.1 The viewport

          C.4.35 Section 9.2.4 The 'display' property

          C.4.36 Section 9.3.1 Choosing a positioning scheme

          C.4.37 Section 9.3.2 Box offsets

          C.4.38 Section 9.4.2 Inline formatting context

          C.4.39 Section 9.4.3 Relative positioning

          C.4.40 Section 9.5 Floats

          C.4.41 Section 9.5.1 Positioning the float

          C.4.42 Section 9.5.2 Controlling flow next to floats

          C.4.43 Section 9.8 Comparison of normal flow, floats, and absolute positioning

          C.4.44 Section 10.1 Definition of "containing block"

          C.4.45 Section 10.2 Content width

          C.4.46 Section 10.3.3 Block-level, non-replaced elements in normal flow

          C.4.47 Section 10.3.8 Absolutely positioning, replaced elements

          C.4.48 Section 10.4 Minimum and maximum widths

          C.4.49 Section 10.6 Calculating heights and margins

          C.4.50 Section 10.7 Minimum and maximum heights

          C.4.51 Section 10.8 Line height calculations

          C.4.52 Section 10.8.1 Leading and half-leading

          C.4.53 Section 11.1 Overflow and clipping

          C.4.54 Section 11.1.1 Overflow

          C.4.55 Section 11.1.2 Clipping

          C.4.56 Section 11.2 Visibility

          C.4.57 Section 12.1 The :before and :after pseudo-elements

          C.4.58 Section 12.2 The 'content' property

          C.4.59 Section 12.3.2 Inserting quotes with the 'content' property

          C.4.60 Section 12.4 Automatic counters and numbering

          C.4.61 Section 12.4.3 Counters in elements with 'display: none'

          C.4.62 Section 14.2 The background

          C.4.63 Section 15.1 Fonts Introduction

          C.4.64 Section 15.2 Font matching algorithm

          C.4.65 Section 15.2.2 Font family

          C.4.66 Section 15.3.1 Generic font families

          C.4.67 Section 15.4 Font styling

          C.4.68 Section 15.5 Small-caps

          C.4.69 Section 15.6 Font boldness

          C.4.70 Section 15.7 Font size

          C.4.71 Section 16.1 Indentation

          C.4.72 Section 16.2 Alignment

          C.4.73 Section 16.3.1 Underlining, over lining, striking, and blinking

          C.4.74 Section 16.5 Capitalization

          C.4.75 Section 16.6 White space

          C.4.76 Section 17.1 Introduction to tables

          C.4.77 Section 17.2 The CSS table model

          C.4.78 Section 17.2.1 Anonymous table objects

          C.4.79 Section 17.4 Tables in the visual formatting model

          C.4.80 Section 17.5 Visual layout of table contents

          C.4.81 Section 17.5.1 Table layers and transparency

          C.4.82 Section 17.5.2 Table width algorithms

          C.4.83 Section 17.5.2.1 Fixed table layout

          C.4.84 Section 17.5.2.2 Automatic table layout

          C.4.85 Section 17.5.4 Horizontal alignment in a column

          C.4.86 Section 17.5.5 Dynamic row and column effects

          C.4.87 Section 17.6.1 The separated borders model

          C.4.88 Section 17.6.2 The collapsing borders model

          C.4.89 Section 18.2 System Colors

          C.4.90 Section 18.4 Dynamic outlines

          C.4.91 Section 18.4.1 Outlines and the focus

          C.4.92 Appendix D Default style sheet for HTML 4
        

      
        C.5 Errata since the Candidate Recommendation of July 2007

        C.5.1 Section 1.4.2.1 Value

          C.5.2 Section 2.3 The CSS 2.1 processing model

          C.5.3 Section 3.1 Definitions

          C.5.4 Section 4.1.1 Tokenization

          C.5.5 Section 4.1.2.2 Informative Historical Notes

          C.5.6 Section 4.1.3 Characters and case

          C.5.7 Section 4.1.3 Characters and case

          C.5.8 Section 4.1.3 Characters and case

          C.5.9 Section 4.1.3 Characters and case

          C.5.10 Section 4.1.5 At-rules

          C.5.11 Section 4.1.7 Rule sets, declaration blocks, and selectors

          C.5.12 Section 4.2 Rules for handling parsing errors

          C.5.13 Section 4.2 Rules for handling parsing errors

          C.5.14 Section 4.3.2 Lengths

          C.5.15 Section 4.3.5 Counters

          C.5.16 Section 5.8.1 Matching attributes and attribute values

          C.5.17 Section 5.8.2 Default attribute values in DTDs

          C.5.18 Section 5.11.4 The language pseudo-class: :lang

          C.5.19 Section 5.12.3 The :before and :after pseudo-elements

          C.5.20 Section 6.3 The @import rule

          C.5.21 Section 6.3 The @import rule

          C.5.22 Section 6.4.1 Cascading order

          C.5.23 Section 6.4.1 Cascading order

          C.5.24 Section 7.2.1 The @media rule

          C.5.25 Section 8.3.1 Collapsing margins

          C.5.26 Section 8.3.1 Collapsing margins

          C.5.27 Section 8.3.1 Collapsing margins

          C.5.28 Section 9.2.2 Inline-level elements and inline boxes

          C.5.29 Section 9.2.4 The 'display' property

          C.5.30 Section 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

          C.5.31 Section 9.5 Floats

          C.5.32 Section 9.5 Floats

          C.5.33 Section 9.5.2 Controlling flow next to floats: the 'clear' property

          C.5.34 Section 9.6.1 Fixed positioning

          C.5.35 Section 9.9.1 Specifying the stack level: the 'z-index' property

          C.5.36 Section 10.1 Definition of "containing block"

          C.5.37 Section 10.3 Calculating widths and margins

          C.5.38 Section 10.3.1 Inline, non-replaced elements

          C.5.39 Section 10.3.2 Inline, replaced elements

          C.5.40 Section 10.3.2 Inline, replaced elements

          C.5.41 Section 10.3.3 Block-level, non-replaced elements in normal flow

          C.5.42 Section 10.3.7 Absolutely positioned, non-replaced elements

          C.5.43 Section 10.3.7 Absolutely positioned, non-replaced elements

          C.5.44 Section 10.3.8 Absolutely positioned, replaced elements

          C.5.45 Section 10.3.8 Absolutely positioned, replaced elements

          C.5.46 Section 10.3.8 Absolutely positioned, replaced elements

          C.5.47 Section 10.5 Content height: the 'height' property

          C.5.48 Section 10.6.2 Inline replaced elements […]

          C.5.49 Section 10.6.4 Absolutely positioned, non-replaced elements

          C.5.50 Section 10.6.5 Absolutely positioned, replaced elements

          C.5.51 Section 10.8.1 Leading and half-leading

          C.5.52 Section 11.1.1 Overflow: the 'overflow' property

          C.5.53 Section 11.1.2 Clipping: the 'clip' property

          C.5.54 Section 12.2 The 'content' property

          C.5.55 Section 12.4.2 Counter styles

          C.5.56 Section 12.5 Lists

          C.5.57 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.5.58 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.5.59 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.5.60 Section 13.2 Page boxes: the @page rule

          C.5.61 Section 13.2.1.1 Rendering page boxes that do not fit a target sheet

          C.5.62 Section 13.2.3 Content outside the page box

          C.5.63 Section 13.3.1 Page break properties: 'page-break-before', 'page-break-after', 'page-break-inside'

          C.5.64 Section 13.3.1 Page break properties: 'page-break-before', 'page-break-after', 'page-break-inside'

          C.5.65 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

          C.5.66 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

          C.5.67 Section 13.3.3 Allowed page breaks

          C.5.68 Section 13.3.3 Allowed page breaks

          C.5.69 Section 13.3.3 Allowed page breaks

          C.5.70 Section 13.3.5 "Best" page breaks

          C.5.71 Section 14.2 The background

          C.5.72 Section 14.2 The background

          C.5.73 Section 14.2.1 Background properties: 'background-color', 'background-image', 'background-repeat', 'background-attachment', 'background-position', and 'background'

          C.5.74 Section 15.6 Font boldness: the 'font-weight' property

          C.5.75 Section 16.6 Whitespace: the 'white-space' property

          C.5.76 Section 16.6.1 The 'white-space' processing model

          C.5.77 Section 17.2.1 Anonymous table objects

          C.5.78 Section 17.2.1 Anonymous table objects

          C.5.79 Section 17.4 Tables in the visual formatting model

          C.5.80 Section 17.5.4 Horizontal alignment in a column

          C.5.81 Section 18.1 Cursors: the 'cursor' property

          C.5.82 Section B.2 Informative references

          C.5.83 Appendix D. Default style sheet for HTML 4

          C.5.84 Appendix D. Default style sheet for HTML 4

          C.5.85 Section E.2 Painting order

          C.5.86 Appendix G. Grammar of CSS 2.1

          C.5.87 Section G.1 Grammar

          C.5.88 Section G.2 Lexical scanner

          C.5.89 Section G.2 Lexical scanner

          C.5.90 Section G.2 Lexical scanner

          C.5.91 Section G.2 Lexical scanner

          C.5.92 Appendix I. Index
        

      
        C.6 Errata since the Candidate Recommendation of April 2009

        C.6.1 Section 4.2 Rules for handling parsing errors

          C.6.2 Section 13.3.3 Allowed page breaks

          C.6.3 Section 15.3 Font family: the 'font-family' property

          C.6.4 Section 15.3.1.1 serif

          C.6.5 Section 15.7 Font size: the 'font-size' property

          C.6.6 Section 17.5.2.1 Fixed table layout

          C.6.7 Section 17.5.3 Table height layout

          C.6.8 Appendix G. Grammar of CSS 2.1
        

      
        C.7 Errata since the Candidate Recommendation of September 2009

        C.7.1 Section 1.4.2.1 Value

          C.7.2 Section 3.1 Definitions

          C.7.3 Section 4.1.1 Tokenization

          C.7.4 Section 4.1.1 Tokenization

          C.7.5 Section 4.1.1 Tokenization

          C.7.6 Section 4.1.1 Tokenization

          C.7.7 Section 4.1.2.2 Informative Historical Notes

          C.7.8 Section 4.1.3 Characters and case

          C.7.9 Section 4.1.3 Characters and case

          C.7.10 Section 4.1.8 Declarations and properties

          C.7.11 Section 4.2 Rules for handling parsing errors

          C.7.12 Section 4.3.2 Lengths

          C.7.13 Section 4.3.2 Lengths

          C.7.14 Section 4.3.4 URLs and URIs

          C.7.15 Section 4.3.4 URLs and URIs

          C.7.16 Section 5.8.2 Default attribute values in DTDs

          C.7.17 Section 5.11.4 The language pseudo-class: :lang

          C.7.18 Section 5.12 Pseudo-elements

          C.7.19 Section 5.12.1 The :first-line pseudo-element

          C.7.20 Section 5.12.2 The :first-letter pseudo-element

          C.7.21 Section 6.2 Inheritance

          C.7.22 Section 6.4.4 Precedence of non-CSS presentational hints

          C.7.23 Section 7.3 Recognized media types

          C.7.24 Section 8.3.1 Collapsing margins

          C.7.25 Section 8.3.1 Collapsing margins

          C.7.26 Section 9.2.1 Block-level elements and block boxes

          C.7.27 Section 9.2.1.1 Anonymous block boxes

          C.7.28 Section 9.2.1.1 Anonymous block boxes

          C.7.29 Section 9.2.1.1 Anonymous block boxes

          C.7.30 Section 9.2.1.1 Anonymous block boxes

          C.7.31 Section 9.2.2 Inline-level elements and inline boxes

          C.7.32 Section 9.2.3 Run-in boxes

          C.7.33 Section 9.2.4 The 'display' property

          C.7.34 Section 9.2.4 The 'display' property

          C.7.35 Section 9.3 Positioning schemes

          C.7.36 Section 9.4 Normal flow

          C.7.37 Section 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

          C.7.38 Section 9.5 Floats

          C.7.39 Section 9.5 Floats

          C.7.40 Section 9.5.2 Controlling flow next to floats: the 'clear' property

          C.7.41 Section 9.5.2 Controlling flow next to floats: the 'clear' property

          C.7.42 Section 9.5.2 Controlling flow next to floats: the 'clear' property

          C.7.43 Section 9.5.2 Controlling flow next to floats: the 'clear' property

          C.7.44 Section 14.2.1 Background properties

          C.7.45 Section 9.9.1 Specifying the stack level: the 'z-index' property

          C.7.46 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

          C.7.47 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

          C.7.48 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

          C.7.49 Section 10.1 Definition of "containing block"

          C.7.50 Section 10.2 Content width: the 'width' property

          C.7.51 Section 10.2 Content width: the 'width' property

          C.7.52 Section 10.2 Content width: the 'width' property

          C.7.53 Section 10.5 Content height: the 'height' property

          C.7.54 Section 10.5 Content height: the 'height' property

          C.7.55 Section 10.6.7 'Auto' heights for block formatting context roots

          C.7.56 Section 10.7 Minimum and maximum heights: 'min-height' and 'max-height'

          C.7.57 Section 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

          C.7.58 Section 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

          C.7.59 Section 10.8.1 Leading and half-leading

          C.7.60 Section 10.8.1 Leading and half-leading

          C.7.61 Section 10.8.1 Leading and half-leading

          C.7.62 Section 11.1 Overflow and clipping

          C.7.63 Section 11.1.1 Overflow: the 'overflow' property

          C.7.64 Section 11.1.1 Overflow: the 'overflow' property

          C.7.65 Section 11.1.1 Overflow: the 'overflow' property

          C.7.66 Section 11.1.2 Clipping: the 'clip' property

          C.7.67 Section 12.5 Lists

          C.7.68 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.7.69 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.7.70 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.7.71 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.7.72 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.7.73 Section 13.2 Page boxes: the @page rule

          C.7.74 Section 13.2.2 Page selectors: selecting left, right, and first pages

          C.7.75 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

          C.7.76 Section 13.3.3 Allowed page breaks

          C.7.77 Section 15.3 Font family: the 'font-family' property

          C.7.78 Section 15.3.1 Generic font families

          C.7.79 Section 15.6 Font boldness: the 'font-weight' property

          C.7.80 Section 15.6 Font boldness: the 'font-weight' property

          C.7.81 Section 15.7 Font size: the 'font-size' property

          C.7.82 Section 16.1 Indentation: the 'text-indent' property

          C.7.83 Section 16.1 Indentation: the 'text-indent' property

          C.7.84 Section 16.2 Alignment: the 'text-align' property

          C.7.85 Section 16.2 Alignment: the 'text-align' property

          C.7.86 Section 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

          C.7.87 Section 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

          C.7.88 Section 16.4 Letter and word spacing: the 'letter-spacing' and 'word-spacing' properties

          C.7.89 Section 16.6 White space: the 'white-space' property

          C.7.90 Section 16.6.1 The 'white-space' processing model

          C.7.91 Section 16.6.1 The 'white-space' processing model

          C.7.92 Section 16.6.1 The 'white-space' processing model

          C.7.93 Section 17.2 The CSS table model

          C.7.94 Section 17.2.1 Anonymous table objects

          C.7.95 Section 17.2.1 Anonymous table objects

          C.7.96 Section 17.4 Tables in the visual formatting model

          C.7.97 Section 17.4 Tables in the visual formatting model

          C.7.98 Section 17.5.2.2 Automatic table layout

          C.7.99 Section 17.5.3 Table height algorithms

          C.7.100 Section 17.5.4 Horizontal alignment in a column

          C.7.101 Section B.2 Informative references

          C.7.102 Section D. Default style sheet for HTML 4

          C.7.103 Section E.2 Painting order

          C.7.104 Appendix G Grammar of CSS 2.1
        

      
        C.8 Changes since the working draft of 7 December 2010

        C.8.1 8.3.1 Collapsing margins

          C.8.2 10.8.1 Leading and half-leading

          C.8.3 10.3 Calculating widths and margins

          C.8.4 14.3 Gamma correction

          C.8.5 11.1.2 Clipping: the 'clip' property

          C.8.6 9.4.2 Inline formatting contexts

          C.8.7 10.3.2 Inline, replaced elements

          C.8.8 10.1 Definition of "containing block"

          C.8.9 13.2.2 Page selectors: selecting left, right, and first pages

          C.8.10 8.3.1 Collapsing margins

          C.8.11 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

          C.8.12 10.8.1 Leading and half-leading

          C.8.13 10.6.1 Inline, non-replaced elements

          C.8.14 9.5.1 Positioning the float: the 'float' property

          C.8.15 9.2.1.1 Anonymous block boxes

          C.8.16 5.12.1 The :first-line pseudo-element

          C.8.17 16.6 White space: the 'white-space' property

          C.8.18 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.8.19 9.7 Relationships between 'display', 'position', and 'float'

          C.8.20 9.4.2 Inline formatting contexts

          C.8.21 4.1.9 Comments

          C.8.22 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

          C.8.23 9.5.1 Positioning the float: the 'float' property

          C.8.24 9.3 Positioning schemes

          C.8.25 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

          C.8.26 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

          C.8.27 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

          C.8.28 10.4 Minimum and maximum widths: 'min-width' and 'max-width'

          C.8.29 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

          C.8.30 9.2.1.1 Anonymous block boxes

          C.8.31 17.4 Tables in the visual formatting model

          C.8.32 11.1.2 Clipping: the 'clip' property

          C.8.33 13.2 Page boxes: the @page rule

          C.8.34 4.1.1 Tokenization

          C.8.35 4.2 Rules for handling parsing errors

          C.8.36 3.1 Definitions

          C.8.37 4.3.4 URLs and URIs

          C.8.38 9.5 Floats

          C.8.39 11.1.1 Overflow: the 'overflow' property

          C.8.40 9.2.1.1 Anonymous block boxes

          C.8.41 16.2 Alignment: the 'text-align' property

          C.8.42 9.5 Floats

          C.8.43 9.4.2 Inline formatting contexts

          C.8.44 5.12 Pseudo-elements

          C.8.45 9.5 Floats

          C.8.46 9.5 Floats

          C.8.47 14.2.1 Background properties: 'background-color', 'background-image', 'background-repeat', 'background-attachment', 'background-position', and 'background'

          C.8.48 9.2.4 The 'display' property

          C.8.49 6.1.2 Computed values

          C.8.50 10.3.2 Inline, replaced elements

          C.8.51 Section 9.5.2 Controlling flow next to floats: the 'clear' property

          C.8.52 G.2 Lexical scanner

          C.8.53 Section 9.5.2 Controlling flow next to floats: the 'clear' property

          C.8.54 9.5 Floats

          C.8.55 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'
        
    

  この付録は参考情報で、規範的ではない。

  CSS 2.1はCSS2の最新の改訂版である。CSS2仕様（[CSS2]を参照）と本仕様との変更点は、既知のエラー、誤植、明確化、変更と追加の5つのグループに分類される。誤植はここに記載されない。

  さらに、この章は、2007年7月に勧告候補となって以来続けてCSS 2.1に適用されたエラッタ（パート1とパート2）を示す。

  この章は、変更点の完全なリストではない。マイナーな編集上の変更および例へのほとんどの変更もここに記載されない。

  【訳注：この章では、リンク参照に疑問のある箇所が多数ありますが、原文ママです。】

  C.1 Additional property values

  C.1.1 Section 4.3.6 Colors

  New color value: 'orange'

  C.1.2 Section 9.2.4 The 'display' property

  New 'display' value: 'inline-block'

  C.1.3 Section 12.2 The 'content' property

  New 'content' values 'none' and 'normal'. (The values 'none' and 'normal' are equivalent in CSS 2.1, but may have different functions in CSS3.)

  C.1.4 Section 16.6 White space: the 'white-space' property

  New 'white-space' values: 'pre-wrap' and 'pre-line'

  C.1.5 Section 18.1 Cursors: the 'cursor' property

  New 'cursor' value: 'progress'

  C.2 Changes

  C.2.1 Section 1.1 CSS 2.1 vs CSS 2

  This new section is added to explain the motivation for CSS2.1 and its relation to CSS2.

  C.2.2 Section 1.2 Reading the specification

  This section (formerly Section 1.1) has been marked non-normative.

  C.2.3 Section 1.3 How the specification is organized

  This section (formerly Section 1.2) has been marked non-normative.

  C.2.4 Section 1.4.2.1 Value

  This section (formerly unnumbered under 1.3.2) notes that value types are specified in terms of tokens and that spaces may appear between tokens in values. A note explains that spaces are required between some tokens.

  C.2.5 Section 1.4.2.6 Media groups

  This section (formerly unnumbered under 1.3.2) now declares the Media line in property definitions to be non-normative.

  C.2.6 Section 1.4.2.7 Computed value

  A new line is added to each property definition specifying what the computed values are for the property. (This defines what level of computation is done to a property value before inheritance and before certain other calculations.)

  C.2.7 Section 1.4.4 Notes and examples

  This section (formerly 1.3.4) now specifies that HTML examples lacking DOCTYPE declarations are SGML Text Entities conforming to the HTML 4.01 Strict DTD [HTML4]. The markup for many examples has been reformulated to either include a DOCTYPE or conform to this definition.

  C.2.8 Section 1.5 Acknowledgments

  This section (formerly 1.4) has been updated to reflect contributions to CSS2.1 and has been marked non-normative.

  C.2.9 Section 3.2 Conformance

  Support for user style sheets is now required (in most cases), rather than just recommended.

  Support for turning of author style sheets is now required.

  Application of CSS properties to form controls is explicitly undefined. Authors are recommended to treat form control styling capabilities in UAs as experimental.

  C.2.10 Section 3.3 Error Conditions

  This section changed to say that error handling is specified in most cases.

  C.2.11 Section 4.1.1 Tokenization

  Added INVALID token and rules for its definition.

  An optional hyphen, "-", is now allowed at the beginning of an "ident" for vendor extensions. (See section 4.1.2.1)

  The underscore character ("_") is allowed in identifiers. The definitions of the lexical macros "nmstart" and "nmchar" now include it. See also section 4.1.2.1 (Vendor extensions).

  The "escape" macro has been modified to allow the escaping of any character except newlines, form feeds, and hex digits (to avoid conflict with Unicode escapes).

  Modified "string1" and "string2" macros by defining allowed characters through excluding disallowed characters. This allows invisible ASCII characters to be included in a string.

  C.2.12 Section 4.1.3 Characters and case

  Updated prose about identifiers (second bullet point) to match changes in the tokenization (above).

  Excluded null (0x0) character from CSS numerical escapes and indicate that it is undefined in CSS2.1 what happens if such a character is encountered.

  Allowed the use of U+FFFD as a replacement for characters outside the range allowed by Unicode.

  CSS is no longer case-insensitive, but case-sensitive with exceptions. Changed "All CSS style sheets are case-insensitive, except for parts that are not under the control of CSS" to "All CSS syntax is case-insensitive within the ASCII range (i.e., [a-z] and [A-Z] are equivalent), except for parts that are not under the control of CSS." See also the change to case-sensitivity of counters in 4.3.5.

  C.2.13 Section 4.2 Rules for handling parsing errors

  Defined parsing in the cases of Malformed Declarations, Unexpected End of Stylesheet, and Unexpected End of String.

  C.2.14 Section 4.3 Values

  Sections 4.3.7 (Angles), 4.3.8 (Times), and 4.3.9 (Frequencies) have been moved to the informative Appendix A.

  C.2.15 Section 4.3.2 Lengths

  Added a paragraph on heuristics for finding the x-height of a font.

  C.2.16 Section 4.3.4 URLs and URIs

  Updated URI references to RFC3986.

  C.2.17 Section 4.3.5 Counters

  Changed "Counters are denoted by identifiers" to "Counters are denoted by case-sensitive identifiers" (see also the change to case-sensitivity in 4.1.3).

  C.2.18 Section 4.3.6 Colors

  Defined the numeric values corresponding to color keywords instead of referencing HTML4 for those values.

  UAs are now allowed to intelligently map colors outside the gamut into the gamut instead of simply clipping them into the range of the gamut.

  C.2.19 Section 4.3.8 Unsupported Values

  Added this section to recommend that unsupported properties and values be ignored as if they were invalid.

  C.2.20 Section 4.4 CSS style sheet representation

  Changed character encoding detection rule 2 to include a BOM and referred to additional rules below.

  Added rule 4 to provide for use of the referring style sheet or document's character encoding.

  Added rule 5 to require falling back to UTF-8.

  Removed the restriction on using @charset in embedded style sheets.

  Allowed a BOM to precede the @charset rule.

  Added requirement that @charset rule must be a literal '@charset"...";', not a CSS-syntax equivalent.

  Added requirement to support for UTF-8 at minimum.

  Specified that any @charset rule not at the beginning of the style sheet must be ignored.

  Removed note on theoretical problem with @charset problem and precisely defined rules for character encoding detection based on @charset and/or BOM.

  Specified that UAs must ignore style sheets in unknown encodings.

  C.2.21 Section 5.8.1 Matching attributes and attribute values

  BCP 47 replaces RFC 1766.

  C.2.22 Section 5.8.3 Class selectors

  Class selectors are allowed for other formats than HTML.

  Added a note about matching classes in formats with multiple class attributes per element. The behavior is non-normative, because, at the time of writing, there exist no such formats.

  C.2.23 Section 5.9 ID selectors

  Specified how to match elements with two or more ID attributes.

  C.2.24 Section 5.10 Pseudo-elements and pseudo-classes

  Removed exception for HTML UAs that allowed them (and only them) to ignore ':first-letter' and ':first-line'.

  C.2.25 Section 5.11.2 The link pseudo-classes: :link and :visited

  UAs may return a :visited link to :link status at some point. (This was previously a note, but is now normative.)

  Added a note about privacy concerns with link pseudo classes and allowed UAs to treat :visited as :link.

  C.2.26 Section 5.11.4 The language pseudo-class: :lang

  The identifier C in ':lang(C)' need not be a valid language code, but it must not be empty.

  C.2.27 Section 5.12.1 The :first-line pseudo-element

  ':first-line' also applies to inline blocks, table captions and table cells. Added a definition of "first formatted line" to make the rules about which line is the first line more precise.

  UAs are no longer forbidden from applying more properties than the given list.

  C.2.28 Section 5.12.2 The :first-letter pseudo-element

  More precise definition of first letter. Added rules for cases where the first letter is in an inline block or table cell. Added rules for cases when preceding punctuation is in a different element from the first letter itself.

  UAs may apply other properties to first letters than the given list.

  Unicode character classes Pi and Pf added to the definition of punctuation.

  C.2.29 Section 6.1 Specified, computed, and actual values

  Redefined "computed value" and created the concept of "used value" so that inheritance can be performed without laying out the document. This change has the effect of allowing (requiring) percentages to be inherited as percentages and affects many other layout calculations throughout the spec.

  Since computed value of a property can now also be a percentage. In particular, the following properties now inherit the percentage if the specified value is a percentage:

  background-position

    bottom, left, right, top

    height, width

    margin-bottom, margin-left, margin-right, margin-top,

    min-height, min-width

    padding-bottom, padding-left, padding-right, padding-top

    text-indent
  Note that only 'text-indent' inherits by default, the others only inherit if the 'inherit' keyword is specified.

  C.2.30 Section 6.4.1 Cascading order

  Changed suggestion that user be able to turn off author styles to a requirement.

  C.2.31 Section 6.4.3 Calculating a selector's specificity

  The "style" attribute now has a higher specificity than any style rule.

  Pseudo-elements are now counted with elements in calculating a a selector's specificity.

  C.2.32 Section 6.4.4 Precedence of non-CSS presentational hints

  "Non-CSS presentational hints" no longer exist, with the exception of a small set of attributes in HTML.

  C.2.33 Section 7.3 Recognized Media Types

  Added 'speech' media type.

  Marked "Media" field in property descriptions informative.

  C.2.34 Section 7.3.1 Media Groups

  Marked this section informative.

  Added sound to 'handheld' in media type/media group table.

  Changed 'tactile' to be both 'static' and 'interactive'.

  C.2.35 Section 8.3 Margin properties

  If the containing block's width depends on an element with percentage margins, then the resulting layout is undefined in CSS 2.1.

  C.2.36 Section 8.3.1 Collapsing margins

  In the definition of "collapsing margins", added "non-empty content" and "clearance" to the parenthetical list of things that prevent consecutive margins from being adjoining.

  Vertical margins of elements with 'overflow' other than 'visible' no longer collapse with their in-flow children.

  Defined how margins collapse through an element with adjoining top and bottom margins.

  Added that margins of the root element's box do not collapse.

  More rigorously defined "adjoining" for margin collapsing.

  Sixth bullet, second sub-bullet: to find the position of the top border edge, assume the element has a bottom (rather than top) border.

  Margins of relatively positioned elements do sometimes collapse.

  C.2.37 Section 8.4 Padding properties

  If the containing block's width depends on an element with percentage padding, then the resulting layout is undefined in CSS 2.1.

  C.2.38 Section 8.5.2 Border color

  'transparent' can now be specified independently for each border side, on par with <color>.

  C.2.39 Section 8.5.3 Border style

  3D border styles ('groove', 'ridge', 'inset', 'outset') now depend on the corresponding border-color rather than on 'color'.

  C.2.40 Section 8.6 The box model for inline elements in bidirectional context

  Added this new section to specify layout of inline boxes when affected by bidi.

  C.2.41 Section 9.1.2 Containing blocks

  Removed paragraphs about the initial containing block, as this is now defined differently. (See changes to section 10.1.)

  C.2.42 Section 9.2.1.1 Anonymous block boxes

  Added a paragraph to define formatting when an inline box contains a block box.

  Specified what property values are applied to anonymous boxes.

  C.2.43 Section 9.2.2.1 Anonymous inline boxes

  Specified that collapsed white space does not generate anonymous inline boxes.

  C.2.44 Section 9.2.3 Run-in boxes

  Changed run-in rules so that a) run-ins that contain blocks become blocks b) run-ins can only run into sibling blocks and c) run-ins cannot run into other run-ins.

  C.2.45 Section 9.2.4 The 'display' property

  The 'marker' and 'compact' values of the 'display' property are not part of CSS 2.1. Text relating to these values has been removed throughout the specification.

  Defined the computed value of 'display' as the specified value except for positioned and floating elements and for the root element. The computed value of 'display' for these elements is defined in section 9.7 and is slightly different from the definition in CSS2.

  Conforming HTML UAs are no longer allowed to ignore the 'display' property.

  C.2.46 Section 9.3.1 Choosing a positioning scheme

  The 'position' property now applies to all elements, including generated content.

  The effect of relative positioning on table captions and internal table elements is undefined in CSS 2.1.

  For fixed positioning, introduced a conflict between this section and section 10.1 rule 3. See howcome [member-only] for rationale.

  Forbid UAs from paginating the content of fixed boxes.

  UAs are allowed to treat all values of 'position' as 'static' on the root element.

  C.2.47 Section 9.3.2 Box offsets

  Defined computed values of 'top', 'right', 'bottom', 'left' based on the value of 'position'.

  Percentage offsets are no longer undefined for containing blocks without an explicit height.

  C.2.48 Section 9.4.1 Block formatting contexts

  Specified that floats, absolutely positioned elements, inline-blocks, table-cells, table-captions, and elements with 'overflow' other than 'visible' establish new block formatting contexts.

  In the paragraph about the position of a box's outer edge with respect to its containing block, except boxes that establish a new block formatting context, as they may become narrower due to floats.

  C.2.49 Section 9.4.2 Inline formatting context

  Specified that the effect of 'justify' on the content of a line box does not affect the contents of inline-table and inline-block boxes.

  Empty line boxes are now required to be treated as zero-height and ignored in margin collapsing.

  C.2.50 Section 9.4.3 Relative positioning

  Added several paragraphs and an example to explain exactly what the computed values of relatively-positioned offsets are, how they affect each other, and what happens when the positioning is overconstrained. (These were not previously defined.)

  C.2.51 Section 9.5 Floats

  Floats are no longer required to have an explicit width.

  Floats outside of line boxes no longer align to the bottom of the preceding block box; it is implied that they are initially aligned with their non-floated position.

  Specified that "If a shortened line box is too small to contain any further content, then it is shifted downward until either it fits or there are no more floats present."

  Specified that the border box of a table, block-level replaced element, or element in the normal flow that establishes a new block formatting context must not overlap any floats in the same block formatting context.

  C.2.52 Section 9.5.1 Positioning the float

  The 'float' property now also applies to :before/:after and generated content.

  UAs are now allowed to treat all values of float as 'none' on the root element.

  Added to rule 4 prose to define the position of a float when it occurs between two collapsing margins.

  C.2.53 Section 9.5.2 Controlling flow next to floats

  Defined clearance to precisely detail the 'clear' property's effect on margin collapsing and the block's cleared position.

  Added note to explain effect of 'clear' on inline elements since CSS1 (but not CSS2 or CSS 2.1) allows 'clear' on inline elements.

  C.2.54 Section 9.7 Relationships between 'display', 'position', and 'float'

  Changed rules to convert 'display' not always to 'block', but to an appropriate block-level display value as given by a mapping table.

  Added rule 4 to convert root element's 'display' value according to the mapping.

  C.2.55 Section 9.9 Layered presentation

  Specified that the background and borders of an element that forms a stacking context are behind all of its descendants, altered stacking context prose to be more precise, and added a normative Appendix E: Elaborate description of Stacking Contexts to be even more precise about the position of borders, backgrounds, and content on the z-axis.

  C.2.56 Section 9.10 Text direction

  Conforming UAs are now allowed to not support bidirectional text; in this case they must ignore the 'direction' and 'unicode-bidi' properties. However since applying bidi can have an effect even when a document does not contain right-to-left characters, UAs that do support bidi are no longer permitted to not apply the algorithm just because the document lacks right-to-left characters.

  Added a paragraph to define precisely how the Unicode bidirectional algorithm applies to text in the CSS formatting model and how the CSS 'direction' property on blocks maps into the algorithm.

  Conforming HTML UAs are no longer exempt from supporting 'direction' and 'unicode-bidi'.

  C.2.57 Chapter 10 Visual formatting model details

  Updated prose to use the terms "specified", "computed" and "used" as appropriate when referencing values. This affects many calculations in this section. (See changes to section 6.1.)

  C.2.58 Section 10.1 Definition of "containing block"

  In rule 1, defined the initial containing block as the viewport for continuous media and the page area for paged media. (It was previously undefined.)

  In rule 2, defined the page area as the containing block for fixed positioned elements in paged media.

  In rule 4.1, when the containing block of an absolutely-positioned element is formed by an inline-level element, it is now formed by that element's padding edges, not its content edges.

  In rule 4, changed the containing block for absolutely positioned elements with only statically positioned elements from the root's content box to the initial containing block.

  Specified the positioning and breaking behavior of absolutely-positioned elements in paged media.

  C.2.59 Section 10.2 Content width

  Declared that if the containing block's width depends on an element's percentage width, then the resulting layout is undefined in CSS 2.1.

  C.2.60 Section 10.3 Calculating widths and margins

  The computed values of 'left' and 'right' for are now defined in section 9.3.2. The value 'auto' does not always compute to zero.

  Added sections 10.3.9 and 10.3.10 to define calculations for inline blocks.

  C.2.61 Section 10.3.2 Inline, replaced elements

  The sizing algorithm for replaced elements now takes into account and attempts to preserve the replaced content's intrinsic ratio. Sizing of replaced elements with percentage intrinsic sizes and without intrinsic sizes is now also defined.

  The effect of percentage intrinsic widths is now undefined for CSS level 2, rather than ignored.

  C.2.62 Section 10.3.3 Block-level, non-replaced elements in normal flow

  Specified that a computed total of the width, padding, and borders that is greater than the containing block width causes auto margins to be treated as zero in the rest of the rules. This avoids 'auto' margins being negative on the start edge.

  C.2.63 Section 10.3.4 Block-level, replaced elements in normal flow

  Applied changes to section 10.3.2 and section 10.3.3 to block-level replaced elements in normal flow by referring to the calculations in those sections.

  C.2.64 Section 10.3.5 Floating, non-replaced elements

  Defined computations for 'auto' width floats as shrink-to-fit. (Floats were previously required to have fixed widths.)

  C.2.65 Section 10.3.6 Floating, replaced elements

  Applied changes to section 10.3.2 to this section by referencing it for 'auto' width calculations.

  C.2.66 Section 10.3.7 Absolutely positioned, non-replaced elements

  Defined the static position of an element more precisely.

  Rewrote constraint rules.

  The 'direction' property of the containing block of the static position determines which side is clamped to the static position, not the 'direction' property of the containing block of the absolutely positioned element.

  C.2.67 Section 10.3.8 Absolutely positioned, replaced elements

  In rule 1, applied sizing rules from section 10.3.2.

  In rule 2 (formerly rules 2 and 3), referred to new definition of 'static position' in section 10.3.7.

  Also in rule 2, the 'direction' property of the containing block of the static position determines which side is clamped to the static position, not the 'direction' property of the containing block of the absolutely positioned element.

  In rule 4 (formerly rule 5), prevented 'auto' left and right margins in resulting in a negative margin on the start edge.

  C.2.68 Section 10.4 Minimum and maximum widths

  Specified that if the containing block's width is negative, the used value of a percentage min/max width is zero.

  Specified that if the min/max width is specified in percentages and the containing block's width depends on this element's width, then the resulting layout is undefined in CSS 2.1.

  The UA is no longer allowed to select an arbitrary minimum width.

  The used width of replaced elements with an intrinsic ratio and both 'width' and 'height' specified as 'auto' is now calculated according to a table designed to preserve the intrinsic ratio as much as possible within the given constraints.

  C.2.69 Section 10.5 Content height

  Removed mention of 'line-height' for inline elements since their content box height no longer depends on 'line-height'.

  Percentage heights on absolutely-positioned elements are no longer treated as 'auto' when the containing block's height is not explicitly specified. Added a note to explain why this is possible.

  Specified that a percentage height on the root element is relative to the initial containing block.

  C.2.70 Section 10.6 Calculating heights and margins

  The computed values of 'top' and 'bottom' for are now defined in section 9.3.2. The value 'auto' does not always compute to zero.

  Added section 10.6.6 to cover cases that are no longer covered under the previous sections.

  Added section 10.6.7 to define 'auto' heights for block formatting context roots. (Unlike other block boxes, the height of these boxes increases to accommodate any normal-flow descendant floats.)

  C.2.71 Section 10.6.1 Inline, non-replaced elements

  The height of an inline box is no longer given by the 'line-height' property and is now undefined. This section now suggests that the height of the box can be based on the font.

  C.2.72 Section 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, 'inline-block' replaced elements in normal flow and floating replaced elements

  The sizing algorithm for replaced elements now takes into account and attempts to preserve the replaced content's intrinsic ratio. Sizing of replaced elements with percentage intrinsic sizes and without intrinsic sizes is now also defined.

  Specified that for inline elements, the margin box is used when calculating the height of the line box.

  C.2.73 Section 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'

  This section now only applies to elements whose 'overflow' value computes to 'visible'; elements with other values of 'overflow' are discussed in the new section 10.6.7 ('Auto' heights for block formatting context roots).

  C.2.74 Section 10.6.4 Absolutely positioned, non-replaced elements

  Defined the static position of an element more precisely.

  Rewrote constraint rules.

  C.2.75 Section 10.6.5 Absolutely positioned, replaced elements

  In rule 1, applied sizing rules from section 10.6.2.

  C.2.76 Section 10.7 Minimum and maximum heights

  Percentage min/max heights on absolutely-positioned elements are no longer treated as '0'/'none' when the containing block's height is not explicitly specified. However if the containing block's width depends on an element's percentage width, then the resulting layout is undefined in CSS 2.1.

  The used width of replaced elements with an intrinsic ratio and both 'width' and 'height' specified as 'auto' is now calculated according to a table designed to preserve the intrinsic ratio as much as possible within the given constraints.

  C.2.77 Section 10.8 Line height calculations

  Added rule 4 to specify that the height of the line box must be at least as much as that specified by the 'line-height' property on the this block.

  C.2.78 Section 10.8.1 Leading and half-leading

  UAs are no longer permitted to clip content to the line box, and are instead asked to render overlapping boxes in document order.

  'line-height' set on a block no longer specifies the minimal height of each inline box; instead it specifies the minimal height of each line box. The exact effect of this requirement is expressed in terms of struts; it is affected by vertical-alignment.

  Adjusted text to reflect that the content box height of an inline is no longer dictated by the 'line-height' property.

  Since the content box is now defined by the font and not by the line-height, 'text-top' and 'text-bottom' refer to the content area instead of the font.

  Defined 'top' and 'bottom' alignment in terms of aligned subtrees to take into account any protruding descendants.

  Defined the baseline of inline tables and inline blocks.

  C.2.79 Section 11.1 Overflow and clipping

  Specified that 'overflow' clips to the padding edge.

  C.2.80 Section 11.1.1 Overflow

  'projection' media are no longer permitted to print overflowing content for 'overflow: scroll'. 'Print' media now may, as opposed to should.

  UAs are now required to apply the 'overflow' property set on the root element to the viewport. Additionally, HTML UAs must use the 'overflow' property on the HTML BODY element instead if the root element's 'overflow' value is 'visible'.

  Specified placement of scrollbar in the box model.

  The width of any scrollbars is no longer included in the width of the containing block. (And consequently, all text in section 10.3 that subtracts the scrollbar width from the containing block width has been removed.)

  C.2.81 Section 11.1.2 Clipping: the 'clip' property

  The 'clip' property now applies only to absolutely positioned elements. Furthermore, it applies to those elements even when their 'overflow' is 'visible'.

  The default value of 'clip', 'auto', now indicates no clipping rather than clipping to the element's border box.

  Values of "rect()" should be separated by commas. UAs are required to support this syntax, but may also support a space-separated syntax since CSS2 was not clear about this.

  While CSS2 specified that values of "rect()" give offsets from the respective sides of the box, current implementations interpret values with respect to the top and left edges for all four values (top, right, bottom, and left). This is now the specified interpretation.

  C.2.82 Section 11.2 Visibility

  The 'visibility' property is now defined to inherit, and descendant elements can override an ancestor's hidden visibility.

  C.2.83 Chapter 12 Generated content, automatic numbering, and lists

  Moved all discussion of aural rendering to Appendix A.

  C.2.84 Section 12.1 The :before and :after pseudo-elements

  Removed restrictions on which properties and property values are allowed on ':before' and ':after' pseudo-elements.

  C.2.85 Section 12.2 The 'content' property

  The initial value of 'content' is now 'normal', not the empty string.

  The 'content' property now distinguishes between the empty string, which creates an empty box; and 'normal'/'none', which create no box at all. (There is no distinction between 'normal' and 'none' in level 2.)

  A UA is now allowed to report a URI that fails to download.

  Removed recommendation to authors to put rules with media-sensitive 'content' properties inside '@media'.

  Whether '\A' escapes in generated content create line breaks is now subject to the 'white-space' property.

  The former section 12.3 on interaction between ':before', ':after' and elements with 'display: compact' or 'display: run-in' has been removed. (The interaction is already fully defined, because generated content consists of boxes in the tree, no different from other boxes.)

  C.2.86 Section 12.3.2 Inserting quotes with the 'content' property

  Specified that extra 'close-quote's and 'no-close-quote's (those without a matching 'open-quote' or 'no-open-quote') are not rendered, and that neither 'close-quote' nor 'no-close-quote' cause the quoting depth to be negative.

  C.2.87 Section 12.4 Automatic counters and numbering

  Defined what a rule with duplicate counters, such as 'counter-reset: section 2 section', means.

  C.2.88 Section 12.4.1 Nested counters and scope

  The scope of a counter no longer defaults to the whole document, but starts at the first element that uses the counter. (This affects counters that are used without a prior 'counter-reset' to set the scope explicitly.)

  C.2.89 Section 12.5 Lists

  Removed text in section 12.5 (formerly 12.6) relating to the 'marker' display value.

  Removed the 'marker-offset' property (and thus former section 12.6.1).

  C.2.90 Section 12.5.1 Lists

  The list styles 'hebrew', 'armenian', 'georgian', 'cjk-ideographic', 'hiragana', 'katakana', 'hiragana-iroha' and 'katakana-iroha' have been removed due to lack of implementation experience. (They are expected to return in the CSS3 Lists module.)

  Removed the sentence that said that an unknown value for 'list-style-type' should cause the value 'decimal' to be used instead. Instead, normal parsing rules apply and cause the rule to be ignored.

  The size of list style markers without an intrinsic size is now defined.

  C.2.91 Chapter 13 Paged media

  The 'size', 'marks', and 'page' properties are not part of CSS 2.1.

  C.2.92 Section 13.2.2 Page selectors

  The requirement for UA's to honor different declarations for :left, :right, and :first pages has been softened to simplify implementations: the page area of the :first page may be used for :left and :right pages as well.

  C.2.93 Section 13.3.1 Page break properties

  UAs are now only required to apply the page break properties to block-level elements in the normal flow of the root element, not to other blocks.However, UAs are now permitted to apply these properties to elements other than block-level elements.

  Defined treatment of margins, borders, and padding when a page break splits a box.

  The 'page-break-inside' property no longer inherits.

  C.2.94 Section 13.3.3 Allowed page breaks

  The 'page-break-inside' property of all ancestors is checked for page-breaking restrictions, not just that of the breakpoint's parent.

  When dropping restrictions to find a page breaking opportunity, rule A is dropped together with B and D rather than together with C.

  Removed restriction on breaking within absolutely positioned boxes.

  C.2.95 Section 14.2.1 Background properties

  For 'background-position', the restriction that keywords cannot be combined with percentage or length values is removed. I.e., a value like: '25% top' is now allowed. Also, 'background-position' now applies to all elements, not just to block-level and replaced elements.

  User agents are no longer allowed to treat a value of 'fixed' for 'background-attachment' as 'scroll'. Instead they must ignore all such declarations as if 'fixed' were an invalid value.

  The size of background images without an intrinsic size is now defined.

  C.2.96 Section 14.3 Gamma correction

  The contents of this section is now a non-normative note.

  C.2.97 Chapter 15 Fonts

  The 'font-stretch' and 'font-size-adjust' properties have been removed in CSS 2.1.

  Font descriptors, the '@font-face' declaration, and all associated parts of the font matching algorithm have been removed in CSS 2.1.

  C.2.98 Section 15.2 Font matching algorithm

  In this section (previously 15.5), in step 5 (previously 8) of the font matching algorithm, the UA is now allowed to use multiple default fallback fonts to find a glyph for a given character.

  In the per-property rule 2, specified that if there is only a small-caps font in a given family, then that font will be selected by 'normal'.

  C.2.99 Section 15.2.2 Font family

  The "missing character" glyph is no longer considered a match for the last font in a font set, but is now considered a match for U+FFFD.

  Certain punctuation characters when appearing in unquoted font family names are now required to be escaped.

  C.2.100 Section 15.5 Small-caps

  The 'font-variant' property's effect is no longer restricted to bicameral scripts.

  C.2.101 Section 15.6 Font boldness

  The computed value of 'font-weight' has been defined more precisely such that the 'bolder' and 'lighter' values have an appropriate effect when inheriting through elements with different font-families.

  C.2.102 Section 15.7 Font size

  Removed suggestion of 1.2 fixed ratio between keyword font sizes in favor of notes recommending a variable ratio and a smallest font-size no less than 9 pixels per EM unit.

  Added table mapping CSS font-size keywords to HTML font size numbers.

  C.2.103 Chapter 16 Text

  The 'text-shadow' property is not in CSS 2.1.

  C.2.104 Section 16.2 Alignment

  The initial value of 'text-align' is no longer UA-defined but a nameless value that acts as 'left' if 'direction' is 'ltr', 'right' if 'direction' is 'rtl'.

  The <string> value for 'text-align' is not part of CSS 2.1.

  For 'text-align', specified that 'justify' is treated as the initial value when computed value of 'white-space' is 'pre' or 'pre-line'.

  C.2.105 Section 16.3.1 Underlining, over lining, striking, and blinking

  More precisely defined what boxes are affected by text decorations specified on a given element.

  Specified that underlines, overlines, and line-throughs apply only to text.

  Specified that an underline, overline, or line-through applied across a line must be at a constant vertical position and with a constant thickness across the entire line.

  Specified how text decorations are affected by relative positioning on descendants.

  User agents are now allowed to recognize the 'blink' value but not blink, whereas before they were required to ignore the 'blink' value if they chose not to support blinking text.

  Added text to allow older UAs to conform to this section if they follow CSS2's 'text-decoration' requirements but not the additional requirements in CSS2.1.

  C.2.106 Section 16.4 Letter and word spacing

  Support for the various values of 'letter-spacing' and 'word-spacing' is no longer optional.

  Specified that word spacing affects each space, non-breaking space, and ideographic space left in the text after white space processing rules have been applied.

  C.2.107 Section 16.5 Capitalization

  UAs are no longer allowed to not transform characters for which there is an appropriate transformation but which are outside of Latin-1.

  C.2.108 Section 16.6 White space

  The 'white-space' property now applies to all elements, not just to block-level elements.

  "\A" in generated content no longer forces a break for 'normal' and 'nowrap' values of 'white-space'.

  Specified that the CSS white space processing model assumes all newlines have been normalized to line feeds.

  Added section 16.6.1 to precisely define white space handling.

  Added section 16.6.3 to specify handling of control and combining characters.

  C.2.109 Chapter 17 Tables

  Moved all discussion of aural rendering and related properties to Appendix A.

  Updated prose to use the terms "specified", "computed" and "used" as appropriate when referencing values. (See changes to section 6.1.)

  C.2.110 Section 17.2 The CSS table model

  Defined handling of multiple 'table-header-group' and 'table-footer-group' elements.

  UAs are no longer allowed to ignore the table display values on arbitrary HTML elements, only on HTML table elements.

  C.2.111 Section 17.2.1 Anonymous table objects

  Changed rules so that internal table elements without an enclosing 'table' or 'inline-table' box generate an anonymous 'inline-table' rather than an anonymous 'table' when inside a "display: inline" parent element.

  The anonymous table object rules now treat anonymous boxes as equal to elements' boxes. Replaced several instances of the term "element" with "box", removed several instances of "(in the document tree)" and clarified that anonymous boxes generated in earlier rules are part of the input to later rules. Also replaced the term "object" with "box", as is used throughout the rest of the specification.

  HTML UAs are no longer exempt from the anonymous box generation rules.

  C.2.112 Section 17.4 Tables in the visual formatting model

  The relationship of the caption box, table box, and outer anonymous table box has been changed as follows:

  The margins of the table box now apply to the outer (anonymous) table box that encloses both the table box and the caption(s), not to the inner table box.

    The width of the anonymous box is now equal to the border-box width of the table box inside it instead of adapting to the widths and positions of both the table box and its captions.
  C.2.113 Section 17.4.1 Caption position and alignment

  The 'left' and 'right' values on 'caption-side' have been removed.

  C.2.114 Section 17.5 Visual layout of table contents

  Changed rule 5 in grid layout rules to allow overlapping of table cells instead of leaving skipping a gap in the grid to avoid overlap.

  C.2.115 Section 17.5.1 Table layers and transparency

  In point 6, changed 'These "empty" cells are transparent' to:

  
    If the value of their 'empty-cells' property is 'hide' these "empty" cells are transparent through the cell, row, row group, column, and column group backgrounds, letting the table background show through.
  

  C.2.116 Section 17.5.2.1 Fixed table layout

  Specified that in fixed table layout, extra columns in rows after the first must not be rendered.

  C.2.117 Section 17.5.2.2 Automatic table layout

  Restricted inputs to the table layout algorithm for 'table-layout: auto', whether or not the algorithm described in this section is used, to the width of the containing block and the content of, and any CSS properties set on, the table and any of its descendants.

  Added rule 4 to include the column group's width in the algorithm for determining column widths.

  C.2.118 Section 17.5.3 Table height algorithms

  The 'height' property on tables is now treated as a minimum height; the UA no longer has the option of using 'height' to constrain the size of the table to be smaller than its contents.

  The baseline of a cell is now defined much more precisely.

  Defined the baseline of a row with no baseline-aligned cells.

  C.2.119 Section 17.5.4 Horizontal alignment in a column

  The <string> value for 'text-align' is not part of CSS 2.1.

  C.2.120 Section 17.6 Borders

  Several popular browsers assume an initial value for 'border-collapse' of 'separate' rather than 'collapse' or exhibit behavior that is close to that value, even if they do not actually implement the CSS table model. 'Separate' is now the initial value.

  C.2.121 Section 17.6.1 The separated borders model

  Specified the effect of padding on the table element.

  Specified which parts of the table are included in the width measurement.

  C.2.122 Section 17.6.1.1 Borders and Backgrounds around empty cells

  Refined definition of "empty" when used as a condition for the 'empty-cells' property so that it is not triggered when the cell includes any child elements, even if they are empty.

  The 'empty-cells' property now hides both borders and backgrounds, not just borders.

  Changed behavior of a row when it collapses due to 'empty-cells': it is no longer treated as "display: none". Instead it is given zero height and its associated border-spacing is eliminated.

  C.2.123 Section 17.6.2 The collapsing border model

  The outer half of the table borders no longer lie in the margin area. Specified which part of the table is considered the border are in the collapsed borders model and how its width is calculated. The edges of the box in which the table background is painted is, however left explicitly undefined.

  C.2.124 Section 17.6.2.1 Border conflict resolution

  Defined in rule 4 what happens when two elements of the same type conflict and their borders have the same width and style.

  C.2.125 Section 18.1 Cursors: the 'cursor' property

  The size of cursors without an intrinsic size is now defined.

  C.2.126 Section 18.4 Dynamic outlines

  Position of outline with respect to the border edge is now only suggested, not required.

  Conformant UAs are now allowed to ignore the 'invert' value. In such UAs the initial value of 'outline-color' is the value of the 'color' property.

  C.2.127 Chapter 12 Generated content, automatic numbering, and lists

  The 'marker' value for 'display' does not exist in CSS 2.1

  C.2.128 Appendix A. Aural style sheets

  Chapter 19 on aural style sheets has become appendix A and is not normative in CSS 2.1. Related units (deg, grad, rad, ms, s, Hz, kHz) are also moved to this appendix, as is the 'speak-header' property from the "tables" chapter and other notes on aural table rendering. The 'aural' media type is deprecated in favor of the new 'speech' media type.

  C.2.129 Appendix A Section 5 Pause properties

  Changed the initial value of 'pause-before' and 'pause-after' to be 0 instead of UA-defined.

  A note has been added to this section (formerly 19.4) about the change in position and behavior of pauses in CSS3 Speech compared to this appendix.

  C.2.130 Appendix A Section 6 Cue properties

  This section (formerly Section 19.5) now specifies the placement of cues and pauses with respect to the :before and :after pseudo-elements.

  C.2.131 Appendix A Section 7 Mixing properties

  The keywords 'mix' and 'repeat' may now appear in either order.

  C.2.132 Appendix B Bibliography

  Various references in Appendix B (formerly Appendix E) have been updated as appropriate.

  Switched [CSS1] from Normative to Informative.

  Updated URI reference from [RFC1808] and the draft-fielding-uri-syntax-01.txt to [RFC3986].

  Updated HTTP reference from [RFC2068] to [RFC2616].

  Removed normative references to [IANA] and [ICC32].

  Added normative references to [ICC42], [RFC3986], [RFC2070], [UAAG10].

  Added informative references to CSS2, CSS3 Color, CSS3 Lists, Selectors, CSS3 Speech, DOM 3 Core, MathML 2, P3P, RFC1630, SVG 1.1, XHTML 1, XML ID, and XML Namespaces.

  Removed informative references to [ISO10179] (DSSSL), [INFINIFONT], [ISO9899] (C), [MONOTYPE], [NEGOT], [OPENTYPE], [PANOSE], [PANOSE2], [POSTSCRIPT], [RFC1866] (HTML 2), [RFC1942] (HTML Tables), [TRUETYPEGX], [W3CStyle].

  Updated language tags references from [RFC1766] to [BCP47].

  C.2.133 Other

  The former informative appendix C, "Implementation and performance notes for fonts," is left out of CSS 2.1.

  C.3 Errors

  C.3.1 Shorthand properties

  Shorthand properties take a list of subproperty values or the value 'inherit'. One cannot mix 'inherit' with other subproperty values as it would not be possible to specify the subproperty to which 'inherit' applied. The definitions of a number of shorthand properties did not enforce this rule: 'border-top', 'border-right', 'border-bottom', 'border-left', 'border', 'background', 'font', 'list-style', 'cue', and 'outline'.

  C.3.2 Applies to

  The "applies to" line of many property definitions has been made more accurate by excluding or including table display types where appropriate.

  C.3.3 Section 4.1.1 (and G2)

  DELIM should not have included single or double quote. Refer also to section 4.1.6 on strings, which must have matching single or double quotes around them.

  Removed "A-Z" from the "nmchar" token: as CSS is case insensitive anyway, it was redundant.

  Corrected "unicode" macro to treat CRLF as a single character.

  Corrected "block" production to allow white space between declarations.

  In the rule for "any" (in the core syntax), corrected "FUNCTION" to "FUNCTION any* ')'".

  C.3.4 Section 4.1.3 Characters and case

  Corrected third paragraph to say that an '@import' rule can only be preceded by an '@charset' rule or other '@import' rules.

  C.3.5 Section 4.3 (Double sign problem)

  Several values described in subsections of this section incorrectly allowed two "+" or "-" signs at their beginnings.

  C.3.6 Section 4.3.2 Lengths

  Fixed double sign error in definition of <length>. (<number> already has a sign.)

  Corrected the suggested reference pixel to be based on a 96 dpi device, not 90 dpi. The visual angle is thus about 0.0213 degrees instead of 0.0227, and a pixel at arm's length is about 0.26 mm instead of 0.28

  Corrected last sentence to refer to a unsupported used length, not an unsupported specified length.

  C.3.7 Section 4.3.3 Percentages

  Fixed double sign error in definition of <percentage>. (<number> already has a sign.)

  C.3.8 Section 4.3.4 URLs and URIs

  Defined escaping requirements in terms of the URI token so that no escaping requirements are missing from the prose.

  Included invalid URIs in last paragraph about URI error handling.

  C.3.9 Section 4.3.5 Counters

  Corrected syntax of counter() and counters() notation to allow white space between tokens.

  C.3.10 Section 4.3.6 Colors

  Deleted the comments about range restriction after the following examples:
  
em { color: rgb(255,0,0) }
em { color: rgb(100%, 0%, 0%) }


  C.3.11 Section 4.3.7 Strings

  (Formerly section 4.3.10) Corrected text to allow all forms of Unicode escapes for U+000A, not just the "\A" form, for including newlines in strings.

  C.3.12 Section 5.10 Pseudo-elements and pseudo-classes

  In the second bullet, added that the ':lang()' pseudo-class can also be deduced from the document in some cases.

  C.3.13 Section 6.4 The cascade

  Removed paragraph about imported style sheets being overridden by rules in the importing style sheet: imported style rules follow the cascade as specified in 6.4.1 Cascading order, exactly as if they were inserted in place of the @import rule.

  C.3.14 Section 8.1 Box Dimensions

  The definition of "content edge" has been changed to depend on 'width' and 'height' rather than directly on 'rendered content'.

  From the definition of "padding edge", deleted the sentence "The padding edge of a box defines the edges of the containing block established by the box." For information about containing blocks, consult Section 10.1.

  C.3.15 Section 8.2 Example of margins, padding, and borders

  The colors in the example HTML did not match the colors in the image.

  C.3.16 Section 8.5.4 Border shorthand properties

  Changed various border shorthands' syntax definitions to use the <border-width>, <border-style> and <'border-top-color'> value types as appropriate.

  C.3.17 Section 9.2.1 Block-level elements and block boxes

  Excepted table elements from second paragraph about principal block boxes and their contents.

  Corrected sentence to say "either only block boxes or only inline boxes" instead of "only block boxes".

  C.3.18 Section 9.3.1 Choosing a positioning scheme

  In the definition of "position: static", added 'right' and 'bottom' to the sentence saying that 'top' and 'left' do not apply.

  C.3.19 Section 9.3.2 Box offsets

  The properties 'top', 'right', 'bottom', and 'left', incorrectly referred to offsets with respect to a box's content edge. The proper edge is the margin edge. Thus, for 'top', the description now reads: "This property specifies how far a box's top margin edge is offset below the top edge of the box's containing block."

  Corrected text under property definitions to say that for relatively-positioned elements, 'top', 'right', 'bottom', and 'left' define the offset from the box's position in the normal flow, not from the edges of the containing block. (The previous definition conflicted with that was further down; since that text is now redundant, it has been removed.)

  C.3.20 Section 9.4.1 Block formatting contexts

  In paragraph about relationship of a box's outer edges to its containing block's edges, corrected parenthetical to say that line boxes, not the content area, may shrink due to floats.

  C.3.21 Section 9.4.2 Inline formatting context

  Added "and the presence of floats" to "The width of a line box is determined by a containing block".

  C.3.22 Section 9.4.3 Relative positioning

  In the first paragraph, added "or floated" to the phrase "laid out according to the normal flow" as floated elements can be relatively positioned but are not part of the normal flow.

  C.3.23 Section 9.5 Floats

  Corrected sentence about not enough horizontal room for the float to say that it is shifted downward until either it fits or there are no more floats present.

  C.3.24 Section 9.5.1 Positioning the float

  Correct "Applies to" line and prose to say that the 'float' property can be set for any element but only applies to elements that are not absolutely positioned.

  C.3.25 Section 9.5.2 Controlling flow next to floats

  Removed sentence saying that 'clear' may only be specified for block-level elements: it can be specified for any element, it only applies to block-level elements.

  C.3.26 Section 9.6 Absolute positioning

  Corrected sentence that said absolutely positioned boxes establish a new containing block for absolutely positioned descendants to except fixed positioned descendants.

  C.3.27 Section 9.7 Relationships between 'display', 'position', and 'float'

  In rule 1, corrected "user agents must ignore 'position' and 'float" to "'position' and 'float' do not apply".

  C.3.28 Section 9.10 Text direction

  Corrected note about 'direction' on table column elements to say that "columns are not the ancestors of the cells in the document tree" rather than saying "columns do not exist in the document tree".

  Added table cells, table captions, and inline blocks alongside block-level elements in description of 'bidi-override' value. Also corrected the prose to handle anonymous child blocks.

  Updated mention of Unicode's embedding limit from 15 to 61.

  C.3.29 Section 10.1 Definition of "containing block"

  Included table cells (and inline blocks) together with block-level elements in rule 2 defining the containing block of non-absolutely-positioned elements.

  C.3.30 Section 10.3.3 Block-level, non-replaced elements in normal flow

  In the last sentence of the paragraph following the equation ("If the value of 'direction' is 'ltr', this happens to 'margin-left' instead") substituted 'rtl' for 'ltr'.

  C.3.31 Section 10.4 Minimum and maximum widths

  The initial value for 'min-width' is now '0' rather than UA-dependent.

  Corrected "applies to" exception for both 'min-width' and 'max-width' from "table elements" to "table rows and row groups".

  Specified that negative values for 'min-width' and 'max-width' are illegal.

  C.3.32 Section 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'

  Added that 'auto' height also depends on whether the element has padding or borders, as these influence margin-collapsing behavior.

  Added text to correctly account for margin collapsing behavior.

  C.3.33 Section 10.7 Minimum and maximum heights

  Corrected "applies to" exception for both 'min-width' and 'max-width' from "table elements" to "table columns and column groups".

  Specified that negative values for 'min-height' and 'max-height' are illegal.

  C.3.34 Section 11.1.1 Overflow

  Corrected "applies to" line for 'overflow' from "block-level and replaced elements" to "non-replaced block-level elements, table cells, and inline-block elements".

  The example of a DIV element containing a BLOCKQUOTE containing another DIV was not rendered correctly. The first style rule applied to both DIVs, so the second DIV box should have been rendered with a red border as well. The second DIV has now been changed to a CITE, which does not have a red border.

  C.3.35 Section 11.1.2 Clipping: the 'clip' property

  Corrected "rect (<top> <right> <bottom> <left>)" to "rect(<top>, <right>, <bottom>, <left>)".

  C.3.36 Section 11.2 Visibility

  Corrected initial value of 'visibility' to 'visible'.

  C.3.37 Section 12.4.2 Counter styles

  The example used the style 'hebrew', which does not exist in CSS level 2. Changed to 'lower-greek'.

  C.3.38 Section 12.6.2 Lists

  Under the 'list-style' property, the example:
  
ul > ul { list-style: circle outside } /* Any UL child of a UL */


  could never match valid HTML markup (since a UL element cannot be a child of another UL element). An LI has been inserted in between.

  C.3.39 Section 14.2 The background

  Second sentence: "In terms of the box model, 'background' refers to the background of the content and the padding areas" now also mentions the border area. (See also errata to section 8.1 above.) Thus:

  
    In terms of the box model, "background" refers to the background of the content, padding and border areas.
  

  C.3.40 Section 14.2.1 Background properties

  Under 'background-image', defined the image tile size used when the background image has intrinsic sizes specified in percentages or no intrinsic size.

  Under 'background-repeat', the sentence "All tiling covers the content and padding areas [...]" has been corrected to

  
    "All tiling covers the content, padding and border areas [...]".
  

  Under 'background-attachment', the value 'scroll' is defined to scroll with the "containing block" rather than with the "document". Also the sentence "Even if the image is fixed [...] background or padding area of the element" has been corrected to

  
    Even if the image is fixed, it is still only visible when it is in the background, padding or border area of the element.
  

  C.3.41 Section 15.2 Font matching algorithm

  In bullet 2, changed "the UA uses the 'font-family' descriptor" to "the UA uses the 'font-family' property".

  C.3.42 Section 15.7 Font size

  The statement "Negative values are not allowed" for 'font-size' now applies to percentages as well as lengths.

  C.3.43 Section 16.1 Indentation

  Corrected 'text-indent' to apply to table cells (and inline blocks) as well as block-level elements.

  C.3.44 Section 16.2 Alignment

  Corrected 'text-align' to apply to table cells (and inline blocks) as well as block-level elements.

  Changed prose about the effect of 'justify' to be less correct.

  Corrected the note to say that justification is also dependent on the script, not just the language, of the text.

  C.3.45 Section 17.2 The CSS table model

  In the definition of table-header-group, changed "footer" to "header" in "Print user agents may repeat footer rows on each page spanned by a table."

  C.3.46 Section 17.2.1 Anonymous table objects

  Added 'table-header-group' and 'table-footer-group' alongside mentions of 'table-row-group' where missing.

  Corrected 'caption' to 'table-caption'.

  Added missing rule (#3) for 'table-column' boxes.

  Added 'table-caption' and 'table-column-group' to list of boxes requiring a 'table' or 'inline-table' parent in rule 4.

  Added rules 5 and 6 to generate 'table-row' boxes where necessary for children of 'table'/'inline-table' and 'table-row-group'/'table-header-group'/'table-footer-group' boxes.

  C.3.47 Section 17.4 Tables in the visual formatting model

  Specified handling of multiple caption boxes.

  Specified that the anonymous outer table box is a 'block' box if the table is block-level and an 'inline-block' box if the table is inline-level but that the anonymous outer table box cannot accept run-ins.

  C.3.48 Section 17.5 Visual layout of table contents

  Correct text that said all internal table elements have padding; change to say that of these only table cells have padding.

  The following note:

  
    Note. Table cells may be relatively and absolutely positioned, but this is not recommended: positioning and floating remove a box from the flow, affecting table alignment.
  

  has been amended as follows:

  
    Note. Table cells may be positioned, but this is not recommended: absolute and fixed positioning, as well as floating, remove a box from the flow, affecting table size.
  

  C.3.49 Section 17.5.1 Table layers and transparency

  The rows and columns only cover the whole table in the collapsed borders model, not in the separated borders model.

  The points 2, 3, 4 and 5 have been corrected to define the area covered by rows, columns, row groups and column groups and thus the positioning and painting of backgrounds on those elements.

  Specify the handling of "missing cells".

  C.3.50 Section 17.6.1 The separated borders model

  In the image, changed "cell-spacing" to "border-spacing".

  C.3.51 Section 18.2 System Colors

  For the 'ButtonHighlight' value, changed the description from "Dark shadow" to "Highlight color".

  C.3.52 Section E.2 Painting order

  Changed "but any descendants which actually create a new stacking context" to "but any positioned descendants and descendants which actually create a new stacking context" (3 times).

  This change also occurred once in section 9.5 (Floats) and once in section section 9.9 (Layered presentation).

  C.4 Clarifications

  C.4.1 Section 2.1 A brief CSS 2.1 tutorial for HTML

  This section has been marked non-normative.

  C.4.2 Section 2.2 A brief CSS 2.1 tutorial for XML

  This section has been marked non-normative.

  Added a statement about case-sensitivity of selectors for XML.

  The specification for the XML style sheet PI was written after CSS2 was finalized. The first line of the full XML example should not have been be <?XML:stylesheet type="text/css" href="bach.css"?>, but
  <?xml-stylesheet type="text/css" href="bach.css"?>

  C.4.3 Section 2.3 The CSS 2.1 processing model

  This section has been marked non-normative.

  C.4.4 Section 3.1 Definitions

  Added a note to clarify that the deprecated/non-deprecated status of a feature is distinct from its normative/non-normative status.

  Under 'document language' clarified that CSS only describes the presentation of a document language, and has no effect on its semantics.

  Changed definition of 'replaced element' to "an element whose content is outside the scope of the CSS formatting model" and added further clarifying text. This clarifies that e.g., SVG images embedded in an XML document are also considered replaced elements, not just those linked in from an outside file. Also changed definition of 'rendered content' to be consistent with this clarification.

  Added under "Intrinsic dimension" that raster images without reliable resolution information are assumed to have a size of 1 px unit per image source pixel.

  Added definition for 'ignore'.

  Added definition for 'HTML user agent'.

  Added definition for 'property'.

  C.4.5 Section 4.1 Syntax

  Moved definitions of "immediately before" and "immediately after" forward so they apply to the whole Syntax section.

  Added sections 4.1.2.1 and 4.1.2.2 to defined vendor-specific extensions.

  C.4.6 Section 4.1.1 Tokenization

  Clarified that input that cannot be parsed according to the core syntax is ignored according to the rules for handling parsing errors.

  Clarified that input that cannot be tokenized or parsed has no meaning in CSS2.1.

  C.4.7 Section 4.1.3 Characters and case

  Clarified that when a CRLF pair terminates an escape sequence, the pair is treated as a single white space character as corrected in the tokenization rules.

  Replaced "[a-z0-9]" by "[a-zA-Z0-9]" as an extra reminder that CSS identifiers are case-insensitive.

  C.4.8 Section 4.1.7 Rule sets, declaration blocks, and selectors

  Replaced the term "{}-block" with "declaration block".

  C.4.9 Section 4.2 Rules for handling parsing errors

  Clarified that all property:value combinations and @-keywords that do not contain an identifier beginning with dash or underscore are reserved by CSS for future use.

  Clarified that when something inside an at-rule is ignored because it is invalid, this does not make the entire at-rule invalid.

  Referenced section 4.1.7 for parsing invalid bits inside declaration blocks.

  C.4.10 Section 4.3.1 Integers and real numbers

  Clarified that '-0' is equivalent to '0' and is not a negative number.

  C.4.11 Section 4.3.2 Lengths

  Clarified that negative length values on properties that do not allow them cause the declaration to be ignored.

  C.4.12 Section 4.3.4 URLs and URIs

  Reduced unnecessary discussion of what a URI is.

  C.4.13 Section 5.1 Pattern matching

  Added note about terminology change ("simple selector") between CSS2 and CSS3.

  C.4.14 Section 5.7 Adjacent sibling selectors

  Clarified that text nodes and comments do not affect whether a sibling selector matches.

  C.4.15 Section 5.8.1 Matching attributes and attribute values

  Clarified ~= and |= by using the definitions from the Selectors module.

  C.4.16 Section 5.8.2 Default attribute values in DTDs

  Clarified that rules about default attribute values are the same, whether the default is specified in a DTD or by other means.

  C.4.17 Section 5.9 ID selectors

  Added a note that it depends on the document format which attributes are ID attributes.

  C.4.18 Section 5.11.3 The dynamic pseudo-classes: :hover, :active, and :focus

  Clarified that CSS 2.1 does not define if the parent of an element that matches ':active' or ':hover' itself also matches ':active' or ':hover'.

  Added note that, in CSS1, ':active' only applies to links.

  C.4.19 Section 5.11.4 The language pseudo-class: :lang

  Added a note to show the differences between ':lang(xx)' and '[lang=xx]'.

  C.4.20 Section 5.12.2 The :first-letter pseudo-element

  Clarified that digits can also be first letter.

  C.4.21 Section 6.2 Inheritance

  Clarified that computed values are inherited (not specified values) and that they become the specified value on the inheritor.

  Removed discussion of "default" styles for a document.

  C.4.22 Section 6.2.1 The 'inherit' value

  Clarify that 'inherit' can be used on properties that are not normally inherited and that when set on the root element, it has the effect of assigning the property's initial value.

  C.4.23 Section 6.3 The @import rule

  Except @charset from the statement that @imports must precede all other rules.

  C.4.24 Section 6.4 The Cascade

  Obfuscated note about system settings and UA limitations.

  C.4.25 Section 6.4.1 Cascading order

  Various editorial changes to clarify sort order.

  C.4.26 Section 6.4.3 Calculating a selector's specificity

  Added a note:

  
    The specificity is based only on the form of the selector. In particular, a selector of the form "[id=p33]" is counted as an attribute selector (a=0, b=1, c=0), even if the id attribute is defined as an "ID" in the source document's DTD.
  

  C.4.27 Section 7.2.1 The @media rule

  Clarify that Style rules outside of @media rules apply to the same media types that the style sheet itself applies to.

  C.4.28 Section 7.3 Recognized media types

  Added text to clarify that media types are mutually exclusive, but a UA can render simultaneously to canvases with different media types.

  C.4.29 Section 7.3.1 Media groups

  Split "aural" media group into "audio" and "speech".

  C.4.30 Section 8.1 Box dimensions

  The terms "content box", "padding box", "border box", and "margin box" have been defined.

    Border backgrounds are not specified by border properties. Changed the last paragraph of 8.1 to:

      
        The background style of the content, padding, and border areas of a box is specified by the 'background' property of the generating element. Margin backgrounds are always transparent.
      
    

    Removed definition of "box width" and "height".
  C.4.31 Section 8.3 Margin properties

  Added a sentence to note that vertical margins have no effect on non-replaced inline elements.

  C.4.32 Section 8.3.1 Collapsing margins

  Changed "absolute maximum" to "maximum of the absolute values" in sentence about negative margins collapsing.

  Added this clarifying note to the first bullet of the explanation of vertical collapsing of margins:

  
    Note. Adjoining boxes may be generated by elements that are not related as siblings or ancestors.
  

  Emphasized that floating elements' margins do not collapse even between a float and its in-flow children.

  Emphasized that absolutely positioned elements' margins do not collapse even between the positioned element and its in-flow children.

  C.4.33 Section 8.5.3 Border style

  Changed description of 'none' value to not imply that all four border widths are set to zero.

  C.4.34 Section 9.1.1 The viewport

  Changed the sentence "When the viewport is smaller than the ..., the user agent should offer a scrolling mechanism" to use "area of the canvas on which the document is rendered" instead of "document's initial containing block".

  C.4.35 Section 9.2.4 The 'display' property

  Clarified that 'display: none' also applies to non-visual media.

  C.4.36 Section 9.3.1 Choosing a positioning scheme

  Clarified that the margins of fixed positioned boxes do not collapse with any other margins.

  Clarified that in print media fixed boxes are rendered on every page.

  C.4.37 Section 9.3.2 Box offsets

  Clarified that negative lengths and percentages are allowed as values of 'top', 'right', 'bottom', and 'left'.

  Added "For replaced elements, the effect of this value depends only on the intrinsic dimensions of the replaced content. See the sections on the width and height of absolutely positioned, replaced elements for details." to the definition of 'auto' because that's not what chapter 10 says at all.

  C.4.38 Section 9.4.2 Inline formatting context

  Clarified that 'justify' stretches "spaces and words in inline boxes"; previous text simply said that it stretches "inline boxes".

  The statement "When an inline box is split, margins, borders, and padding have no visual effect where the split occurs." has been generalized. Margins, borders, and padding have no visual effect where one or more splits occur.

  Clarified that an inline box that exceeds the width of a line box and cannot be split therefore overflows the line box.

  Removed sentence about formatting of margins, borders, and padding for split inline boxes not being fully defined when affected by bidi as that situation is now defined in section 8.6.

  C.4.39 Section 9.4.3 Relative positioning

  Clarified that although relative positioning normally does not directly affect layout, it may affect layout indirectly through the creation of scrollbars.

  Relatively positioned boxes do not always establish new containing blocks. Changed the second paragraph to refer to the section on containing blocks accordingly.

  The paragraph about dynamic movement and superscripting has been shifted into a non-normative note.

  C.4.40 Section 9.5 Floats

  Clarified that line boxes are shortened to make room for the margin box of the float.

  Added some text to clarify what "Any content in the current line before a floated box is reflowed in the first available line on the other side of the float" means.

  Clarified floats' position in the stacking order.

  C.4.41 Section 9.5.1 Positioning the float

  Clarified that the elements referenced in the float behavior rules are in the same block formatting context as the float.

  C.4.42 Section 9.5.2 Controlling flow next to floats

  Clarified that the effects of 'clear' do not consider floats in other block formatting contexts.

  C.4.43 Section 9.8 Comparison of normal flow, floats, and absolute positioning

  Added a note to clarify that the images in this section are not drawn to scale and are illustrations, not reference renderings.

  C.4.44 Section 10.1 Definition of "containing block"

  Noted that a containing block formed by inline elements may wind up with a negative containing block width.

  C.4.45 Section 10.2 Content width

  In the definition of <length> values for the 'width' property, changed "Specifies a fixed width" to "Specifies the width of the content area using a length unit".

  C.4.46 Section 10.3.3 Block-level, non-replaced elements in normal flow

  Clarified that setting both left and right margins to 'auto' horizontally centers the element within its containing block.

  C.4.47 Section 10.3.8 Absolutely positioning, replaced elements

  Clarified which part of the text of section 10.3.7 is re-used.

  C.4.48 Section 10.4 Minimum and maximum widths

  Clarified that 'min-width' and 'max-width' do not affect the computed values of any properties. (They only affect the used value.)

  C.4.49 Section 10.6 Calculating heights and margins

  Clarified that these rules apply to the root element just as to any other element.

  C.4.50 Section 10.7 Minimum and maximum heights

  Clarified that 'min-width' and 'max-width' do not affect the computed values of any properties. (They only affect the used value.)

  C.4.51 Section 10.8 Line height calculations

  Removed clarifying note about line height being taller than tallest single inline box due to vertical alignment.

  C.4.52 Section 10.8.1 Leading and half-leading

  Removed "slightly" from the note "Values of this property have slightly different meanings in the context of tables."

  C.4.53 Section 11.1 Overflow and clipping

  Clarified when absolute positioning and negative margins cause overflow.

  Added 'text-indent' to the list of things that can cause overflow.

  Removed mention of 'clip' since it no longer affects most elements; mentioned that the 'overflow' property also specifies whether a scrolling mechanism is provided to access clipped content.

  C.4.54 Section 11.1.1 Overflow

  Clarified that descendant elements whose containing block is the viewport or an ancestor of the element are not affected by overflow clipping.

  Removed unnecessary mentions of the 'clip' property from the 'hidden' value definition.

  C.4.55 Section 11.1.2 Clipping

  Changed "portion of an element's rendered content" to "portion of an element's border box" since clipping also affects the element's backgrounds and borders.

  Clarified what parts of the element are affected by clipping.

  Clarified that clipped content does not cause overflow.

  Clarified that arguments of clip() can be separated by spaces or by commas, but not a combination.

  C.4.56 Section 11.2 Visibility

  Clarified that descendants of a 'visibility: hidden' element will be visible if they have 'visibility: visible'.

  C.4.57 Section 12.1 The :before and :after pseudo-elements

  Clarified that :before and :after pseudo-elements interact with other boxes as if they were real elements just inside their associated element.

  Noted that the interaction of :before and :after with replaced elements is left undefined for now.

  C.4.58 Section 12.2 The 'content' property

  Clarified which counters are used for counter() and counters() in case there are multiple counters of the same name.

  C.4.59 Section 12.3.2 Inserting quotes with the 'content' property

  Removed note about common typographic practices when quotes in different languages are mixed.

  C.4.60 Section 12.4 Automatic counters and numbering

  In the "self-nesting" behavior of counters, clarified that merely using a counter in a child element does not create a new instance of it: only resetting it does.

  Clarified that the scope of a counter does not include any elements in the scope of a counter with the same name created by a 'counter-reset' on a later sibling or a later 'counter-reset' on the same element.

  Removed sentence about scope of 'counter-increment' without prior 'counter-reset' as that is now defined (differently) under "12.4.1 Nested counters and scope."

  C.4.61 Section 12.4.3 Counters in elements with 'display: none'

  Clarified that pseudo-elements that generate no boxes also do not increment counters.

  C.4.62 Section 14.2 The background

  Clarified that the root background image, although painted over the entire canvas, is anchored as if painted only for the root element, and that the root's background is only painted once.

  Clarified rules for propagation of background settings on HTML's <body> element to the root.

  Added statement about z-index of backgrounds for elements that form a stacking context and referred to z-index property for details.

  Added this note after the first paragraph after 'background-attachment':

  
    Note that there is only one viewport per document. I.e., even if an element has a scrolling mechanism (see 'overflow'), a 'fixed' background does not move with it.
  

  Definition of 'background-position' has been rewritten as normative rules rather than just examples.

  Stated that the tiling and positioning of background images for inline elements is undefined in CSS2.1.

  C.4.63 Section 15.1 Fonts Introduction

  Drastically shortened introduction.

  C.4.64 Section 15.2 Font matching algorithm

  In the per-property rule 2, clarified that 'normal' matches the non-small-caps variant (if there is one).

  C.4.65 Section 15.2.2 Font family

  Removed discussion of font-matching algorithm. (It is already covered in the font-matching algorithm's own section.

  Clarified that quoted strings that are the same as a keyword value must be treated as font family names and not as the keyword value (which must be unquoted).

  C.4.66 Section 15.3.1 Generic font families

  This section, previously section 15.2.6, has been moved but no other change was made.

  C.4.67 Section 15.4 Font styling

  The text for this section (formerly part of 15.2.3) has been reverted to its CSS1 format.

  C.4.68 Section 15.5 Small-caps

  The text for this section (formerly part of 15.2.3) has been reverted to its CSS1 format.

  Clarified that CSS2.1 cannot select font variants besides small-caps.

  Clarified that when "font-variant: small-caps" results in the substitution of full-caps, the behavior is the same as for text-transform.

  C.4.69 Section 15.6 Font boldness

  The text for this section (formerly part of 15.2.3) has been reverted to its CSS1 format. Also, discussion of font-weight from other parts of the Fonts chapter has been aggregated under this section.

  Removed statement that says "User agents must map names to values in a way that preserves visual order; a face mapped to a value must not be lighter than faces mapped to lower values." This is otherwise implied by "The only guarantee is that a face of a given value will be no less dark than the faces of lighter values."

  C.4.70 Section 15.7 Font size

  Clarified relationship of font size to em squares.

  Added a totally irrelevant note about font sizes virtual reality scenes.

  C.4.71 Section 16.1 Indentation

  Clarified that text overflowing due to text-indent is affected by the 'overflow' property.

  Added a note about text-indents inheriting behavior and suggesting 'text-indent: 0' on inline-blocks.

  C.4.72 Section 16.2 Alignment

  Changed "double justify" to "justify" under "left, right, center, and justify".

  C.4.73 Section 16.3.1 Underlining, over lining, striking, and blinking

  Added an example to illustrate how underlining affects descendant boxes.

  C.4.74 Section 16.5 Capitalization

  Switched language reference from RFC2070 to BCP47.

  C.4.75 Section 16.6 White space

  Added section 16.6.1 as an example to illustrate the interaction of white space collapsing and bidi.

  C.4.76 Section 17.1 Introduction to tables

  Expanded introduction to include a brief discussion of the two table layout models. Mentioned that the automatic table algorithm is not fully defined in CSS 2.1 but that some implementations have achieved relatively close interoperability.

  C.4.77 Section 17.2 The CSS table model

  Clarify that all table captions must be rendered if more than one exists.

  Specified that replaced elements with table display values are treated as table elements in table layout.

  C.4.78 Section 17.2.1 Anonymous table objects

  Moved the first bullet text to the prose before the list of generation rules as it is a general statement of what the rules are supposed to accomplish.

  C.4.79 Section 17.4 Tables in the visual formatting model

  Clarified that "display: table" elements behave as block-level elements and "display: inline-table" elements behave as inline-level elements and not the other way around.

  Clarified that 'table-caption' boxes behave as normal block boxes within the outer anonymous table box.

  Clarified that percentage 'width' and 'height' on the table box is relative to the anonymous box's containing block, not the anonymous box itself.

  Clarified that the 'position', 'float', 'top', 'right', 'bottom', and 'left' values on the table box are used on the anonymous outer box instead of the table box and that the table box itself uses the initial values of those properties.

  C.4.80 Section 17.5 Visual layout of table contents

  To remove ambiguity about the position of extent of internal table boxes, the following paragraph was added after point 6:

  
    the edges of the rows, columns, row groups and column groups in the collapsing borders model coincide with the hypothetical grid lines on which the borders of the cells are centered. (And thus, in this model, the rows together exactly cover the table, leaving no gaps; ditto for the columns.) In the separated borders model, the edges coincide with the border edges of cells. (And thus, in this model, there may be gaps between the rows and columns, corresponding to the 'border-spacing' property.)
  

  Changed warning note about positioning of table cells to be more precise about the possibly unintended effects.

  C.4.81 Section 17.5.1 Table layers and transparency

  At the end of the section added the following paragraph:

  
    Note that if the table has 'border-collapse: separate', the background of the area given by the 'border-spacing' property is always the background of the table element. See 17.6.1
  

  C.4.82 Section 17.5.2 Table width algorithms

  Added a paragraph to clarify the interaction of the table width algorithms with the rules in section 10.3 (Calculating widths and margins).

  C.4.83 Section 17.5.2.1 Fixed table layout

  Explicitly mentioned that the fixed table layout algorithm may be used with the algorithm of section 10.3.3 when 'table-layout' is 'fixed' but 'width' is 'auto'.

  C.4.84 Section 17.5.2.2 Automatic table layout

  Clarified that UAs can use other algorithms besides the one in this section even if it results in different behavior. Also marked the rest of the section non-normative in accordance with that statement.

  C.4.85 Section 17.5.4 Horizontal alignment in a column

  Changed "The horizontal alignment of a cell's content within a cell box is specified with the 'text-align' property" to "The horizontal alignment of a cell's inline content within a cell box can be specified with the 'text-align' property."

  C.4.86 Section 17.5.5 Dynamic row and column effects

  Clarified that not affecting layout means that 'visibility: collapse' causes the part of row- and column-spanning cells that span into the collapsed row to be clipped.

  C.4.87 Section 17.6.1 The separated borders model

  Added a note explaining that 'border-spacing' can be used as a substitute for the non-standard 'framespacing' attribute on frameset elements (which are out-of-scope for CSS2.1).

  Added clarification about backgrounds: the sentence "This space is filled with the background of the table element" was replaced by:

  
    In this space, the row, column, row group, and column group backgrounds are invisible, allowing the table background to show through.
  

  C.4.88 Section 17.6.2 The collapsing borders model

  In the sentence after the question, added "and padding-lefti and padding-righti refer to the left (resp., right) padding of cell i."

  C.4.89 Section 18.2 System Colors

  Noted that system colors are deprecated in CSS3.

  C.4.90 Section 18.4 Dynamic outlines

  Clarified that outlines do not cause overflow.

  Clarified that outlines are only fully connected "if possible".

  C.4.91 Section 18.4.1 Outlines and the focus

  Clarify that changing outlines in response to focus should not cause a document to reflow.

  C.4.92 Appendix D Default style sheet for HTML 4

  Added paragraph clarifying that some presentational markup in HTML can be replaced with CSS, but it requires different markup.

  C.5 Errata since the Candidate Recommendation of July 2007

  Errata to CSS 2.1 since CR version of July 19, 2007.

  C.5.1 Section 1.4.2.1 Value

  [2009-04-15] The notation “&&” may be used in syntax definitions in future CSS specifications.

  C.5.2 Section 2.3 The CSS 2.1 processing model

  [2008-08-19] The first part of the section is not normative.

  C.5.3 Section 3.1 Definitions

  [2007-11-14] Append For raster images without reliable resolution information, a size of 1 px unit per image source pixel must be assumed. to the definition of intrinsic dimensions.

  C.5.4 Section 4.1.1 Tokenization

  [2007-09-27] Remove DELIM? from the grammar rule
  declaration : DELIM? property S* ':' S* value;

  The DELIM was allowed there so that unofficial properties could start with a dash (-), but the dash was already allowed because of the definition of IDENT.

  [2009-02-02] Change U to u in token UNICODE-RANGE. (It means the same, but seems to avoid confusion.)

  [2009-02-02] Clarify where comments are allowed:

  
    COMMENT tokens do not occur in the grammar (to keep it readable), but any number of these tokens may appear anywhere between outside other tokens. (Note, however, that a comment before or within the @charset rule disables the @charset.)
  

  C.5.5 Section 4.1.2.2 Informative Historical Notes

  [2008-12-09] Other known vendor prefixes are: -xv-, -ah-, prince-, -webkit-, and -khtml-.

  C.5.6 Section 4.1.3 Characters and case

  [2007-11-14] In the second bullet, change [a-z0-9] to [a-zA-Z0-9]; in the third bullet, change [0-9a-f] to [0-9a-fA-F].

  Although the preceding bullet already says that CSS is case-insensitive, the explicit mention of upper and lower case letters helps avoid mistakes.

  C.5.7 Section 4.1.3 Characters and case

  [2008-03-05] CSS is now case-sensitive, except for certain parts:

  
    All CSS syntax is case-insensitive within the ASCII range (i.e., [a-z] and [A-Z] are equivalent), except for parts that are not under the control of CSS.
  

  C.5.8 Section 4.1.3 Characters and case

  [2008-12-02] The pair “*/” ends a comment, even if preceded by a backslash. Change this sentence in the third bullet:

  
    Except within CSS comments, any character (except a hexadecimal digit) can be escaped with a backslash to remove its special meaning.
  

  C.5.9 Section 4.1.3 Characters and case

  [2009-04-15] Text added to match the grammar:

  
    […] any character (except a hexadecimal digit , linefeed, carriage return or form feed) can be escaped […]
  

  C.5.10 Section 4.1.5 At-rules

  [2009-04-15] Clarified that unknown statements are ignored when looking for @import:

  
    CSS 2.1 user agents must ignore any '@import' rule that occurs inside a block or after any valid non-ignored statement other than an @charset or an @import rule.
  

  C.5.11 Section 4.1.7 Rule sets, declaration blocks, and selectors

  [2008-11-26] More precise statement of what is ignored:

  
    When a user agent cannot parse the selector (i.e., it is not valid CSS 2.1), it must ignore the selector and the following declaration block (if any) as well.
  

  C.5.12 Section 4.2 Rules for handling parsing errors

  [2009-04-15] Added error recovery rule for unexpected tokens at the top level:

  
    Malformed statements. User agents must handle unexpected tokens encountered while parsing a statement by reading until the end of the statement, while observing the rules for matching pairs of (), [], {}, "", and '', and correctly handling escapes. For example, a malformed statement may contain an unexpected closing brace or at-keyword. E.g., the following lines are all ignored:
    
p @here {color: red}     /* ruleset with unexpected at-keyword "@here" */
@foo @bar;               /* at-rule with unexpected at-keyword "@bar" */
}} {{ - }}               /* ruleset with unexpected right brace */
) [ {} ] p {color: red } /* ruleset with unexpected right parenthesis */

  

  C.5.13 Section 4.2 Rules for handling parsing errors

  [2008-11-26] Change “or block” as follows:

  
    User agents must ignore an invalid at-keyword together with everything following it, up to and including the next semicolon (;), or block ({...}) the next block ({...}), or the end of the block (}) that contains the invalid at-keyword, whichever comes first.
  

  C.5.14 Section 4.3.2 Lengths

  [2008-08-19] Add recommendation about size of px:

  
    […] the user agent should rescale pixel values. It is recommended that the pixel unit refer to the whole number of device pixels that best approximates the reference pixel.
  

  C.5.15 Section 4.3.5 Counters

  [2008-03-05] Insert case-sensitive in Counters are denoted by case-sensitive identifiers.

  C.5.16 Section 5.8.1 Matching attributes and attribute values

  [2008-04-07] Clarified ~= and |= by using the definitions from the Selectors module.

  [2008-11-03] Clarified that [foo~=""] (i.e., with an empty value) will not match anything.

  C.5.17 Section 5.8.2 Default attribute values in DTDs

  [2007-11-14] Replace tag selector by type selector.

  C.5.18 Section 5.11.4 The language pseudo-class: :lang

  [2009-04-15] The language code is case-insensitive.

  C.5.19 Section 5.12.3 The :before and :after pseudo-elements

  [2008-11-03] Clarified text:

  
    When the :first-letter and :first-line pseudo-elements are combined with applied to an element having content generated using :before and :after, they apply to the first letter or line of the element including the inserted text generated content.
  

  C.5.20 Section 6.3 The @import rule

  [2008-08-19] Add “In CSS 2.1” and “See the section on parsing for when user agents must ignore @import rules” to

  
    In CSS 2.1, any @import rules must precede all other rules (except the @charset rule, if present). See the section on parsing for when user agents must ignore @import rules.
  

  C.5.21 Section 6.3 The @import rule

  [2008-11-26] Define what it means to import a style sheet twice and how the media list is matched. Add at the end:

  
    In the absence of any media types, the import is unconditional. Specifying 'all' for the medium has the same effect. The import only takes effect if the target medium matches the media list.

    A target medium matches a media list if one of the items in the media list is the target medium or 'all'.

    Note that Media Queries [MEDIAQ] extends the syntax of media lists and the definition of matching.

    When the same style sheet is imported or linked to a document in multiple places, user agents must process (or act as though they do) each link as though the link were to a separate style sheet.
  

  C.5.22 Section 6.4.1 Cascading order

  [2007-11-22] Spelling error: precendence.

  C.5.23 Section 6.4.1 Cascading order

  [2008-11-26] Define the meaning of a media list:

  
    Find all declarations that apply to the element and property in question, for the target media type. Declarations apply if the associated selector matches the element in question and the target medium matches the media list on all @media rules containing the declaration and on all links on the path through which the style sheet was reached.
  

  C.5.24 Section 7.2.1 The @media rule

  [2008-12-02] The rules for parsing unknown statements inside @media blocks were ambiguous. Change the first sentence as follows:

  
    An @media rule specifies the target media types (separated by commas) of a set of rules statements (delimited by curly braces). Invalid statements must be ignored per 4.1.7 "Rule sets, declaration blocks, and selectors" and 4.2 "Rules for handling parsing errors."
  

  Also make it explicit that CSS level 2 (unlike higher levels) has no nested @-rules. Add at the end of the section: “At-rules inside @media are invalid in CSS 2.1.”

  C.5.25 Section 8.3.1 Collapsing margins

  [2008-08-18] In bullet 6, sub-bullet 2, the position of the top border edge is determined by assuming the element has a non-zero bottom (not: top) border.

  C.5.26 Section 8.3.1 Collapsing margins

  [2009-02-02] Rephrased the rule for adjoining margins so that the 'min-height' and 'max-height' of an element have no influence over whether the element's bottom margin is adjoining to its last child's bottom margin.

  C.5.27 Section 8.3.1 Collapsing margins

  [2008-12-02] Not only elements with 'overflow' other than 'visible', but all block formatting contexts avoid collapsing their margins with their children. Change the third bullet as follows:

  
    Vertical margins of elements with 'overflow' other than 'visible' that establish new block formatting contexts (such as floats and elements with 'overflow' other than 'visible') do not collapse with their in-flow children.
      
    

  C.5.28 Section 9.2.2 Inline-level elements and inline boxes

  [2008-12-02] Added missing 'inline-block' in: “Several values of the 'display' property make an element inline: 'inline', 'inline-table', 'inline-block' and 'run-in' (part of the time; see run-in boxes).”

  C.5.29 Section 9.2.4 The 'display' property

  [2008-04-07] Clarified that 'display: none' also applies to non-visual media.

  C.5.30 Section 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

  [2008-08-19] Remove true but confusing note (occurs 4×):

  
    Note: For absolutely positioned elements whose containing block is based on a block-level element, this property is an offset from the padding edge of that element.
  

  C.5.31 Section 9.5 Floats

  [2008-08-19] Positioned descendants of a float are in the stacking context of the float's parent. Add “positioned elements and” to

  
    […] except that any positioned elements and elements that actually create new stacking contexts take part in the float's parent's stacking context.
  

  Same change in Section 9.9 Layered presentation:

  
    […] except that any positioned elements and any elements that actually create new stacking contexts take part in the parent stacking context.”
  

  C.5.32 Section 9.5 Floats

  [2008-12-02] Remove “'s” that may be misinterpreted: “the float's parent's stacking context.”

  C.5.33 Section 9.5.2 Controlling flow next to floats: the 'clear' property

  [2009-02-02] Add an example of negative clearance after the first note.

  C.5.34 Section 9.6.1 Fixed positioning

  [2008-11-03] Added:

  
    Boxes with fixed position that are larger than the page box are clipped. Parts of the fixed position box that are not visible in the initial containing block will not print.
  

  C.5.35 Section 9.9.1 Specifying the stack level: the 'z-index' property

  [2008-12-02] The list of stacking levels is ambiguous: relatively positioned elements could fall under items 3/4/5 or under item 6. Meant is item 6, so exclude them from 3/4/5 as follows:

  
    the background and borders of the element forming the stacking context.

      the stacking contexts of descendants with negative stack levels.

      a stacking level containing in-flow non-inline-level non-positioned descendants.
      

      a stacking level for non-positioned floats and their contents.
      

      a stacking level for in-flow inline-level non-positioned descendants.
      

      a stacking level for positioned descendants with 'z-index: auto', and any descendant stacking contexts with 'z-index: 0'.

      the stacking contexts of descendants with positive stack levels.
    

  C.5.36 Section 10.1 Definition of "containing block"

  [2009-02-02] Rephrase first bullet point to make easier to read:

  
    The containing block in which the root element lives is a rectangle with the dimensions of the viewport, anchored at the canvas origin for continuous media, and the page area for paged media. This containing block is called the initial containing block.
  

  
    The containing block in which the root element lives is a rectangle called the initial containing block. For continuous media, it has the dimensions of the viewport and is anchored at the canvas origin; it is the page area for paged media.
  

  C.5.37 Section 10.3 Calculating widths and margins

  [2009-04-15] The values of 'left' and 'right' are only determined by section 9.4.3 in the case of relatively positioned elements:

  
    For Points 1-6 and 9-10, the values of 'left' and 'right' used for layout in the case of relatively positioned elements are determined by the rules in section 9.4.3.
  

  C.5.38 Section 10.3.1 Inline, non-replaced elements

  [2009-04-15] The only case in which 'left' or 'right' can be 'auto' is when the element is statically positioned. In that case 'left' and 'right are ignored and there is thus no need to determine a used value:

  
    A computed value of 'auto' for 'left', 'right', 'margin-left' or 'margin-right' becomes a used value of '0'.
  

  C.5.39 Section 10.3.2 Inline, replaced elements

  [2007-11-14] Add the following paragraph:

  
    Otherwise, if 'width' has a computed value of 'auto', and the element has an intrinsic width, then that intrinsic width is the used value of 'width'.
  

  just before the paragraph beginning Otherwise, if 'width' has a computed value of 'auto', but none of the conditions above are met, […].

  C.5.40 Section 10.3.2 Inline, replaced elements

  [2008-03-05] Change the last paragraph as follows:

  
    If it does, then a percentage intrinsic width on that element cannot be resolved and the element is assumed to have no intrinsic width then the resulting layout is undefined in CSS2.1.
  

  C.5.41 Section 10.3.3 Block-level, non-replaced elements in normal flow

  [2008-03-05] Scrollbar widths are no longer included in the containing block width. Remove scrollbar width from:

  
    'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + scrollbar width (if any) = width of containing block
  

  and from:

  
    If 'width' is not 'auto' and 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + scrollbar width (if any) [...]
  

  and remove the paragraph:

  
    The "scrollbar width" value is only relevant if the user agent uses a scrollbar as its scrolling mechanism. See the definition of the 'overflow' property.
  

  C.5.42 Section 10.3.7 Absolutely positioned, non-replaced elements

  [2008-03-05] Scrollbar widths are no longer included in the containing block width. Remove scrollbar width from:

  
    'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + 'right' + scrollbar width (if any) = width of containing block
  

  and remove the paragraph:

  
    The "scrollbar width" value is only relevant if the user agent uses a scrollbar as its scrolling mechanism. See the definition of the 'overflow' property.
  

  C.5.43 Section 10.3.7 Absolutely positioned, non-replaced elements

  [2008-03-05] Add the following definition.

  [2008-08-19] Add the following note to that definition.

  
    The static-position containing block is the containing block of a hypothetical box that would have been the first box of the element if its specified 'position' property had been 'static' and its 'float' had been 'none'. (Note that due to the rules in section 9.7 this hypothetical calculation might require also assuming a different computed value for 'display'.)
  

  And change which 'direction' property is used as follows (two occurrences):

  
    [...] if the 'direction' property of the element establishing the static-position containing block is [...]
  

  C.5.44 Section 10.3.8 Absolutely positioned, replaced elements

  [2008-03-05] Change bullet 2 as follows:

  
    [...] if the 'direction' property of the element establishing the static-position containing block is [...]
  

  C.5.45 Section 10.3.8 Absolutely positioned, replaced elements

  [2008-03-05] Clarification. Replace

  
    This situation is similar to the previous one, except that the element has an intrinsic width. The sequence of substitutions is now:
  

  by

  
    In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
  

  C.5.46 Section 10.3.8 Absolutely positioned, replaced elements

  [2008-04-07] Clarified that margins are not calculated as for inline elements.

  C.5.47 Section 10.5 Content height: the 'height' property

  Under “<percentage>,” add the same note as under “<percentage>,” in section 10.2 (“Content width: the 'width' property”).

  C.5.48 Section 10.6.2 Inline replaced elements […]

  [2007-11-14] Add the following paragraph:

  
    Otherwise, if 'height' has a computed value of 'auto', and the element has an intrinsic height, then that intrinsic height is the used value of 'height'.
  

  just before the paragraph beginning Otherwise, if 'height' has a computed value of 'auto', but none of the conditions above are met […].

  C.5.49 Section 10.6.4 Absolutely positioned, non-replaced elements

  [2008-11-26] The static position is determined considering neither float nor clear. Add this:

  
    […] and its specified 'float' had been 'none' and 'clear' had been 'none'.
  

  C.5.50 Section 10.6.5 Absolutely positioned, replaced elements

  [2008-04-07] Clarified that margins are not calculated as for inline elements.

  C.5.51 Section 10.8.1 Leading and half-leading

  [2007-11-14] In the Note under 'vertical-align', remove slightly from Values of this property have slightly different meanings in the context of tables.

  C.5.52 Section 11.1.1 Overflow: the 'overflow' property

  [2008-03-05] Scrollbar widths are no longer included in the containing block width. Replace

  
    The space taken up by the scrollbars affects the computation of the dimensions in the rendering model.
  

  by

  
    Any space taken up by the scrollbars should be taken out of (subtracted from the dimensions of) the containing block formed by the element with the scrollbars.
  

  [2008-11-03] 'Overflow' on BODY is special not only in HTML but also in XHTML. Change the sentence “HTML UAs must instead apply the 'overflow' property from the BODY element to the viewport, if the value on the HTML element is 'visible'.” to:

  
    When the root element is an HTML "HTML" element or an XHTML "html" element, and that element has an HTML "BODY" element or an XHTML "body" element as a child, user agents must instead apply the 'overflow' property from the first such child element to the viewport, if the value on the root element is 'visible'.
  

  C.5.53 Section 11.1.2 Clipping: the 'clip' property

  [2008-03-05] Insert (but not a combination) in User agents must support separation with commas, but may also support separation without commas (but not a combination).

  C.5.54 Section 12.2 The 'content' property

  [2009-04-15] (And also in section 12.4:) certain keywords, in particular 'none', 'inherit' and 'initial' (the latter being reserved for future use) cannot be used as names for counters.

  C.5.55 Section 12.4.2 Counter styles

  [2008-03-05] Error in example. Replace hebrew by lower-greek:
  BLOCKQUOTE:after { content: " [" counter(bq, hebrew lower-greek) "]" }

  C.5.56 Section 12.5 Lists

  [2008-12-01] Change “in” to “with respect to” in

  
    The list properties describe basic visual formatting of lists: they allow style sheets to specify the marker type (image, glyph, or number), and the marker position in with respect to the principal box (outside it or within it before content).
  

  because the marker is, as the rest of the sentence itself makes clear, not necessarily in the principal box.

  C.5.57 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2008-04-07] The size of list style markers without an intrinsic size is now defined.

  C.5.58 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2008-12-01] CSS 2.1 does not specify the position of the list item marker, but does require it to be on the left or right of the content. Also, the marker is not affected by 'overflow', but may influence the height of the principal box. Add to the definition of 'outside':

  
    … but does require that for list items whose 'direction' property is 'ltr' the marker box be on the left side of the content and for elements whose 'direction' property is 'rtl' the marker box be on the right side of the content. 'Overflow' on the element does not clip the marker box. The marker box is fixed with respect to the principal block box's border and does not scroll with the principal block box's content. The size or contents of the marker box may affect the height of the principal block box and/or the height of its first line box, and in some cases may cause the creation of a new line box. Note: This interaction may be more precisely defined in a future level of CSS.
  

  C.5.59 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2009-04-015] Meaning of 'none' for 'list-style' was only defined by an example.

  C.5.60 Section 13.2 Page boxes: the @page rule

  [2008-08-19] Add rules for drawing canvas to:

  
    The page area. The page area includes the boxes laid out on that page. The edges of the first page area establish the rectangle that is the initial containing block of the document. The canvas background is painted within and covers the page area.
      

      The margin area, which surrounds the page area. The page margin area is transparent.
      
    

  C.5.61 Section 13.2.1.1 Rendering page boxes that do not fit a target sheet

  [2009-02-02]

  Remove sections 13.2.1.1 and 13.2.1.2. (The described situations cannot occur in CSS 2.1, because CSS 2.1 does not have a 'size' property.)

  C.5.62 Section 13.2.3 Content outside the page box

  [2008-11-03] Clarified what locations are inconvenient for printing:

  
    When formatting content in the page model, some content may end up outside the current page box. For example, an element whose 'white-space' property has the value 'pre' may generate a box that is wider than the page box. As another example, when boxes are positioned absolutely or relatively, they may end up in “inconvenient” locations. For example, images may be placed on the edge of the page box or 100,000 meters below the page box.
  

  C.5.63 Section 13.3.1 Page break properties: 'page-break-before', 'page-break-after', 'page-break-inside'

  [2008-04-30] The 'page-break-inside' property no longer inherits.

  C.5.64 Section 13.3.1 Page break properties: 'page-break-before', 'page-break-after', 'page-break-inside'

  [2008-12-01] UAs may apply 'page-break-before', 'page-break-after' and 'page-break-inside' to other elements than block-level ones.

  C.5.65 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

  [2009-02-02] “Paragraph” is not a defined term. Change of a paragraph to in a block element (twice).

  C.5.66 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

  [2009-04-15] 'Widows' and 'orphans' only accept positive values.

  C.5.67 Section 13.3.3 Allowed page breaks

  [2008-04-30] The 'page-break-inside' property of all ancestors is checked for page-breaking restrictions, not just that of the breakpoint's parent.

  C.5.68 Section 13.3.3 Allowed page breaks

  [2009-02-02] Remove possible confusion:

  
    Rule D: In addition, breaking at (2) is allowed only if the 'page-break-inside' property of the element and all its ancestors is 'auto'.
  

  C.5.69 Section 13.3.3 Allowed page breaks

  [2009-02-02] Top margins do not disappear at a page break that is forced by a 'page-break-after' or 'page-break-before'. Correct the first bullet to:

  
    When an unforced page break occurs here, the used values of the relevant 'margin-top' and 'margin-bottom' properties are set to '0'. When a forced page break occurs here, the used value of the relevant 'margin-bottom' property is set to '0'; the relevant 'margin-top' used value may either be set to '0' or retained.
  

  And add the following note:

  
    Note: It is expected that CSS3 will specify that the relevant 'margin-top' applies (i.e., is not set to '0') after a forced page break.
  

  C.5.70 Section 13.3.5 "Best" page breaks

  [2009-02-02] Remove the advice to user agents to avoid breaking inside elements with borders, inside tables or inside floating elements; add the advice to avoid breaking inside replaced elements.

  C.5.71 Section 14.2 The background

  [2008-11-03] The 'background' property is special on BODY not only in HTML but also in XHTML.

  C.5.72 Section 14.2 The background

  [2009-04-15] The whole 'background' property is used for the canvas, not just the color and the image:

  
    For documents whose root element is an HTML "HTML" element or an XHTML "html" element that has computed values of 'transparent' for 'background-color' and 'none' for 'background-image', user agents must instead use the computed value of those the background properties from that element's first HTML "BODY" element or XHTML "body" element child […]
  

  C.5.73 Section 14.2.1 Background properties: 'background-color', 'background-image', 'background-repeat', 'background-attachment', 'background-position', and 'background'

  [2008-04-07] The size of background images without an intrinsic size is now defined.

  C.5.74 Section 15.6 Font boldness: the 'font-weight' property

  [2008-11-26] Remove incorrect text:

  
    'bolder' selects the next weight that is assigned to a font that is darker than the inherited one. If there is no such weight, it simply results in the next darker numerical value (and the font remains unchanged), unless the inherited value was '900' in which case the resulting weight is also '900'.
      

      'lighter' is similar, but works in the opposite direction: it selects the next lighter keyword with a different font from the inherited one, unless there is no such font, in which case it selects the next lighter numerical value (and keeps the font unchanged).
      
    

  and:

  
    The computed value of "font-weight" is either:

    
        one of the legal number values, or
      

      
        one of the legal number values combined with one or more of the relative values (bolder or lighter). This type of computed values is necessary to use when the font in question does not have all weight variations that are needed.
      
    

  And instead add this note:

  
    Note: A set of nested elements that mix 'bolder' and 'lighter' will give unpredictable results depending on the UA, OS, and font availability. This behavior will be more precisely defined in CSS3.
  

  C.5.75 Section 16.6 Whitespace: the 'white-space' property

  [2008-08-19] Remove rules about generated text from:

  
    The following examples show what whitespace behavior is expected from the PRE and P elements, the “nowrap” attribute in HTML, and in generated content.
    pre        { white-space: pre }
p          { white-space: normal }
td[nowrap] { white-space: nowrap }
:before,:after { white-space: pre-line }
  

  C.5.76 Section 16.6.1 The 'white-space' processing model

  [2009-02-02] Collapsing of white space does not remove any line breaking opportunities. Add the following clarification:

  
    Then, the entire block is rendered. Inlines are laid out, taking bidi reordering into account, and wrapping as specified by the 'white-space' property. When wrapping, line breaking opportunities are determined based on the text prior to the white space collapsing steps above.
  

  C.5.77 Section 17.2.1 Anonymous table objects

  [2007-11-14] Spelling error: boxess.

  C.5.78 Section 17.2.1 Anonymous table objects

  [2008-10-13] Added new rule after bullet 4:

  
    5. If a child T of a 'table', 'inline-table', 'table-row-group', 'table-header-group', 'table-footer-group', or 'table-row' box is an anonymous inline box that contains only white space, then it is treated as if it has 'display: none'.
  

  C.5.79 Section 17.4 Tables in the visual formatting model

  [2009-02-02] The anonymous block containing the table and its caption establishes a block formatting context:

  
    The anonymous box is a 'block' box if the table is block-level, and an 'inline-block' box if the table is inline-level except that this block is never considered as a block for 'run-in' interaction, and that The anonymous box establishes a block formatting context. The table box (not the anonymous box) is used when doing baseline vertical alignment for an 'inline-table'.
  

  The diagram now shows the caption's margins inside the anonymous box.

  C.5.80 Section 17.5.4 Horizontal alignment in a column

  [2008-04-07] Clarification:

  
    The horizontal alignment of a cell's inline content within a cell box is can be specified with the 'text-align' property by the value of the 'text-align' property on the cell.
  

  C.5.81 Section 18.1 Cursors: the 'cursor' property

  [2008-04-07] The size of cursors without an intrinsic size is now defined.

  C.5.82 Section B.2 Informative references

  [2007-11-14] Spelling error: change ?lik to Çelik (2×).

  C.5.83 Appendix D. Default style sheet for HTML 4

  [2008-08-19] Replace
  br:before       { content: "\A" }
:before, :after { white-space: pre-line }

  with
  br:before       { content: "\A"; white-space: pre-line }

  C.5.84 Appendix D. Default style sheet for HTML 4

  [2008-08-19] Add tr to:
  td, th, tr      { vertical-align: inherit }

  C.5.85 Section E.2 Painting order

  [2007-11-14] Replace but any descendants which actually create a new stacking context by but any positioned descendants and descendants which actually create a new stacking context.

  C.5.86 Appendix G. Grammar of CSS 2.1

  [2007-09-27] Change the last S in the grammar rule for combinator to S+:
  combinator
  : PLUS S*
  | GREATER S*
  | S+

  and remove the rule
  {s}+\/\*[^*]*\*+([^/*][^*]*\*+)*\/  {unput(' '); /*replace by space*/}

  in the tokenizer. The resulting language is the same, but the grammar is easier to read and relies less on specific notations of Flex.

  C.5.87 Section G.1 Grammar

  [2007-09-27] Changes to remove ambiguity with respect to the S token and avoid nullable non-terminals.

  C.5.88 Section G.2 Lexical scanner

  [2007-09-27] Change the tokenizer rule
  @{C}{H}{A}{R}{S}{E}{T}  {return CHARSET_SYM;}

  to
  "@charset "  {return CHARSET_SYM;}

  The @charset must be in lowercase and must have a space after it (as defined in section  4.4 CSS style sheet representation).

  C.5.89 Section G.2 Lexical scanner

  [2008-03-05] Change the tokenizer rules
  "url("{w}{string}{w}")" {return URI;}
"url("{w}{url}{w}")"    {return URI;}

  to
  {U}{R}{L}"("{w}{string}{w}")"   {return URI;}
{U}{R}{L}"("{w}{url}{w}")"   {return URI;}

  C.5.90 Section G.2 Lexical scanner

  [2008-04-07] The definition of the macro “O” is wrong. The letters O and o can be written with hexadecimal escapes as “\4f” and “\6f” respectively (not as “\51” and “\71”). The macro should therefore be
  O          o|\\0{0,4}(4f|6f)(\r\n|[ \t\r\n\f])?|\\o

  C.5.91 Section G.2 Lexical scanner

  “The two occurrences of "\377"…”: There is in fact only one occurrence.

  C.5.92 Appendix I. Index

  Add a TITLE attribute to all links and which is equal to the lemma.

  C.6 Errata since the Candidate Recommendation of April 2009

  These are the errata for CSS level 2 revision 1, CR version of 23 April 2009. These corrections have the status of a draft.

  C.6.1 Section 4.2 Rules for handling parsing errors

  [2009-08-06] Clarified the rules for ignoring invalid at-keywords:

  
    Invalid at-keywords. User agents must ignore an invalid at-keyword together with everything following it, up to the end of the block that contains the invalid at-keyword, or up to and including the next semicolon (;), or up to and including the next block ({...}), or the end of the block (}) that contains the invalid at-keyword, whichever comes first.
  

  C.6.2 Section 13.3.3 Allowed page breaks

  [2009-08-06] Page breaks are also allowed when there is a gap after the last content of a block. Added the following to the first list:

  
    3. Between the content edge of a block box and the outer edges of its child content (margin edges of block-level children or line box edges for inline-level children) if there is a (non-zero) gap between them.
  

  C.6.3 Section 15.3 Font family: the 'font-family' property

  [2009-08-31] The list of keywords in “(e.g., 'initial', 'inherit', 'default', 'serif', 'sans-serif', 'monospace', 'fantasy', and 'cursive')” isn't an example, but is in fact the complete and normative list.

  C.6.4 Section 15.3.1.1 serif

  [2009-08-31] Spelling errors in font names. The correct names are “Excelsior Cyrillic Upright” and “ER Bukinist.”

  C.6.5 Section 15.7 Font size: the 'font-size' property

  [2009-08-31] The two notes “Note: implementation experience has demonstrated…” and “Note 2. In CSS1, the suggested scaling factor… say essentially the same thing. They are replaced by a single note:

  
    Note 2. In CSS1, the suggested scaling factor between adjacent indexes was 1.5, which user experience proved to be too large. In CSS2, the suggested scaling factor for a computer screen between adjacent indexes was 1.2, which still created issues for the small sizes. Implementation experience has demonstrated that a fixed ratio between adjacent absolute-size keywords is problematic, and this specification does not recommend such a fixed ratio.
  

  C.6.6 Section 17.5.2.1 Fixed table layout

  [2009-05-20] UAs may render extra columns if there are unexpected columns in later rows of a 'fixed' table layout. In that case, the width of the columns and of the table is undefined.

  C.6.7 Section 17.5.3 Table height layout

  [2009-08-06] Replaced “Percentage heights on table cells, table rows, and table row groups compute to 'auto' by

  
    CSS 2.1 does not define how the height of table cells and table rows is calculated when their height is specified using percentage values. CSS 2.1 does not define the meaning of 'height' on row groups.
  

  C.6.8 Appendix G. Grammar of CSS 2.1

  [2009-08-06] Removed ambiguities from the grammar. (The ambiguities only affected spaces and were harmless.)

  C.7 Errata since the Candidate Recommendation of September 2009

  These are the errata for CSS level 2 revision 1, CR version of 8 September 2009. These corrections have the status of a draft.

  C.7.1 Section 1.4.2.1 Value

  [2010-08-06] (Also in various other sections throughout the specification.) Distinguished all cases where the word value referred to a whole property value from where it referred to only part of such a value (such as a component in a comma-separated list). The former is now property value, the latter component value.

  C.7.2 Section 3.1 Definitions

  [2010-04-19] Add a clarification to the definition of replaced element:

  
    The content of replaced elements is not considered in the CSS rendering model.
  

  (Previously, the definition only said that the content was “outside the scope of CSS.”)

  C.7.3 Section 4.1.1 Tokenization

  [2010-04-19] The definition of “identifier” in 4.1.3 (2nd bullet) and in the grammar were contradictory w.r.t. whether no-break space (U+00A0) was allowed in identifiers or not. Change the text in 4.1.3 to allow no-break space: “characters U+00A1 U+00A0 and higher.”

  Also, change the macro “nonascii” in the token definition from “[^\0-\177]” to [^\0-\237]”. (When CSS was first written, Unicode didn't have code points U+0080 to U+009F, i.e., \200-\237 in octal.)

  C.7.4 Section 4.1.1 Tokenization

  [2010-09-29] The tokenizer has been modified so that it can be implemented as a state machine without back-up (e.g., with Lex). This changes the meaning of an input of the form “url(…(…)…)”, i.e., input that starts like a URI token but then contains a parenthesis (which is not allowed in a URI token). Previously, such input was re-parsed to yield a FUNCTION token followed by other things; now it yields a BAD_URI token. Given that CSS has never used a FUNCTION token of the form “url(” this should not affect any existing CSS style sheets.

  A non-normative section has been added to appendix G with an explanation of how to make a tokenizer without back-up.

  C.7.5 Section 4.1.1 Tokenization

  [2010-09-29] The definition of the URI token was ambiguous: it allowed a backslash to be either parsed on its own or as part of an escape. A backslash in a URI token must always be interpreted as part of an escape.

  C.7.6 Section 4.1.1 Tokenization

  [2010-09-29] Error handling for illegal tokens (braces, at-keywords, and SGML comment tokens) inside parenthesized expressions was not well defined. Change the production for “any” as follows

  
    
any         : [ IDENT | NUMBER | PERCENTAGE | DIMENSION | STRING
              | DELIM | URI | HASH | UNICODE-RANGE | INCLUDES
              | DASHMATCH | ':' | FUNCTION S* [any|unsused]* ')'
              | '(' S* [any|unused]* ')' | '[' S* [any|unused]* ']'
              ] S*;
unused      : block | ATKEYWORD S* | ';' S* | CDO S* | CDC S*;

  

  and add the following explanation:

  
    The "unused" production is not used in CSS and will not be used by any future extension. It is included here only to help with error handling. (See 4.2 "Rules for handling parsing errors.")
  

  C.7.7 Section 4.1.2.2 Informative Historical Notes

  [2010-04-19] Add “-tc-” to the list of existing vendor prefixes.

  C.7.8 Section 4.1.3 Characters and case

  [2010-08-06] The handling of a backslash before a newline or at the end of a file is no longer undefined: it is parsed as a DELIM.

  C.7.9 Section 4.1.3 Characters and case

  [2010-08-06] Make text and formal grammar the same:

  
    In CSS, identifiers […]; they cannot start with a digit, two hyphens, or a hyphen followed by a digit.
  

  C.7.10 Section 4.1.8 Declarations and properties

  [2010-05-12] Remove “2.1” from

  
    Every CSS 2.1 property has its own syntactic and semantic restrictions
  

  C.7.11 Section 4.2 Rules for handling parsing errors

  [2010-07-07] Clarify that the fifth bullet only applies to at-rules. (At-keywords in other constructs are already handled in the preceding bullets.)

  
    Invalid at-keywords At-rules with unknown at-keywords. User agents must ignore…
    

  C.7.12 Section 4.3.2 Lengths

  [2010-04-19] Make explicit that 'ex', when used in the 'font-size' property, refers to the parent element's 'ex' (just as 'em' refers to the parent's 'em' in that case.)

  C.7.13 Section 4.3.2 Lengths

  [2010-10-28] A UA must now either display absolute lengths (cm, in, pt, etc.) at their real size or make px align with device pixel boundaries near the 0.0213 degrees viewing angle, but not both. In either case, 3px must equal 4pt.

  (Until now, authors could use absolute lengths for physical sizes and px for aligning to device pixels, but couldn't know the number of pt in a px, except in combination with Media Queries. Authors can no longer choose between absolute or device-related units, but can use px and pt interchangeably. This should only affect relatively low-resolution devices: above 300 dots per inch, the maximum error is about 16%.)

  C.7.14 Section 4.3.4 URLs and URIs

  [2010-05-12] Commas do not have to be escaped in <uri> tokens:

  
    Some characters appearing in an unquoted URI, such as parentheses, commas, white space characters, single quotes (') and double quotes ("), must be escaped
  

  C.7.15 Section 4.3.4 URLs and URIs

  [2010-04-21] Describe in English what was only expressed through the grammar:

  
    Note. Since URIs may contain characters that would otherwise be used as delimiters in CSS, the entire URI value must be treated as a single unit by the tokenizer and normal tokenization behavior does not apply within a URI value. Therefore comments are not allowed within a URI value.
  

  C.7.16 Section 5.8.2 Default attribute values in DTDs

  [2010-09-29] Clarify what is meant by “is not required”:

  
    More precisely, a UA may, but is not required to, read an "external subset" of the DTD but is required to look for default attribute values in the document's "internal subset." (See [XML10] for definitions of these subsets.) Depending on the UA, a default attribute value defined in the external subset of the DTD might or might not appear in the document tree.

    A UA that recognizes an XML namespace [XMLNAMESPACES] may, but is not required to, use its knowledge of that namespace to treat default attribute values as if they were present in the document. (E.g., an XHTML UA is not required to use its built-in knowledge of the XHTML DTD.)
  

  and:

  
    the first rule will might not match elements whose "notation" attribute is set by default, i.e., not set explicitly. To catch all cases, the attribute selector for the default value must be dropped:
  

  C.7.17 Section 5.11.4 The language pseudo-class: :lang

  [2010-08-06] The argument of ':lang()' is only case-insensitive for characters in ASCII.

  C.7.18 Section 5.12 Pseudo-elements

  [2010-08-06] Clarify that pseudo-elements behave like elements for the aspects not explicitly mentioned:

  
    Pseudo-elements behave just like real elements in CSS with the exceptions described below and elsewhere.
  

  C.7.19 Section 5.12.1 The :first-line pseudo-element

  [2010-08-24] More consistent use of “block” and “block-level.” Change:

  
    The :first-line pseudo-element can only be attached to a block-level element, inline-block, table-caption or a table-cell block container element.
  

  C.7.20 Section 5.12.2 The :first-letter pseudo-element

  [2010-08-24] More consistent use of “block” and “block-level.” Change:

  
    The :first-letter pseudo-element applies to block, list-item, table-cell, table-caption and inline-block elements block container elements.
  

  C.7.21 Section 6.2 Inheritance

  [2010-08-06] Add a note that, because it follows the document tree, inheritance is not intercepted by anonymous boxes

  C.7.22 Section 6.4.4 Precedence of non-CSS presentational hints

  [2010-10-05] Give other languages than HTML (such as SVG) the possibility to define certain attributes as “presentational attributes”:

  
    For other languages, all document language-based styling should be handled in the user agent style sheet must be translated to the corresponding CSS and either enter the cascade at the user agent level or, as with HTML presentational hints, be treated as author level rules with a specificity of zero placed at the start of the author style sheet.
  

  C.7.23 Section 7.3 Recognized media types

  [2010-09-08] Clarify what is ignored. Change:

  
    @media and @import rules with unknown media types (that are nonetheless valid identifiers) are treated as if the unknown media types are not present. If an @media/@import rule contains a malformed media type (not an identifier) then the statement is invalid.

    Note: Media Queries supercedes this error handling.
  

  C.7.24 Section 8.3.1 Collapsing margins

  [2010-05-12] Simplify/clarify text:

  
    An element that has had clearance applied to it never collapses
  

  and:

  
    When an element's own margins collapse, and that element has had clearance applied to it
  

  C.7.25 Section 8.3.1 Collapsing margins

  [2010-08-24] More consistent use of “block box” vs “block-level element.” Include table captions in the set of block-level elements. See also changes to 9.2.1 and to 9.2.1.1.

  
    Two or more adjoining vertical margins of block-level boxes in the normal flow collapse.
  

  and

  
    The top margin of an in-flow block-level element block box is adjoining to its first in-flow block-level child's top margin
  

  and

  
    The bottom margin of an in-flow block-level element block box with a 'height' of 'auto'
  

  C.7.26 Section 9.2.1 Block-level elements and block boxes

  [2010-08-24] Define the term “block-level element” more precisely. Also define auxiliary terms “block container box” and “block box”:

  More consistent use of block box vs block-level element in section 9.2.1.1. See also changes to section 8.3.1 and 9.4.

  C.7.27 Section 9.2.1.1 Anonymous block boxes

  [2010-05-12] The example has invalid HTML mark-up. Change it to use P and SPAN elements instead of BODY and P.

  [2010-08-06] Also clarify that “block box” only refers to boxes in the same flow.

  C.7.28 Section 9.2.1.1 Anonymous block boxes

  [2010-09-29] Percentage values that refer to dimensions of parent boxes ignore any intervening anonymous boxes. Add this paragraph:

  
    Anonymous block boxes are ignored when resolving percentage values that would refer to it: the closest non-anonymous ancestor box is used instead. For example, if the child of the anonymous block box inside the DIV above needs to know the height of its containing block to resolve a percentage height, then it will use the height of the containing block formed by the DIV, not of the anonymous block box.
  

  C.7.29 Section 9.2.1.1 Anonymous block boxes

  [2010-09-29] Clarify the wording:

  
    When an inline box contains an in-flow block box […] When such an inline box is affected by relative positioning, the relative positioning also affects the block-level box contained in the block box.
  

  C.7.30 Section 9.2.1.1 Anonymous block boxes

  [2010-10-13] Clarify that an inline box that is broken around a block-level box is always broken into two pieces, even if one or both are empty:

  
    When an inline box contains an in-flow block-level box, the inline box (and its inline ancestors within the same line box) are broken around the block-level box, dividing the inline box into two pieces, even if either side is empty..
  

  C.7.31 Section 9.2.2 Inline-level elements and inline boxes

  [2010-08-24] Better define the term “inline-level element/box” and define the auxiliary terms “inline box” and “atomic inline-level box.”

  C.7.32 Section 9.2.3 Run-in boxes

  [2010-04-19] Make the definition of 'run-in' more precise:

  
    A run-in box behaves as follows:

    
        If the run-in box contains a block box, the run-in box becomes a block box.
      

      
        If a sibling block box (that does not float and is not absolutely positioned) follows the run-in box, the run-in box becomes the first inline box of the block box. A run-in cannot run in to a block that already starts with a run-in or that itself is a run-in.
      

      
        Otherwise, the run-in box becomes a block box.
      
    A run-in element (or pseudo-element) A behaves as follows:

    
        If A has any children that inhibit run-in behavior (see below), then A is rendered as if it had 'display: block'.
      

      
        Let B be the first of A's following siblings that is neither floating nor absolutely positioned nor has 'display: none'. If B exists and has a specified value for 'display' of 'block' or 'list-item' and is not replaced, then A is rendered as an 'inline' element at the start of B's principal box. Note: A is rendered before B's ':before' pseudo-element, if any. See 12.1.
      

      
        Otherwise, A is rendered as if it had 'display: block'.
      
    In the above, "siblings" and "children" include both normal elements and :before/:after pseudo-elements.

    An element or pseudo-element C inhibits run-in behavior if one of the following is true. (Note that the definition is recursive.)

    
        C is not floating and not absolutely positioned and the computed value of its 'display' is one of 'block', 'list-item', 'table' or 'run-in'.
      

      
        C has a computed value for 'display' of 'inline' and it has one or more children that inhibit run-in behavior. (Where "children" includes both normal elements and :before/:after pseudo-elements.)
      
    

  It remains undefined how 'run-in' and ':first-line' interact:

  
    It is undefined in CSS 2.1 if a run-in inherits from a ':first-line' pseudo-element.
  

  C.7.33 Section 9.2.4 The 'display' property

  [2010-08-06] Use the same terminology as in chapter 12:

  
    list-item

      
        This value causes an element (e.g., LI in HTML) to generate a principal block box and a list-item inline marker box.
      
    

  C.7.34 Section 9.2.4 The 'display' property

  [2010-08-24] More consistent use of “inline-level.”

  
    inline-block

      
        This value causes an element to generate a block box, which itself is flowed as a single inline box, similar to a replaced element an inline-level block container. The inside of an inline-block is formatted as a block box, and the element itself is formatted as an inline replaced element an atomic inline-level box.
      
    

  C.7.35 Section 9.3 Positioning schemes

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    Normal flow. In CSS 2.1, normal flow includes block formatting of block-level boxes, inline formatting of inline-level boxes, relative positioning of block-level or and inline-level boxes, and positioning formatting of run-in boxes.
      
    

  C.7.36 Section 9.4 Normal flow

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.
  

  In 9.4.1:

  
    Floats, absolutely positioned elements, inline-blocks, table-cells, table-captions, and elements with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible'.

    In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.
  

  In 9.4.2:

  
    […] When several inline-level boxes cannot fit horizontally within a single line box, they are distributed among two or more vertically-stacked line boxes.

    When the total width of the inline-level boxes on a line […]is less than the width of the line box containing them, their horizontal distribution within the line box is determined by the 'text-align' property. If that property has the value 'justify', the user agent may stretch spaces and words in inline boxes (except for but not inline-table and inline-block boxes) as well.
  

  C.7.37 Section 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

  [2010-07-19] If 'top', 'right', 'bottom' or 'left' is specified as 'auto', the used value rather than the computed value is set to the negative of the opposite side. For all four, change:

  
    Computed value:

          
            for 'position:relative', see section Relative Positioning. For 'position:static', 'auto'. Otherwise: if specified as a length, the corresponding absolute length; if specified as a percentage, the specified value; otherwise, 'auto'.
          
        

  And in section 9.4.3:

  
    […] Since boxes are not split or stretched as a result of 'left' or 'right', the computed used values are always: left = -right.

    If both 'left' and 'right' are 'auto' (their initial values), the computed used values are '0' (i.e., the boxes stay in their original position).

    If 'left' is 'auto', its computed used value is minus the value of 'right' (i.e., the boxes move to the left by the value of 'right').

    If 'right' is specified as 'auto', its computed used value is minus the value of 'left'.

    […] Since boxes are not split or stretched as a result of 'top' or 'bottom', the computed used values are always: top = -bottom. If both are 'auto', their computed used values are both '0'. If one of them is 'auto', it becomes the negative of the other. If neither is 'auto', 'bottom' is ignored (i.e., the computed used value of 'bottom' will be minus the value of 'top').
  

  C.7.38 Section 9.5 Floats

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    […] In other words, if inline-level boxes are placed on the line before a left float is encountered that fits in the remaining line box space, the left float is placed on that line, aligned with the top of the line box, and then the inline-level boxes already on the line are moved accordingly to the right of the float (the right being the other side of the left float) and vice versa for rtl and right floats.
  

  In 9.5.2:

  
    Values have the following meanings when applied to non-floating block-level boxes:
  

  C.7.39 Section 9.5 Floats

  [2010-10-25] Define exactly what it means for a line box to be next to a float:

  
    […] However, line boxes created next to the float are shortened to make room for the margin box of the float.

    A line box is next to a float when there exists a vertical position that satisfies all of these four conditions: (a) at or below the top of the line box, (b) at or above the bottom of the line box, (c) below the top margin edge of the float, and (d) above the bottom margin edge of the float.

    Note: this means that floats with zero height or negative height do not move line boxes.
  

  C.7.40 Section 9.5.2 Controlling flow next to floats: the 'clear' property

  [2010-05-12] Clarify that 'clear' only introduces clearance above an element if necessary; and that clearance may have zero height.

  C.7.41 Section 9.5.2 Controlling flow next to floats: the 'clear' property

  [2010-10-13] Added an example of calculating clearance from two collapsing margins M1 and M2 and the height H of a float.

  C.7.42 Section 9.5.2 Controlling flow next to floats: the 'clear' property

  [2010-10-13] Clarify the language:

  
    Computing the clearance of an element on which 'clear' is set is done by first determining the hypothetical position of the element's top border edge within its parent block. This position is determined after the top margin of the element has been collapsed with previous adjacent margins (including the top margin of the parent block). This position where the actual top border edge would have been if the element had a non-zero top border and its 'clear' property had been 'none'.

    If this hypothetical position of the element's top border edge is not past the relevant floats, then clearance must be is introduced, and margins collapse according to the rules in 8.3.1.

    Then the amount of clearance is set to the greater of:

    The amount necessary to place the border edge of the block even with the bottom outer edge of the lowest float that is to be cleared.

      
        The amount necessary to make the sum of the following equal to the distance to which these margins collapsed when the hypothetical position was calculated:

        
            the margins collapsing above the clearance
          

          
            the clearance itself
          

          
            if the block's own margins collapse together: the block's top margin
          

          
            if the block's own margins do not collapse together: the margins collapsing below the clearance
          
        The amount necessary to place the top border edge of the block at its hypothetical position.
      
    

  C.7.43 Section 9.5.2 Controlling flow next to floats: the 'clear' property

  [2010-10-13] Correction: The hypothetical position is determined by assuming the box has a non-zero bottom border (see section 8.3.1):

  
    This position is where the actual top border edge would have been if the element had a non-zero top bottom border and its 'clear' property had been 'none'.
  

  C.7.44 Section 14.2.1 Background properties

  [2010-04-19] 'Fixed' backgrounds in paged media are positioned relative to the page box (and thus repeat on every page, just like 'fixed' elements). The position of fixed backgrounds in paged media was previously undefined.

  C.7.45 Section 9.9.1 Specifying the stack level: the 'z-index' property

  [2010-07-07] Some ambiguities in the description of stacking contexts are fixed and the description is clearly marked as non-normative. (Appendix E holds the normative description.)

  C.7.46 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    User agents that support bidirectional text must apply the Unicode bidirectional algorithm to every sequence of inline-level boxes uninterrupted by a forced line break or block boundary. This sequence forms the "paragraph" unit in the bidirectional algorithm. The paragraph embedding level is set according to the value of the 'direction' property of the containing block rather than by the heuristic given in steps P2 and P3 of the Unicode algorithm.

    […]

    For the 'direction' property to affect reordering in inline-level elements, the 'unicode-bidi' property's value must be 'embed' or 'override'.

    […]

    normal

      
        The element does not open an additional level of embedding with respect to the bidirectional algorithm. For inline-level elements, implicit reordering works across element boundaries.
      

      embed

      
        If the element is inline-level, this value opens an additional level of embedding with respect to the bidirectional algorithm. The direction of this embedding level is given by the 'direction' property. Inside the element, reordering is done implicitly. This corresponds to adding a LRE (U+202A; for 'direction: ltr') or RLE (U+202B; for 'direction: rtl') at the start of the element and a PDF (U+202C) at the end of the element.
      

      bidi-override

      
        For inline-level elements this creates an override. For block-level, table-cell, table-caption, or inline-block block container elements this creates an override for inline-level descendants not within another block container element. This means that inside the element, reordering is strictly in sequence according to the 'direction' property; the implicit part of the bidirectional algorithm is ignored. This corresponds to adding a LRO (U+202D; for 'direction: ltr') or RLO (U+202E; for 'direction: rtl') at the start of the element or at the start of each anonymous child block box, if any, and a PDF (U+202C) at the end of the element.
      
    The final order of characters in each block-level element block container is […]
  

  C.7.47 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

  [2010-10-05] Add a reference to bidi class B in Unicode TR 9 to clarify what a “forced break” is in the context of the Unicode bidi algorithm:

  
    […] inline-level boxes uninterrupted by a forced line (bidi class B) break or block boundary
  

  C.7.48 Section 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

  [2010-10-25] clarify “non-textual entities”:

  
    In this process, non-textual entities such as images replaced elements with 'display: inline' (and replaced elements with 'display: run-in', when they generate inline-level boxes) are treated as neutral characters, unless their 'unicode-bidi' property has a value other than 'normal', in which case they are treated as strong characters in the 'direction' specified for the element. All other atomic inline-level boxes are treated as neutral characters always.
  

  C.7.49 Section 10.1 Definition of "containing block"

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    […]

      For other elements, if the element's position is 'relative' or 'static', the containing block is formed by the content edge of the nearest block-level, table cell or inline-block block container ancestor box.
      

      […]

      […]

        In the case that the ancestor is inline-level an inline box, the containing block depends on the 'direction' property of the ancestor:
          
        
    

  C.7.50 Section 10.2 Content width: the 'width' property

  [2010-05-12] The computed value of 'width' doesn't depend on whether the property applies or not:

  
    Computed value: the percentage or 'auto' as specified or the absolute length; 'auto' if the property does not apply
  

  C.7.51 Section 10.2 Content width: the 'width' property

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    This property specifies the content width of boxes generated by block-level and replaced elements.

    This property does not apply to non-replaced inline-level elements.
  

  C.7.52 Section 10.2 Content width: the 'width' property

  [2010-10-05] Remove unclear and redundant sentence:

  
    The width of a replaced element's box is intrinsic and may be scaled by the user agent if the value of this property is different than 'auto'.
  

  C.7.53 Section 10.5 Content height: the 'height' property

  [2010-05-12] The computed value of 'height' doesn't depend on whether the property applies or not:

  
    Computed value: the percentage or 'auto' (see prose under <percentage>) or the absolute length; 'auto' if the property does not apply
  

  C.7.54 Section 10.5 Content height: the 'height' property

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    This property specifies the content height of boxes generated by block-level, inline-block and replaced elements.

    This property does not apply to non-replaced inline-level elements. See the section on computing heights and margins for non-replaced inline elements for the rules used instead.
  

  C.7.55 Section 10.6.7 'Auto' heights for block formatting context roots

  [2010-08-06] Clarify “bottom” and “preceding”:

  
    In certain cases (see the preceding sections e.g., sections 10.6.4 and 10.6.6), the height of an element that establishes a block formatting context is computed as follows:

    […]

    In addition, if the element has any floating descendants whose bottom margin edge is below the bottom the element's bottom content edge, then the height is increased to include those edges. Only floats that are children of the element itself or of descendants in the normal flow are taken into account, e.g., floats inside absolutely positioned descendants or other floats are not.
  

  C.7.56 Section 10.7 Minimum and maximum heights: 'min-height' and 'max-height'

  [2010-10-26] The effect of 'min-height' and 'max-height' on table cells is still undefined in CSS:

  
    In CSS 2.1, the effect of 'min-height' and 'max-height' on tables, inline tables, table cells, table rows, and row groups is undefined.
  

  C.7.57 Section 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

  [2010-06-02] Clarifications to the calculation of the line boxes and the minimum line height ("strut"). Item 2 in the bulleted list is expanded and items 3 and 4 are merged, as follows:

  
    The height of each inline box in the line box is calculated (see "Calculating heights and margins" and the 'line-height' property).

      The inline boxes are aligned vertically according to their 'vertical-align' property. In case they are aligned 'top' or 'bottom', they must be aligned so as to minimize the line box height. If such boxes are tall enough, there are multiple solutions and CSS 2.1 does not define the position of the line box's baseline (i.e., the position of the strut, see below).
      

      The line box height is the distance between the uppermost box top and the lowermost box bottom. (This includes the strut, as explained under 'line-height' below.)
      

      
        If the resulting height is smaller than the minimal height of line boxes for this block, as specified by the 'line-height' property, the height is increased to be that minimal height.
      
    

  Furthermore, in 10.8.1, after the definition of “strut,” clarify that the font determines the initial baseline:

  
    The height and depth of the font above and below the baseline are assumed to be metrics that are contained in the font. (For more details, see CSS level 3.)
  

  C.7.58 Section 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    As described in the section on inline formatting contexts, user agents flow inline-level boxes into a vertical stack of line boxes. The height of a line box is determined as follows:

    The height of each inline-level box in the line box is calculated (see "Calculating heights and margins" and the 'line-height' property).
      

      The inline-level boxes are aligned vertically according to their 'vertical-align' property.
      
    

  In 10.8.1:

  
    On a block-level, table-cell, table-caption or inline-block block container element whose content is composed of inline-level elements, 'line-height' specifies the minimal height of line boxes within the element. […]

    On an inline-level element, 'line-height' specifies the height that is used in the calculation of the line box height […]
  

  After the definition of 'vertical-align':

  
    The following values only have meaning with respect to a parent inline-level element, or to the strut of a parent block-level, table-cell, table-caption or inline-block block container element.
  

  C.7.59 Section 10.8.1 Leading and half-leading

  [2010-07-19] Clarify text:

  
    On a block-level, table-cell, table-caption or inline-block element whose content is composed of inline-level elements, 'line-height' specifies the minimal height of line boxes within the element. The minimum height consists of a minimum height above the block's baseline and a minimum depth below it, exactly as if each line box starts with a zero-width inline box with the block's element's font and line height properties. (what TEX calls a "strut"). We call that imaginary box a "strut." (The name is inspired by TeX.).
  

  C.7.60 Section 10.8.1 Leading and half-leading

  [2010-08-20] Remove text that talks about the “content area” of an inline box and about “center vertically” and instead make it more explicit how leading is added to a glyph: leading is added above and below a hypothetical box around each glyph that represents the (normal or ideal) height of a line of text in that font, as given in the font metrics.

  Add a note referring to 10.6.1 (which defines that the content area is undefined) and explaining that the exact position of backgrounds and borders relative to the line box is undefined.

  Also add a note about how to find the relevant metrics in OpenType and TrueType fonts.

  C.7.61 Section 10.8.1 Leading and half-leading

  [2010-08-20] Clarify some imprecise terms:

  
    When an element contains text that is rendered in more than one font, user agents may determine the 'normal' 'line-height' value according to the largest font size.

    Generally, when there is only one value of 'line-height' for all inline boxes in a paragraph block container box (and no tall images replaced elements, inline-block elements, etc.), the above will ensure that baselines of successive lines are exactly 'line-height' apart. This is important when columns of text in different fonts have to be aligned, for example in a table.
  

  C.7.62 Section 11.1 Overflow and clipping

  [2010-10-25] Clarify which ancestors are meant:

  
    A descendant box is positioned absolutely, partly outside the box. Such boxes are not always clipped by the overflow property on their ancestors; specifically, they are not clipped by the overflow of any ancestor between themselves and their containing block
      
    

  C.7.63 Section 11.1.1 Overflow: the 'overflow' property

  [2010-08-06] The phrase “containing block” in the example doesn't refer to the technical term “containing block” but simply to the containing box. Change “containing block” to “containing div.”

  C.7.64 Section 11.1.1 Overflow: the 'overflow' property

  [2010-08-24] More consistent use of “inline-level” and “block-level.”

  
    This property specifies whether content of a block-level block container element is clipped when it overflows the element's box.
  

  C.7.65 Section 11.1.1 Overflow: the 'overflow' property

  [2010-10-25] Add missing inline-table:

  
    Applies to:

          
            non-replaced block-level elements, table cells, inline-table, and inline-block elements
          
        

  C.7.66 Section 11.1.2 Clipping: the 'clip' property

  [2010-10-25] The computed value of 'auto' is 'auto' also when 'auto' is specified inside 'rect()':

  
    Computed value:

          
            For rectangle values, a rectangle consisting of four computed lengths; otherwise, as specified 'auto' if specified as 'auto', otherwise a rectangle with four values, each of which is 'auto' if specified as 'auto' and the computed length otherwise
          
        

  And:

  
    <top>, <right>, <bottom>, and <left> may either have a <length> value or 'auto'. Negative lengths are permitted. The value 'auto' means that a given edge of the clipping region will be the same as the edge of the element's generated border box (i.e., 'auto' means the same as '0' for <top> and <left> (in left-to-right text, <right> in right-to-left text), the same as the computed used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the computed used value of the width plus the sum of the horizontal padding and border widths for <right> (in left-to-right text, <left> in right-to-left text), such that four 'auto' values result in the clipping region being the same as the element's border box).
  

  C.7.67 Section 12.5 Lists

  [2010-10-05] Improve wording: the marker box of a list item isn't “optional,” it is sometimes absent. Change:

  
    CSS 2.1 offers basic visual formatting of lists. An element with 'display: list-item' generates a principal box for the element's content and an optional marker box and, depending on the values of 'list-style-type' and 'list-style-image', possibly also a marker box as a visual indication that the element is a list item.
  

  C.7.68 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2010-07-14] Because of persistent incompatibilites between implementations, the constraints on the position of 'outside' markers are relaxed in the presence of floats. This will be fixed in a future specification.

  C.7.69 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2010-08-06] The 'armenian' list-style-type refers to uppercase Armenian numbering.

  C.7.70 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2010-08-06] Define the order of 'inside' marker boxes and ':before' pseudo-elements:

  
    inside

      
        The marker box is placed as the first inline box in the principal block box, after which the element's content flows before the element's content and before any :before pseudo-elements.
      
    

  C.7.71 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2010-08-06] CSS 2.1 does not specify the precise location of an 'outside' marker box, including its z-order. Append:

  
    CSS 2.1 does not specify the precise location of the marker box or its position in the painting order
  

  C.7.72 Section 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  [2010-11-25] Because of historical ambiguity, CSS level 2 does not yet require the marker to be visible when 'list-style-position' is 'outside' and 'overflow' is other than 'visible'. Insert in the definition of 'outside':

  
    In CSS 2.1, a UA may hide the marker if the element's 'overflow' is other than 'visible'. (This is expected to change in the future.)
  

  C.7.73 Section 13.2 Page boxes: the @page rule

  [2010-07-07] The @page rule can contain not just declarations but also other @-rules. (There aren't any such nested @-rules defined in level 2, but there are in level 3.)

  
    An @page rule consists of the keyword "@page", followed by an optional page selector, followed by a block of declarations containing declarations and at-rules.

    Note: CSS level 2 has no at-rules that may appear inside @page, but such at-rules are expected to be defined in level 3.
  

  And add just above section 13.2.1:

  
    The rules for handling malformed declarations, malformed statements, and invalid at-rules inside @page are as defined in section 4.2, with the following addition: when the UA expects the start of a declaration or at-rule (i.e., an IDENT token or an ATKEYWORD token) but finds an unexpected token instead, that token is considered to be the first token of a malformed declaration. I.e., the rule for malformed declarations, rather than malformed statements is used to determine which tokens to ignore in that case.
  

  C.7.74 Section 13.2.2 Page selectors: selecting left, right, and first pages

  [2010-10-25] Whether the first page of a document is :left or :right depends on the major writing direction. Give an example of how:

  
    All pages are automatically classified by user agents into either the :left or :right pseudo-class. Whether the first page of a document is :left or :right depends on the major writing direction of the root element. For example, the first page of a document with a left-to-right major writing direction would be a :right page, and the first page of a document with a right-to-left major writing direction would be a :left page. To explicitly force a document to begin printing on a left or right page, authors can insert a page break before the first generated box.
  

  And in 13.3.1:

  
    Whether the first page of a document is :left or :right depends on the major writing direction of the document.
  

  C.7.75 Section 13.3.2 Breaks inside elements: 'orphans', 'widows'

  [2010-08-24] More consistent use of “inline-level” and “block-level.” Change for both 'orphans' and 'widows':

  
    Applies to:

          
            block-level block container elements
          
        

  And change:

  
    The 'orphans' property specifies the minimum number of lines in a block element container that must be left at the bottom of a page. The 'widows' property specifies the minimum number of lines in a block element container that must be left at the top of a page. Examples of how they are used to control page breaks are given below.
  

  C.7.76 Section 13.3.3 Allowed page breaks

  [2010-08-24] More consistent use of “inline-level” and “block-level.” Change:

  
    In the vertical margin between block-level boxes. […]
      

      Between line boxes inside a block container box.
      

      Between the content edge of a block container box and the outer edges of its child content […]
      
    

  C.7.77 Section 15.3 Font family: the 'font-family' property

  [2010-07-19] The specification was ambiguous as to whether parentheses, brackets and braces in font names must always be escaped, or only when needed to conform to the syntax for declarations. Because of that, and because of the many bugs in implementations, all font names must now either be quoted, or be escaped so as to consist of only identifiers.

  C.7.78 Section 15.3.1 Generic font families

  [2010-08-26] Make it clearer that CSS does not try to define what fonts are serif or sans-serif:

  
    15.3.1.1 serif

    Glyphs of serif fonts, as the term is used in CSS, tend to have finishing strokes, flared or tapering ends, or have actual serifed endings (including slab serifs). […]

    15.3.1.2 sans-serif

    Glyphs in sans-serif fonts, as the term is used in CSS, tend to have stroke endings that are plain – without any with little or no flaring, cross stroke, or other ornamentation. […]
  

  C.7.79 Section 15.6 Font boldness: the 'font-weight' property

  [2010-04-19] The meaning of the keywords 'bolder' and 'lighter' no longer depends on both the inherited weight and the actually used font, but only on the inherited weight.

  C.7.80 Section 15.6 Font boldness: the 'font-weight' property

  [2010-10-13] Clarify the algorithm for mapping CSS font weight values to the actual weights of a font and make it normative:

  
    The association of other weights within a family to the numerical weight values is intended only to preserve the ordering of darkness within that family. However, the following heuristics tell how the assignment is done in typical cases:

    If the font family already uses a numerical scale with nine values (like e.g., OpenType does), the font weights should be mapped directly.

      If there is both a face labeled Medium and one labeled Book, Regular, Roman or Normal, then the Medium is normally assigned to the '500'.

      The font labeled "Bold" will often correspond to the weight value '700'.
    Once the font family's weights are mapped onto the CSS scale, missing weights are selected as follows:

    
        If there are fewer then 9 weights in the family, the default algorithm for filling the "holes" is as follows. If '500' is unassigned, it will be assigned the same font as '400'. If any of the values '600', '700', '800' or '900' remains unassigned, they are assigned to the same face as the next darker assigned keyword, if any, or the next lighter one otherwise. If any of '300', '200' or '100' remains unassigned, it is assigned to the next lighter assigned keyword, if any, or the next darker otherwise.
      

      
        If the desired weight is less than 400, weights below the desired weight are checked in descending order followed by weights above the desired weight in ascending order until a match is found.
      

      
        If the desired weight is greater than 500, weights above desired weight are checked in ascending order followed by weights below the desired weight in descending order until a match is found.
      

      
        If the desired weight is 400, 500 is checked first and then the rule for desired weights less than 400 is used.
      

      
        If the desired weight is 500, 400 is checked first and then the rule for desired weights less than 400 is used.
      
    

  C.7.81 Section 15.7 Font size: the 'font-size' property

  [2010-08-06] Changed “Percentages: refer to parent element's font size” to “Percentages: refer to inherited font size” so that it uses the same terminology as Section 4.3.3.

  C.7.82 Section 16.1 Indentation: the 'text-indent' property

  [2010-08-24] More consistent use of “inline-level” and “block-level.” Change:

  
    Applies to:

          
            block-level elements, table cells and inline blocks block containers
          
        […]

    This property specifies the indentation of the first line of text in a block container.
  

  C.7.83 Section 16.1 Indentation: the 'text-indent' property

  [2010-10-25] Clarify that the “first line” of the “first box,” etc., is the same as the “first formatted line” of chapter 5:

  
    'Text-indent' only affects a line if it is the first formatted line of an element. For example, the first line of an anonymous block box is only affected if it is the first child of its parent element.
  

  C.7.84 Section 16.2 Alignment: the 'text-align' property

  [2010-07-19] The value 'pre-line' of 'white-space' does not inhibit justification. (Only lines that end with an explicit newline aren't justified, as is the case for any value of 'white-space'.) But, 'pre-wrap' does inhibit justification. Replace

  
    If the computed value of text-align is 'justify' while the computed value of white-space is 'pre' or 'pre-line', the actual value of text-align is set to the initial value.
  

  with

  
    If an element has a computed value for 'white-space' of 'pre' or 'pre-wrap', then neither the glyphs of that element's text content nor its white space may be altered for the purpose of justification.
  

  C.7.85 Section 16.2 Alignment: the 'text-align' property

  [2010-08-24] More consistent use of “inline-level” and “block-level.” Change:

  
    Applies to:

          
            block-level elements, table cells and inline blocks block containers
          
        This property describes how inline-level content of a block container is aligned.
  

  And:

  
    […] In the case of 'left', 'right' and 'center', this property specifies how the inline-level boxes within each line box align with respect to the line box's left and right sides; alignment is not with respect to the viewport. In the case of 'justify', this property specifies that the inline-level boxes are to be made flush with both sides of the block container if possible, by expanding or contracting the contents of inline boxes, else aligned as for the initial value.
  

  C.7.86 Section 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

  [2010-08-24] Clarify that 'text-decoration' does not propagate to inline-table and inline-block elements. Change:

  
    This property describes decorations that are added to the text of an element using the element's color. When specified on an inline element, it affects all the boxes generated by that element; for all other elements, the decorations are propagated to an anonymous inline box that wraps all the in-flow inline children of the element, and to any block-level in-flow descendants. It is not, however, further propagated to floating and absolutely positioned descendants, nor to the contents of 'inline-table' and 'inline-block' descendants. or propagated to an inline element, it affects all the boxes generated by that element, and is further propagated to any in-flow block-level boxes that split the inline (see section 9.2.1.1). For block containers that establish an inline formatting context, the decorations are propagated to an anonymous inline element that wraps all the in-flow inline-level children of the block container. For all other elements it is propagated to any in-flow children. Note that text decorations are not propagated to floating and absolutely positioned descendants, nor to the contents of atomic inline-level descendants such as inline blocks and inline tables.
  

  and:

  
    If an element contains no text, user agents must refrain from rendering these text decorations on the element. For example, images will not be underlined. User agents must not render these text decorations on content that is not text. For example, images and inline blocks must not be underlined.
  

  C.7.87 Section 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

  [2010-10-05] CSS 2.1 does not specify if a text decoration that is specified on a transparent element ('visibility: hidden') is itself transparent, or only transparent where the text is transparent. Add this note:

  
    
      Note. If an element E has both 'visibility: hidden' and 'text-decoration: underline', the underline is invisible (although any decoration of E's parent is visible.) However, CSS 2.1 does not specify if the underline is visible or invisible in E's children:
      
<span style="visibility: hidden; text-decoration: underline">
 <span style="visibility: visible">
  underlined or not?
 </span>
</span>


      This is expected to be specified in level 3 of CSS.
    
  

  C.7.88 Section 16.4 Letter and word spacing: the 'letter-spacing' and 'word-spacing' properties

  [2010-04-19] Word spacing does not affect fixed-width spaces. Change:

  
    Word spacing affects each space (U+0020), and non-breaking space (U+00A0) and ideographic space (U+3000), left in the text after the white space processing rules have been applied. The effect of the property on other word-separator characters is undefined. However general punctuation, characters with zero advance width (such as the zero with space U+200B) and fixed-width spaces (such as U+3000 and U+2000 through U+200A) are not affected.
  

  C.7.89 Section 16.6 White space: the 'white-space' property

  [2010-10-25] If the document language specifies how newlines are represented, those newlines must be passed to the CSS UA as line feed (LF) characters. If the document language does not define how newlines are expressed (e.g., if text is inserted with the 'content' property), the CSS UA must treat CR, and CRLF as if they were LF:

  
    Newlines in the source can be represented by a carriage return (U+000D), a linefeed (U+000A) or both (U+000D U+000A) or by some other mechanism that identifies the beginning and end of document segments, such as the SGML RECORD-START and RECORD-END tokens. The CSS 'white-space' processing model assumes all newlines have been normalized to line feeds. UAs that recognize other newline representations must apply the white space processing rules as if this normalization has taken place. If no newline rules are specified for the document language, each carriage return (U+000D) and CRLF sequence (U+000D U+000A) in the document text is treated as single line feed character. This default normalization rule also applies to generated content.

    […]

    Each tab (U+0009), carriage return (U+000D), or space (U+0020) character surrounding a linefeed (U+000A) character is removed if 'white-space' is set to 'normal', 'nowrap', or 'pre-line'.
      
    

  C.7.90 Section 16.6.1 The 'white-space' processing model

  [2010-08-06] The sentence that absolutely positioned elements do not create line breaking opportunities is normative, not informative.

  C.7.91 Section 16.6.1 The 'white-space' processing model

  [2010-08-06] The first paragraph is moved to 9.2.2.1. Also, as is clear from the latter section, the “should” is a “must”:

  
    Any text that is directly contained inside a block container element (not inside an inline element) should must be treated as an anonymous inline element.
  

  C.7.92 Section 16.6.1 The 'white-space' processing model

  [2010-08-24] More consistent use of “inline-level” and “block-level.” Change:

  
    Then, the entire block is rendered block container's inlines are laid out.
  

  C.7.93 Section 17.2 The CSS table model

  [2010-08-04] Clarify that the term “row group” includes header groups and footer groups as well:

  
    Thus, the table model consists of tables, captions, rows, row groups (including header groups and footer groups), columns, column groups, and cells.
  

  C.7.94 Section 17.2.1 Anonymous table objects

  [2010-08-24] XML and HTML5, unlike SGML, do not automatically remove insignificant white space. Change the rules for generating anonymous table elements to suppress most white space between elements, rather than consider it the content of an anonymous table cell.

  C.7.95 Section 17.2.1 Anonymous table objects

  [2010-08-24] The static position of absolutely positioned elements between table cells or rows was not very useful. Define that the static position of such an element is found not just as if the element had 'position: static', but also had 'display: inline' and zero width and height.

  C.7.96 Section 17.4 Tables in the visual formatting model

  [2010-04-19] The caption of the image still describes the image as it was in the previous version. Change:

  
    Diagram of a table with a caption above it; the top margin of the caption is collapsed with the top margin of the table.
  

  C.7.97 Section 17.4 Tables in the visual formatting model

  [2010-10-13] Clarify which of the two boxes generated by a table element is the principal box:

  
    In both cases, the table box generates an anonymous box a principal block box called the table wrapper box that contains the table box itself and any caption boxes (in document order). The table box is a block-level box that contains the table's internal table boxes. The caption boxes are block-level boxes that retain their own content, padding, margin, and border areas, and are rendered as normal blocks block boxes inside the anonymous table wrapper box. Whether the caption boxes are placed before or after the table box is decided by the 'caption-side' property, as described below.

    The anonymous table wrapper box is a 'block' box if the table is block-level, and an 'inline-block' box if the table is inline-level. The anonymous table wrapper box establishes a block formatting context. The table box (not the anonymous table wrapper box) is used when doing baseline vertical alignment for an 'inline-table'. The width of the anonymous table wrapper box is the border-edge width of the table box inside it, as described by section 17.5.2. Percentages on 'width' and 'height' on the table are relative to the anonymous table wrapper box's containing block, not the anonymous table wrapper box itself.

    The computed values of properties 'position', 'float', 'margin-*', 'top', 'right', 'bottom', and 'left' on the table box are used on the anonymous table wrapper box instead of the table box. The table box uses the initial values for those properties.
  

  C.7.98 Section 17.5.2.2 Automatic table layout

  [2010-10-25] The width of the table caption contributes to the width of the table if 'table-layout' is 'auto':

  
    This gives a maximum and minimum width for each column.

    The caption width minimum (CAPMIN) is determined by calculating for each caption the minimum caption outer width as the MCW of a hypothetical table cell that contains the caption formatted as "display: block". The greatest of the minimum caption outer widths is CAPMIN.

    Column and caption widths influence the final table width as follows:

    If the 'table' or 'inline-table' element's 'width' property has a computed value (W) other than 'auto', the property's value as used for layout used width is the greater of W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN). If W the used widthis greater than MIN, the extra width should be distributed over the columns.
      

      If the 'table' or 'inline-table' element has 'width: auto', the table width used for layout used width is the greater of the table's containing block width, CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is less than that of the containing block, use MAX max(MAX, CAPMIN).
      
    

  C.7.99 Section 17.5.3 Table height algorithms

  [2010-07-15] Clarify that the height of a table row can be influenced by 'vertical-align' and 'height', but the content box of the table cell is not affected.

  
    […] it is the maximum of the row's specified 'height', the specified 'height' of each cell in the row, and the minimum height (MIN) required by the cells
  

  and

  
    In CSS 2.1, the height of a cell box is the maximum of the table cell's 'height' property and the minimum height required by the content (MIN). minimum height required by the content. The table cell's 'height' property can influence the height of the row, but it does not increase the height of the cell box. A value of 'auto' for 'height' implies that the value MIN will be used for layout.
  

  C.7.100 Section 17.5.4 Horizontal alignment in a column

  [2010-08-24] More consistent use of “inline-level.” Change:

  
    The horizontal alignment of a cell's inline content inline-level content within a cell box
  

  C.7.101 Section B.2 Informative references

  [2010-08-06] BCP 47 replaces RFC 3066.

  C.7.102 Section D. Default style sheet for HTML 4

  [2010-10-05] HTML defines that HTML's block elements represent a Unicode embedding even if they are displayed inline by means of a style sheet. The default style sheet for HTML didn't yet express that. Add:

  
    
html, address,
blockquote,
body, dd, div,
dl, dt, fieldset, form,
frame, frameset,
h1, h2, h3, h4,
h5, h6, noframes,
ol, p, ul, center,
dir, hr, menu, pre   { display: block; unicode-bidi: embed }

  

  C.7.103 Section E.2 Painting order

  [2010-07-07] Clarification:

  
    The stacking order for painting order for the descendants of an element generating a stacking context (see the 'z-index' property) is: […]
  

  C.7.104 Appendix G Grammar of CSS 2.1

  [2010-10-25] The appendix is not normative.

  C.8 Changes since the working draft of 7 December 2010

  C.8.1 8.3.1 Collapsing margins

  The section is completely rewritten to make the normative text shorter and clearer.

  C.8.2 10.8.1 Leading and half-leading

  The remark about equal line spacing is made more precise and put in green, to make it clearer that it is a note:

  
    Generally, Note. when there is only one value of 'line-height' for all inline boxes in a block container box and they are all in the same font (and there are no replaced elements, inline-block elements, etc.), the above will ensure that baselines of successive lines are exactly 'line-height' apart. This is important when columns of text in different fonts have to be aligned, for example in a table.
  

  C.8.3 10.3 Calculating widths and margins

  Added a note that the width calculation only yields a tentative value, still to be compared to 'min-width' and 'max-width'

  
    Note. The used value of 'width' calculated below is a tentative value, and may have to be calculated multiple times, depending on 'min-width' and 'max-width', see the section Minimum and maximum widths below.
  

  A similar note is added to section 10.6 about calculating heights.

  C.8.4 14.3 Gamma correction

  The section on gamma correction was removed. It existed only to help implementations on certain operating systems of the 1990s.

  C.8.5 11.1.2 Clipping: the 'clip' property

  The 2nd and 4th offsets of the clip rectangle are offsets from the left edge of the element. The 'direction' property no longer has an influence.

  C.8.6 9.4.2 Inline formatting contexts

  The words "line feed" were a typing error. The intended words are "forced line break."

  (The sentence was subsequently changed further as a result of another issue.)

  C.8.7 10.3.2 Inline, replaced elements

  No image formats were found that allow an intrinsic size to be expressed as a percentage. The relevant definitions are removed:

  
    Percentage intrinsic widths are first evaluated with respect to the containing block's width, if that width does not itself depend on the replaced element's width. If it does, then the resulting layout is undefined in CSS 2.1.
  

  Similarly in 10.6.2:

  
    Percentage intrinsic heights are evaluated with respect to the containing block's height, if that height is specified explicitly, or if the replaced element is absolutely positioned. If neither of these conditions is met, then percentage values on such replaced elements cannot be resolved and such elements are assumed to have no intrinsic height.
  

  And in 12.5.1:

  
    2. If the image's intrinsic width or height is given as a percentage, then that percentage is resolved against 1em.
  

  C.8.8 10.1 Definition of "containing block"

  In CSS 2.1, it is undefined what the containing block of an absolutely positioned element is, if its nearest positioned ancestor is inline and split over multiple lines:

  
    4. If the element has 'position: absolute' […] following way;

    In the case that the ancestor is an inline box inline-level element, the containing block depends on the 'direction' property of the ancestor: is the bounding box around the padding boxes of the first and the last inline boxes generated for that element. In CSS 2.1, if the inline element is split across multiple lines, the containing block is undefined.

        
            If the 'direction' is 'ltr', the top and left of the containing block are the top and left padding edges of the first box generated by the ancestor, and the bottom and right are the bottom and right padding edges of the last box of the ancestor.
          

          
            If the 'direction' is 'rtl', the top and right are the top and right padding edges of the first box generated by the ancestor, and the bottom and left are the bottom and left padding edges of the last box of the ancestor.
          
        Note: This may cause the containing block's width to be negative.
      
    

  C.8.9 13.2.2 Page selectors: selecting left, right, and first pages

  CSS 2.1 does not define if ':first' applies to the first page or the first non-blank page:

  
    If a forced break occurs before the first generated box, it is undefined in CSS 2.1 whether ':first' applies to the blank page before the break or to the page after it.
  

  C.8.10 8.3.1 Collapsing margins

  Added a note with a link to 9.4.2, which defines types of line boxes that exist but do not interfere with collapsing margins.

  
    no line boxes, no clearance, no padding and no border separate them (Note that certain zero-height line boxes (see 9.4.2) are ignored for this purpose.)
      
    

  C.8.11 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties

  The definition of which height is used for the different kinds of inline-level boxes is made explicit, rather than linked:

  
    The height of each inline-level box in the line box is calculated. For replaced elements, inline-block elements, and inline-table elements, this is the height of their margin box; for inline boxes, this is their 'line-height'. (See "Calculating heights and margins" and the 'line-height' property height of inline boxes in "Leading and half-leading".)
      
    

  The part of the definition that was in 10.6.2 is removed:

  
    For 'inline' and 'inline-block' elements, the margin box is used when calculating the height of the line box.
  

  C.8.12 10.8.1 Leading and half-leading

  Inserted the following before the definitions of the keywords of 'vertical-align' to define precisely which box is aligned:

  
    In the following definitions, for inline non-replaced elements, the box used for alignment is the box whose height is the 'line-height' (containing the box's glyphs and the half-leading on each side, see above). For all other elements, the box used for alignment is the margin box.
  

  Also, to make sure there always is a box whose height is 'line-height', a phrase earlier in the same section was removed:

  
    User agent must align the glyphs in a non-replaced inline box to each other by their relevant baselines, and to nested inline boxes according to 'vertical-align'.
  

  And another modified:

  
    The height of the inline box is then the smallest such that it encloses all glyphs and their leading, as well as all nested inline boxes. encloses all glyphs and their half-leading on each side and is thus exactly 'line-height'. Boxes of child elements do not influence this height.
  

  C.8.13 10.6.1 Inline, non-replaced elements

  Improve language:

  
    The vertical padding, border and margin of an inline, non-replaced box start at the top and bottom of the content area, not and has nothing to do with the 'line-height'. But only the 'line-height' is used when calculating the height of the line box.
  

  C.8.14 9.5.1 Positioning the float: the 'float' property

  A left float must not only not overlap a right float, but must also not be completely to the right of it.

  
    3. The right outer edge of a left-floating box may not be to the right of the left outer edge of any right-floating box that is to the right of next to it. Analogous rules hold for right-floating elements.
  

  C.8.15 9.2.1.1 Anonymous block boxes

  An error in the description of the example:

  
    The resulting boxes would be an anonymous block box around a block box representing the BODY, containing an anonymous block box around C1, the SPAN block box, and another anonymous block box around C2.
  

  C.8.16 5.12.1 The :first-line pseudo-element

  UAs are not required to support 'vertical-align' on '::first-line'.

  
    The following properties apply to a :first-line pseudo-element: font properties, color property, background properties, 'word-spacing', 'letter-spacing', 'text-decoration', 'vertical-align', 'text-transform', and 'line-height'. UAs may apply other properties as well.
  

  C.8.17 16.6 White space: the 'white-space' property

  CSS 2.1 does not define whether the Line Separator character in Unicode and other forced line break characters (other than LF) cause a line break. (Level 3 will probably define this in detail.)

  
    pre

      
        This value prevents user agents from collapsing sequences of white space. Lines are only broken at newlines in the source, or at occurrences of "\A" in generated content preserved newline characters.
      
    

  and

  
    pre-wrap

      
        This value prevents user agents from collapsing sequences of white space. Lines are broken at newlines in the source, at occurrences of "\A" in generated content, preserved newline characters, and as necessary to fill line boxes.
      

      pre-line

      
        This value directs user agents to collapse sequences of white space. Lines are broken at newlines in the source, at occurrences of "\A" in generated content, preserved newline characters, and as necessary to fill line boxes.
      
    

  and add this paragraph:

  
    UAs must recognize line feeds (U+000A) as newline characters. UAs may additionally treat other forced break characters as newline characters per UAX14.
  

  C.8.18 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  CSS 2.1 omits to define how the implicit counters of 'list-item' are reset and incremented. This will be specified in level 3.

  
    CSS 2.1 does not define how the list numbering is reset and incremented. This is expected to be defined in the CSS List Module [CSS3LIST].
  

  C.8.19 9.7 Relationships between 'display', 'position', and 'float'

  Some UAs treat 'display: list-item' on the root element as 'block'. Allow that behavior for now:

  
    4. Otherwise, if the element is the root element, 'display' is set according to the table below, except that it is undefined in CSS 2.1 whether a specified value of 'list-item' becomes a computed value of 'block' or 'list-item'.
  

  C.8.20 9.4.2 Inline formatting contexts

  Empty line boxes aren't generated at all, rather than just ignored for margin collapsing. But their virtual position must still be calculated if they contain empty inlines with absolutely positioned or floating descendants:

  
    Line boxes are created as needed to hold inline-level content within an inline formatting context. Line boxes that contain no text, no preserved white space, no inline elements with non-zero margins, padding, or borders, and no other in-flow content (such as images, inline blocks or inline tables), and do not end with a line feed preserved newline must be treated as zero-height line boxes for the purposes of determining the positions of any elements inside of them, and treated as not existing for any other purpose. For the purposes of margin collapsing, this line box must be ignored.
  

  C.8.21 4.1.9 Comments

  Use same phrasing for comment tokens as in section 4.1.1:

  
    They may occur anywhere between outside other tokens
  

  C.8.22 12.5.1 Lists: the 'list-style-type', 'list-style-image', 'list-style-position', and 'list-style' properties

  The size computation of list marker images without an intrinsic size is modified to be consistent with how image sizes are computed in other places, using 1em for the available width and 1:1 for the default aspect ratio:

  
    
        If the image has an intrinsic width or height, then that intrinsic width/height becomes the image's used width/height. If the image has a intrinsic width and height, the used width and height are the intrinsic width and height.
      

      
        If the image has no intrinsic ratio and a ratio cannot be calculated from its width and height, then its intrinsic ratio is assumed to be 1:1. Otherwise, if the image has an intrinsic ratio and either an intrinsic width or an intrinsic height, the used width/height is the same as the provided intrinsic width/height, and the used value of the missing dimension is calculated from the provided dimension and the ratio.
      

      
        If the image has a width but no height, its height is calculated from the intrinsic ratio. Otherwise, if the image has an intrinsic ratio, the used width is 1em and the used height is calculated from this width and the intrinsic ratio. If this would produce a height larger than 1em, then the used height is instead set to 1em and the used width is calculated from this height and the intrinsic ratio.
      

      
        If the image's height cannot be resolved from the rules above, then the image's height is assumed to be 1em. Otherwise, the image's used width is its intrinsic width if it has one, or else 1em. The image's used height is its intrinsic height if it has one, or else 1em.
      

      
        If the image has no intrinsic width, then its width is calculated from the resolved height and the intrinsic ratio.
      
    

  C.8.23 9.5.1 Positioning the float: the 'float' property

  Because of lack of sufficient implementations, the top of a floating box is allowed to be above the top of earlier boxes in certain difficult cases. Add after the numbered list:

  
    But in CSS 2.1, if, within the block formatting context, there is an in-flow negative vertical margin such that the float's position is above the position it would be at were all such negative margins set to zero, the position of the float is undefined.
  

  C.8.24 9.3 Positioning schemes

  Add formal definitions of the terms “out of flow,” “in-flow” and “flow of an element”:

  
    An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow. The flow of an element A is the set consisting of A and all in-flow elements whose nearest out-of-flow ancestor is A.
  

  C.8.25 9.10 Text direction: the 'direction' and 'unicode-bidi' properties

  The list of features affected by 'direction' is not meant to be exclusive:

  
    This property specifies the base writing direction of blocks and the direction of embeddings and overrides (see 'unicode-bidi') for the Unicode bidirectional algorithm. In addition, it specifies such things as the direction of table column layout, the direction of horizontal overflow, the position of an incomplete last line in a block in case of 'text-align: justify'.
  

  C.8.26 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

  Whether the effect of 'text-decoration' propagates into tables may be the subject of a separate property in level 3:

  
    […] When specified on or propagated to an inline element, it affects all the boxes generated by that element, and is further propagated to any in-flow block-level boxes that split the inline (see section 9.2.1.1). But, in CSS 2.1, it is undefined whether the decoration propagates into block-level tables.
  

  C.8.27 16.3.1 Underlining, overlining, striking, and blinking: the 'text-decoration' property

  Clarify that the text for 'inset' and 'outset' only talks about how the border styles look (and not, e.g., about which style takes priority):

  
    *inset

      
        In the separated borders model, the border makes the entire box look as though it were embedded in the canvas. In the collapsing border model, drawn the same as 'ridge'.
      

      *outset

      
        In the separated borders model, the border makes the entire box look as though it were coming out of the canvas. In the collapsing border model, drawn the same as 'groove'.
      
    

  C.8.28 10.4 Minimum and maximum widths: 'min-width' and 'max-width'

  Added:

  
    In CSS 2.1, the effect of 'min-width' and 'max-width' on tables, inline tables, table cells, table columns, and column groups is undefined.
  

  C.8.29 9.3.2 Box offsets: 'top', 'right', 'bottom', 'left'

  'Top', right', 'bottom' and 'left' are always computed, independent of the value of other properties:

  
    
      'top'

        
          Value:  

                <length> | <percentage> | auto | inherit
              Initial:  

                auto
              Applies to:  

                positioned elements
              Inherited:  

                no
              Percentages:  

                refer to height of containing block
              Media:  

                visual
              Computed value:  

                
                  for 'position:static', 'auto'. Otherwise: if specified as a length, the corresponding absolute length; if specified as a percentage, the specified value; otherwise, 'auto'.
                
              
      
  

  Analogously for 'right', 'bottom' and 'left'.

  C.8.30 9.2.1.1 Anonymous block boxes

  Clarify that the two parts of an inline that is split by a block are on opposite sides of the block:

  
    When an inline box contains an in-flow block-level box, the inline box (and its inline ancestors within the same line box) are broken around the block-level box (and any block-level siblings that are consecutive or separated only by collapsible whitespace and/or out-of-flow elements), dividing splitting the inline box into two pieces (even if either side is empty), one on each side of the block-level box(es).
  

  C.8.31 17.4 Tables in the visual formatting model

  More precise rule for which properties apply to the table box and which to the table wrapper box:

  
    The computed values of properties 'position', 'float', 'margin-*', 'top', 'right', 'bottom', and 'left' on the table box element are used on the table wrapper box instead of and not the table box. The table box uses the initial values for those properties. ; all other values of non-inheritable properties are used on the table box and not the table wrapper box. (Where the table element's values are not used on the table and table wrapper boxes, the initial values are used instead.)
  

  C.8.32 11.1.2 Clipping: the 'clip' property

  Some text and arrows were added to the example to make it easier to see where the four offsets of the clip rectangle are applied:

  
    
         [D]
    
  

  C.8.33 13.2 Page boxes: the @page rule

  The definition of the @page rule didn't mention explicitly (except with examples) that white space is allowed:

  
    An @page rule consists of the keyword "@page", followed by an optional page selector, followed by a block containing declarations and at-rules. Comments and white space are allowed, but optional, between the @page token and the page selector and between the page selector and the block.
  

  C.8.34 4.1.1 Tokenization

  Added an example to illustrate what is meant by “the longest match” in the tokenizer:

  
    
      Example(s):

      For example, the rule of the longest match means that "red-->" is tokenized as the IDENT "red--" followed by the DELIM ">", rather than as an IDENT followed by a CDC.
    
  

  C.8.35 4.2 Rules for handling parsing errors

  Clarify that “end of line” means an end of line character, i.e., the end of file is not an end of line:

  
    User agents must close strings upon reaching the end of a line (i.e., before an unescaped line feed, carriage return or form feed character), but then drop the construct (declaration or rule) in which the string was found.
  

  C.8.36 3.1 Definitions

  There may soon be a newer version of HTML then HTML4:

  
    An HTML user agent is one that supports one or more of the HTML 2.x, HTML 3.x, or HTML 4.x specifications. A user agent that supports XHTML [XHTML], but not HTML (as listed in the previous sentence) is not considered an HTML user agent for the purpose of conformance with this specification.
  

  C.8.37 4.3.4 URLs and URIs

  Make the note about parsing URLs shorter and clearer:

  
    
      Note that COMMENT tokens cannot occur within other tokens: thus, "url(/*x*/pic.png)" denotes the URI "/*x*/pic.png", not "pic.png".
    
  

  C.8.38 9.5 Floats

  Clarify the note:

  
    Note: this means that floats with zero outer height or negative outer height do not shorten line boxes.
  

  C.8.39 11.1.1 Overflow: the 'overflow' property

  Shorten the “applies to” line:

  
    
      'overflow'

        
          Value:  

                visible | hidden | scroll | auto | inherit
              Initial:  

                visible
              Applies to:  

                
                  non-replaced block-level elements, table cells, inline-table, and inline-block elements block containers
                
              Inherited:  

                no
              Percentages:  

                N/A
              Media:  

                visual
              Computed value:  

                as specified
              
      
  

  C.8.40 9.2.1.1 Anonymous block boxes

  Clarify how block-level elements inside inline elements are affected by relative positioning:

  
    When such an inline box is affected by relative positioning, the relative positioning any resulting translation also affects the block-level box contained in the inline box.
  

  C.8.41 16.2 Alignment: the 'text-align' property

  Text is justified within the line box, which may be narrower than the block box:

  
    In the case of 'justify', this property specifies that the inline-level boxes are to be made flush with both sides of the block container line box if possible, […]
  

  C.8.42 9.5 Floats

  Only the current and later line boxes can be shortened by a float. Earlier line boxes, if the float ends up next to them, will overlap the float instead:

  
    Since a float is not in the flow, non-positioned block boxes created before and after the float box flow vertically as if the float did not exist. However, the current and subsequent line boxes created next to the float are shortened to make room for the margin box of the float.
  

  C.8.43 9.4.2 Inline formatting contexts

  A float may cause a gap between line boxes:

  
    […] Thus, a paragraph is a vertical stack of line boxes. Line boxes are stacked with no vertical separation (except as specified elsewhere) and they never overlap.
  

  C.8.44 5.12 Pseudo-elements

  Added a note to make it explicit that CSS 2.1 does not define ':first-line' and ':first-letter' completely:

  
    Note that the sections below do not define the exact rendering of ':first-line' and ':first-letter' in all cases. A future level of CSS may define them more precisely.
  

  C.8.45 9.5 Floats

  Clarify that “overlap a float” means overlap the margin box of the float:

  
    The border box of a table, a block-level replaced element, or an element in the normal flow that establishes a new block formatting context (such as an element with 'overflow' other than 'visible') must not overlap the margin box of any floats in the same block formatting context as the element itself.
  

  C.8.46 9.5 Floats

  A line box next to a float is not shortened if it already doesn't overlap the float:

  
    […] However, the current and subsequent line boxes created next to the float are shortened as necessary to make room for the margin box of the float.
  

  C.8.47 14.2.1 Background properties: 'background-color', 'background-image', 'background-repeat', 'background-attachment', 'background-position', and 'background'

  Because of insufficient implementations of background images with an intrinsic ratio but no intrinsic size, add this note:

  
    However, the position is undefined in CSS 2.1 if the image has an intrinsic ratio, but no intrinsic size.
  

  C.8.48 9.2.4 The 'display' property

  Because some aspects of 'run-in' (most notably if and how 'clear' should apply to run-in elements when they are inline) are still under discussion, 'run-in' has been reclassified as a level 3 feature.

  Change in section 9.2.4:

  
    Value:

          
            inline | block | list-item | run-in | inline-block | table | inline-table | inline | block | list-item | run-in | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit
          
        

  and

  
    
        run-in
      

      
        This value creates either block or inline boxes, depending on context. Properties apply to run-in boxes based on their final status (inline-level or block-level).
      
    

  Remove 'run-in' from section 9.2.1 “Block-level elements and block boxes”:

  
    […] The following values of the 'display' property make an element block-level: 'block', 'list-item', and 'run-in' (part of the time; see run-in boxes), and 'table'.
  

  Remove 'run-in' from section 9.2.2 “Inline-level elements and inline boxes”:

  
    […] The following values of the 'display' property make an element inline-level: 'inline', 'inline-table', and 'inline-block' and 'run-in' (part of the time; see run-in boxes). […]

    […] A non-replaced element with a 'display' value of 'inline' generates an inline box. An element with a 'display' value of 'run-in' can also generate an inline box; see run-in boxes.
  

  Replace section 9.2.3 “Run-in boxes” by this:

  
    9.2.3 Run-in boxes

    [This section exists so that the section numbers are the same as in previous drafts. 'Display: run-in' is now defined in CSS level 3 (see CSS basic box model).]
  

  Remove 'run-in' from section 9.3 “Positioning schemes”:

  
    Normal flow. In CSS 2.1, normal flow includes block formatting of block-level boxes, inline formatting of inline-level boxes, and relative positioning of block-level and inline-level boxes, and formatting of run-in boxes.
      
    

  Remove 'run-in' from section 9.5.2 “Controlling flow next to floats: the 'clear' property”:

  
    For run-in boxes, this property applies to the final block box to which the run-in box belongs.
  

  Remove 'run-in' from section 9.7 “Relationships between 'display', 'position', and 'float'”:

  
    Specified value

          Computed value
        inline-table

          table
        
            inline, run-in, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block
          

          block
        others

          same as specified
        

  Remove 'run-in' from section 9.10 “Text direction: the 'direction' and 'unicode-bidi' properties”:

  
    The final order of characters in each block container is the same as if the bidi control codes had been added as described above, markup had been stripped, and the resulting character sequence had been passed to an implementation of the Unicode bidirectional algorithm for plain text that produced the same line-breaks as the styled text. In this process, replaced elements with 'display: inline' (and replaced elements with 'display: run-in', when they generate inline-level boxes) are treated as neutral characters, unless their 'unicode-bidi' property has a value other than 'normal', in which case they are treated as strong characters in the 'direction' specified for the element. All other atomic inline-level boxes are treated as neutral characters always.
  

  Remove 'run-in' from section E.1 “Definitions”:

  
    Tree Order

      
        Preorder depth-first traversal of the rendering tree, in logical (not visual) order for bidirectional content, after taking into account properties that move boxes around such as the 'run-in' value of 'display'.
      
    

  Remove 'run-in' from section 12.1 “The :before and :after pseudo-elements”:

  
    The :before and :after pseudo-elements interact with other boxes, such as run-in boxes, as if they were real elements inserted just inside their associated element.
  

  and also from the subsequent example.

  C.8.49 6.1.2 Computed values

  Clarify that the keyword 'inherit' means that the specified value is the inherited value. The value is not the keyword itself.

  
    When the specified value is not 'inherit', the computed value of a property is determined as specified by the Computed Value line in the definition of the property. See the section on inheritance for the definition of computed values when the specified value is 'inherit'.
  

  And in 6.2.1:

  
    Each property may also have a specified cascaded value of 'inherit', which means that, for a given element, the property takes the same computed specified value as the property for the element's parent. The 'inherit' value can be used to strengthen inherited enforce inheritance of values, and it can also be used on properties that are not normally inherited.
  

  C.8.50 10.3.2 Inline, replaced elements

  Because of lack of implementations, the width of a replaced element with an intrinsic ratio but neither intrinsic with nor intrinsic height is left undefined:

  
    If 'height' and 'width' both have computed values of 'auto' and the element has an intrinsic ratio but no intrinsic height or width, and then the used value of 'width' is undefined in CSS 2.1. However, it is suggested that, if the containing block's width does not itself depend on the replaced element's width, then the used value of 'width' is calculated from the constraint equation used for block-level, non-replaced elements in normal flow.
  

  C.8.51 Section 9.5.2 Controlling flow next to floats: the 'clear' property

  Because of lack of implementations, also allow 'clear' to work in a different way for now:

  
    Computing the clearance of an element on which 'clear' is set is done by first determining the hypothetical position of the element's top border edge within its parent block. This position is where the actual top border edge would have been if the element had a non-zero bottom border and its 'clear' property had been 'none'.

    If this hypothetical position of the element's top border edge is not past the relevant floats, then clearance is introduced, and margins collapse according to the rules in 8.3.1.

    Then the amount of clearance is set to the greater of:

    The amount necessary to place the border edge of the block even with the bottom outer edge of the lowest float that is to be cleared.

      The amount necessary to place the top border edge of the block at its hypothetical position.
    Alternatively, clearance is set exactly to the amount necessary to place the border edge of the block even with the bottom outer edge of the lowest float that is to be cleared.

    Note: Both behaviors are allowed pending evaluation of their compatibility with existing Web content. A future CSS specification will require either one or the other.
  

  C.8.52 G.2 Lexical scanner

  The tokenizer in the appendix allowed backslashes in the URI token, in contradiction with the same token in the core grammar and the error recovery token {baduri}:

  
    
{U}{R}{L}"("{w}{string}{w}")"      {return URI;}
{U}{R}{L}"("{w}{url}{w}")"         {return URI;}
"url("{w}{string}{w}")"            {return URI;}
"url("{w}{url}{w}")"               {return URI;}

  

  C.8.53 Section 9.5.2 Controlling flow next to floats: the 'clear' property

  The top border edge is now well-defined in the section on collapsing margins. That is the hypothetical position to use for clearance:

  
    This position is where the actual top border edge would have been if the element had a non-zero bottom border and its 's 'clear' property had been 'none'.
  

  C.8.54 9.5 Floats

  Remove ambiguities:

  
    If a shortened line box is too small to contain any content after the float, then that content the line box is shifted downward (and its width recomputed) until either it some content fits or there are no more floats present. Any content in the current line before a floated box is reflowed in the first available same line on the other side of the float.
  

  C.8.55 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'

  Removed redundancy (the top edge was already defined elsewhere) and made the implied cases for the bottom edge explicit:

  
    If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.

    If it has block-level children, the height is the distance between the top border-edge of the topmost block-level child box that does not have margins collapsed through it and the bottom border-edge of the bottommost block-level child box that does not have margins collapsed through it. However, if the element has a non-zero top padding and/or top border, or is the root element, then the content starts at the top margin edge of the topmost child. (The first case expresses the fact that the top and bottom margins of the element collapse with those of the topmost and bottommost children, while in the second case the presence of the padding/border prevents the top margins from collapsing.) Similarly, if the bottom margin of the block does not collapse with the bottom margin of its last in-flow child, then the content ends at the bottom margin edge of the bottommost child.

    The element's height is the distance from its top content edge to the first applicable of the following:

    
        the bottom edge of the last line box, if the box establishes a inline formatting context with one or more lines
      

      
        the bottom edge of the bottom (possibly collapsed) margin of its last in-flow child, if the child's bottom margin does not collapse with the element's bottom margin
      

      
        the bottom border edge of the last in-flow child whose top margin doesn't collapse with the element's bottom margin
      

      
        zero, otherwise
      
    

  付録 D. HTML 4のためのデフォルトスタイルシート

  この付録は参考情報で、規範的ではない。

  このスタイルシートは、現在のユーザーエージェントの実装の広範な調査に基づく、すべてのHTML 4（[HTML4]）要素の標準的な書式設定を記述する。開発者は、実装のデフォルトのスタイルシートとして使用することを推奨する。

  一部のHTML要素の見栄えはCSS 2.1で表現することはできない。置換要素（"img"、"object"）、スクリプト要素（"script"、"applet"）、フォーム制御要素、およびフレーム要素が含まれる。

  他の要素については、従来の見栄えはCSSに記載されるが、解決策は要素を削除することである。たとえば、FONT要素は他の要素（たとえば、DIV）にCSS宣言を付加することによって置換可能である。同様に、表象的な属性（たとえば、テーブルの属性"border"）の従来の見栄えは、CSSに記述可能であるが、ソース文書のマークアップを変更しなければならない。
  
html, address,
blockquote,
body, dd, div,
dl, dt, fieldset, form,
frame, frameset,
h1, h2, h3, h4,
h5, h6, noframes,
ol, p, ul, center,
dir, hr, menu, pre   { display: block; unicode-bidi: embed }
li              { display: list-item }
head            { display: none }
table           { display: table }
tr              { display: table-row }
thead           { display: table-header-group }
tbody           { display: table-row-group }
tfoot           { display: table-footer-group }
col             { display: table-column }
colgroup        { display: table-column-group }
td, th          { display: table-cell }
caption         { display: table-caption }
th              { font-weight: bolder; text-align: center }
caption         { text-align: center }
body            { margin: 8px }
h1              { font-size: 2em; margin: .67em 0 }
h2              { font-size: 1.5em; margin: .75em 0 }
h3              { font-size: 1.17em; margin: .83em 0 }
h4, p,
blockquote, ul,
fieldset, form,
ol, dl, dir,
menu            { margin: 1.12em 0 }
h5              { font-size: .83em; margin: 1.5em 0 }
h6              { font-size: .75em; margin: 1.67em 0 }
h1, h2, h3, h4,
h5, h6, b,
strong          { font-weight: bolder }
blockquote      { margin-left: 40px; margin-right: 40px }
i, cite, em,
var, address    { font-style: italic }
pre, tt, code,
kbd, samp       { font-family: monospace }
pre             { white-space: pre }
button, textarea,
input, select   { display: inline-block }
big             { font-size: 1.17em }
small, sub, sup { font-size: .83em }
sub             { vertical-align: sub }
sup             { vertical-align: super }
table           { border-spacing: 2px; }
thead, tbody,
tfoot           { vertical-align: middle }
td, th, tr      { vertical-align: inherit }
s, strike, del  { text-decoration: line-through }
hr              { border: 1px inset }
ol, ul, dir,
menu, dd        { margin-left: 40px }
ol              { list-style-type: decimal }
ol ul, ul ol,
ul ul, ol ol    { margin-top: 0; margin-bottom: 0 }
u, ins          { text-decoration: underline }
br:before       { content: "\A"; white-space: pre-line }
center          { text-align: center }
:link, :visited { text-decoration: underline }
:focus          { outline: thin dotted invert }

/* Begin bidirectionality settings (do not change) */
BDO[DIR="ltr"]  { direction: ltr; unicode-bidi: bidi-override }
BDO[DIR="rtl"]  { direction: rtl; unicode-bidi: bidi-override }

*[DIR="ltr"]    { direction: ltr; unicode-bidi: embed }
*[DIR="rtl"]    { direction: rtl; unicode-bidi: embed }

@media print {
  h1            { page-break-before: always }
  h1, h2, h3,
  h4, h5, h6    { page-break-after: avoid }
  ul, ol, dl    { page-break-before: avoid }
}




  付録 E. スタックコンテキストの詳説

  
    目次

    E.1 定義

      E.2 描画順序

      E.3 ノート
    

  この章では、仕様の残りでの説明よりも詳細にCSS 2.1描画順序を定義する。

  E.1 定義

  ツリー順

    周りのボックスを移動するプロパティを考慮した後、双方向のコンテンツのための（視覚でなく）論理的な順序で、レンダリングツリーの先行順に深さ探索すること。

    要素

    この説明で"要素"は、実際の要素、擬似要素、および匿名ボックスを指す。擬似要素と匿名ボックスは適切な場所で子孫として扱われる。たとえば、外側のリストマーカーはラインボックスに隣接する':before'ボックスの前に来るが、これは、ボックス内容の前に来る、など。
  E.2 描画順序

  スタックの最下部はユーザーから最も遠いが、スタックの最上位はユーザーに最も近い:
  
             |     |         |    |
             |          |    |    |     ⇦ ☻
             |          |         |     ユーザー
z-index:  canvas  -1    0    1    2


  スタックコンテキストの背景と最も負の位置のスタックコンテキストは、スタックの下部にあり、一方最も正の位置スタックコンテキストはスタックの最上位にある。

  別の内側に含まれる場合はキャンバスは透明であり、そうでない場合はユーザーエージェント定義の色が与えられる。範囲内で無限大であり、ルート要素を含む。初めに、ビューポートは、キャンバスの原点で左上隅で固定される。

  スタックコンテキスト（ 'z-index'プロパティを参照）を生成する要素の子孫の塗装順序は次のとおり:

  
      要素がルート要素の場合：

      全体のキャンバス上の要素の背景色を指定する。

        ルート要素に塗装された場合、全体のキャンバス一面に、要素の背景画像は使用され原点に固定される。
      

    
      要素が、ブロック、リスト項目、または他のブロックと等価である場合：

      ルート要素である場合を除き、要素の背景色。

        ルート要素である場合を除き、要素の背景画像。

        要素のボーダー。
      そうでなければ、要素がブロックレベルのテーブルの場合：

      ルート要素である場合を除き、テーブルの背景（色、次に画像）。

        列グループの背景（色、次に画像）。

        列の背景（色、次に画像）。

        行グループの背景（色、次に画像）。

        行の背景（色、次に画像）。

        セルの背景（色、次に画像）。

        すべてのテーブルのボーダー（分離ボーダーによるツリー順で）。
      

    
      z-indexの順（最も負のものが最初）でz-index（0を除く）とともに配置された子孫によって形成されたスタックコンテキスト、次にツリーの順。
    

    
      要素が、ブロック、リスト項目、または他のブロックと等価である場合、ツリーの順でほとんどすべてのフロー内、非配置、ブロックレベルの子孫：

      要素の背景色。

        要素の背景画像。

        要素のボーダー。
      そうでなければ、要素がテーブル：

      テーブルの背景（色、次に画像）。

        列グループの背景（色、次に画像）。

        列の背景（色、次に画像）。

        行グループの背景（色、次に画像）。

        行の背景（色、次に画像）。

        セルの背景（色、次に画像）。

        すべてのテーブルのボーダー（分離ボーダーによるツリー順で）。
      

    
      すべての非配置浮動子孫は、ツリーの順。これらのそれぞれについて、あたかも新しいスタックコンテキストを作成したかのように要素を扱うが、実際に新しいスタックコンテキストを作成し、任意の配置子孫と子孫は、親スタックコンテキストではなく、この新しいものの一部と見なされるべきである。
    

    
      要素は、その後、スタックコンテキストを生成し、インライン要素である場合：

      
          要素であるそれぞれの行ボックスの場合：

          その行ボックス内の要素のボックスの7.2.1にジャンプする（ツリー順に）。
          
      

    
      そうでなければ、最初に要素に対して、次にすべてのフロー、非配置、ブロックレベルの子孫のツリー順に：

      
          要素がブロックレベル置換要素の場合、原始的な置換内容。
        

        
          そうでなければ、その要素の各行ボックスに対して：

          
              その行ボックスで、各ボックスにその要素の子である。ツリーの順序で：

              
                  要素の背景色。
                

                
                  要素の背景画像。
                

                
                  要素のボーダー。
                

                
                  インライン要素に対して：

                  
                      すべての要素のフロー内、非配置、この行のボックスにあるインラインレベルの子供、この行のボックス上にある要素内のテキストのすべての実行、ツリーの順序で：

                      
                          テキストの実行である場合：

                          下線を適用する要素のツリー順で、要素のテキストに影響を与える下線（もしあれば、最も深い要素の下線が最上位とルート要素の下線を描かれているような、もしあれば、一番下の描画されるような）。

                            上線を適用する要素のツリー順で、要素のテキストに影響を与える上線（もしあれば、最も深い要素の上線が最上位とルート要素の上線を描かれているような、もしあれば、一番下の描画されるような）。

                            テキスト。

                            中央線を適用する要素のツリー順で、要素のテキストに影響を与える中央線（もしあれば、最も深い要素の中央線が最上位とルート要素の中央線を描かれているような、もしあれば、一番下の描画されるような）。
                          

                        
                          そうでなければ、その要素に対して7.2.1 に飛ぶ。
                        
                      
                  インラインブロックおよびインラインテーブル要素に対して：

                  これらのそれぞれについて、あたかも新しいスタックコンテキストを作成したかのように要素を扱うが、実際に新しいスタックコンテキストを作成し、任意の配置子孫と子孫は、親スタックコンテキストではなく、この新しいものの一部と見なされるべきである。
                  インラインレベル置換要素に対して：

                  原始的に置換内容。
                  
              ボックスの一部は、行分割、またはUnicode双方向アルゴリズムによって生成されている場合がある。
            

            
              必要に応じて、要素のアウトライン（以下10を参照）。
            
          

        
          必要に応じて、要素がブロックレベルであれば、要素のアウトライン（以下10を参照）。
        
      

    
      ツリーの順序で、'z-index: auto'または 'z-index: 0'をもつすべての配置子孫。 'z-index: auto'をもつこれらにとっては、新しいスタックコンテキストを作成したかのように要素を扱うが、実際に新しいスタックコンテキストを作成し、任意の配置子孫と子孫は、新しいものではなく、親スタックコンテキストの一部と考慮されるべきである。'z-index: 0'をこれらのために、原始的な生成スタックコンテキストを扱う。
    

    
      z-indexの順序（最小が最初）、ツリーの順序でのz-indexが1以上と配置子孫によって形成されたスタックコンテキスト。
    

    
      最後に、上記の手順で輪郭を描画しない実装では、この段階では、このスタックコンテキストからアウトラインを描画しなければならない。（この手順でアウトラインの描画を推奨する。）
    
  E.3 ノート

  ルート要素の背景は、全体のキャンバス一面に一度だけ描かれる。

  双方向のインラインの背景はツリー順で描かれている一方、視覚的な順序で配置される。インライン背景の配置はCSS 2.1で指定されてないので、これらの2つの要件の正確な結果は、ユーザーエージェント定義である。CSS3は、詳細に定義するかもしれない。

  付録 F. 全プロパティ表

  この付録は参考情報で、規範的ではない。

  Name

        値

        Initial value

        Applies to
        (Default: all)

        Inherited?

        Percentages
        (Default: N/A)

        メディアグループ
      'azimuth'

        <angle> | [[ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards | inherit

        center

         

        yes

         

        aural
      'background-attachment'

        scroll | fixed | inherit

        scroll

         

        no

         

        visual
      'background-color'

        <color> | transparent | inherit

        transparent

         

        no

         

        visual
      'background-image'

        <uri> | none | inherit

        none

         

        no

         

        visual
      'background-position'

        [ [ <percentage> | <length> | left | center | right ] [ <percentage> | <length> | top | center | bottom ]? ] | [ [ left | center | right ] || [ top | center | bottom ] ] | inherit

        0% 0%

         

        no

        ボックス自身の大きさを参照

        visual
      'background-repeat'

        repeat | repeat-x | repeat-y | no-repeat | inherit

        repeat

         

        no

         

        visual
      'background'

        ['background-color' || 'background-image' || 'background-repeat' || 'background-attachment' || 'background-position'] | inherit

        個々のプロパティを参照

         

        no

        allowed on 'background-position'

        visual
      'border-collapse'

        collapse | separate | inherit

        separate

        'table'および'inline-table'要素

        yes

         

        visual
      'border-color'

        [ <color> | transparent ]{1,4} | inherit

        個々のプロパティを参照

         

        no

         

        visual
      'border-spacing'

        <length> <length>? | inherit

        0

        'table'および'inline-table'要素 

        yes

         

        visual
      'border-style'

        <border-style>{1,4} | inherit

        個々のプロパティを参照

         

        no

         

        visual
      'border-top' 'border-right' 'border-bottom' 'border-left'

        [ <border-width> || <border-style> || 'border-top-color' ] | inherit

        個々のプロパティを参照

         

        no

         

        visual
      'border-top-color' 'border-right-color' 'border-bottom-color' 'border-left-color'

        <color> | transparent | inherit

        'color'プロパティの値

         

        no

         

        visual
      'border-top-style' 'border-right-style' 'border-bottom-style' 'border-left-style'

        <border-style> | inherit

        none

         

        no

         

        visual
      'border-top-width' 'border-right-width' 'border-bottom-width' 'border-left-width'

        <border-width> | inherit

        medium

         

        no

         

        visual
      'border-width'

        <border-width>{1,4} | inherit

        個々のプロパティを参照

         

        no

         

        visual
      'border'

        [ <border-width> || <border-style> || 'border-top-color' ] | inherit

        個々のプロパティを参照

         

        no

         

        visual
      'bottom'

        <length> | <percentage> | auto | inherit

        auto

        位置指定された要素

        no

        内容ブロックの高さを参照

        visual
      'caption-side'

        top | bottom | inherit

        top

        'table-caption' elements

        yes

         

        visual
      'clear'

        none | left | right | both | inherit

        none

        ブロックレベル要素

        no

         

        visual
      'clip'

        <shape> | auto | inherit

        auto

        絶対配置要素

        no

         

        visual
      'color'

        <color> | inherit

        ユーザーエージェントに依存

         

        yes

         

        visual
      'content'

        normal | none | [ <string> | <uri> | <counter> | attr(<identifier>) | open-quote | close-quote | no-open-quote | no-close-quote ]+ | inherit

        normal

        :beforeおよび:after擬似要素

        no

         

        all
      'counter-increment'

        [ <identifier> <integer>? ]+ | none | inherit

        none

         

        no

         

        all
      'counter-reset'

        [ <identifier> <integer>? ]+ | none | inherit

        none

         

        no

         

        all
      'cue-after'

        <uri> | none | inherit

        none

         

        no

         

        aural
      'cue-before'

        <uri> | none | inherit

        none

         

        no

         

        aural
      'cue'

        [ 'cue-before' || 'cue-after' ] | inherit

        個々のプロパティを参照

         

        no

         

        aural
      'cursor'

        [ [<uri> ,]* [ auto | crosshair | default | pointer | move | e-resize | ne-resize | nw-resize | n-resize | se-resize | sw-resize | s-resize | w-resize | text | wait | help | progress ] ] | inherit

        auto

         

        yes

         

        visual, interactive
      'direction'

        ltr | rtl | inherit

        ltr

        すべての要素、ただし文を参照のこと。

        yes

         

        visual
      'display'

        inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit

        inline

         

        no

         

        all
      'elevation'

        <angle> | below | level | above | higher | lower | inherit

        level

         

        yes

         

        aural
      'empty-cells'

        show | hide | inherit

        show

        'table-cell'要素

        yes

         

        visual
      'float'

        left | right | none | inherit

        none

        すべて、ただし9.7節参照

        no

         

        visual
      'font-family'

        [[ <family-name> | <generic-family> ] [, <family-name>| <generic-family>]* ] | inherit

        ユーザーエージェントに依存

         

        yes

         

        visual
      'font-size'

        <absolute-size> | <relative-size> | <length> | <percentage> | inherit

        medium

         

        yes

        継承されたフォントサイズを参照

        visual
      'font-style'

        normal | italic | oblique | inherit

        normal

         

        yes

         

        visual
      'font-variant'

        normal | small-caps | inherit

        normal

         

        yes

         

        visual
      'font-weight'

        normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit

        normal

         

        yes

         

        visual
      'font'

        [ [ 'font-style' || 'font-variant' || 'font-weight' ]? 'font-size' [ / 'line-height' ]? 'font-family' ] | caption | icon | menu | message-box | small-caption | status-bar | inherit

        個々のプロパティを参照

         

        yes

        個々のプロパティを参照

        visual
      'height'

        <length> | <percentage> | auto | inherit

        auto

        非置換インライン要素、テーブル行と行グループを除く全要素

        no

        文を参照

        visual
      'left'

        <length> | <percentage> | auto | inherit

        auto

        位置指定された要素

        no

        包含ブロックを含む幅を参照

        visual
      'letter-spacing'

        normal | <length> | inherit

        normal

         

        yes

         

        visual
      'line-height'

        normal | <number> | <length> | <percentage> | inherit

        normal

         

        yes

        要素自身のフォントの大きさを参照

        visual
      'list-style-image'

        <uri> | none | inherit

        none

        'display: list-item'をもつ要素

        yes

         

        visual
      'list-style-position'

        inside | outside | inherit

        outside

        'display: list-item'をもつ要素

        yes

         

        visual
      'list-style-type'

        disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit

        disc

        'display: list-item'をもつ要素

        yes

         

        visual
      'list-style'

        [ 'list-style-type' || 'list-style-position' || 'list-style-image' ] | inherit

        個々のプロパティを参照

        'display: list-item'をもつ要素

        yes

         

        visual
      'margin-right' 'margin-left'

        <margin-width> | inherit

        0

        table-caption、table、inline-table以外のテーブルdisplayタイプを持つ要素を除くすべての要素

        no

        包含ブロックを含む幅を参照

        visual
      'margin-top' 'margin-bottom'

        <margin-width> | inherit

        0

        table-caption、table、inline-table以外のテーブルdisplayタイプを持つ要素を除くすべての要素

        no

        包含ブロックを含む幅を参照

        visual
      'margin'

        <margin-width>{1,4} | inherit

        個々のプロパティを参照

        table-caption、table、inline-table以外のテーブルdisplayタイプを持つ要素を除くすべての要素

        no

        包含ブロックを含む幅を参照

        visual
      'max-height'

        <length> | <percentage> | none | inherit

        none

        非置換インライン要素、テーブル行と行グループを除く全要素

        no

        文を参照

        visual
      'max-width'

        <length> | <percentage> | none | inherit

        none

        非置換インライン要素、テーブル列と列グループを除く全要素

        no

        包含ブロックを含む幅を参照

        visual
      'min-height'

        <length> | <percentage> | inherit

        0

        非置換インライン要素、テーブル行と行グループを除く全要素

        no

        文を参照

        visual
      'min-width'

        <length> | <percentage> | inherit

        0

        非置換インライン要素、テーブル列と列グループを除く全要素

        no

        包含ブロックを含む幅を参照

        visual
      'orphans'

        <integer> | inherit

        2

        ブロックコンテナ要素

        yes

         

        visual, paged
      'outline-color'

        <color> | invert | inherit

        invert

         

        no

         

        visual, interactive
      'outline-style'

        <border-style> | inherit

        none

         

        no

         

        visual, interactive
      'outline-width'

        <border-width> | inherit

        medium

         

        no

         

        visual, interactive
      'outline'

        [ 'outline-color' || 'outline-style' || 'outline-width' ] | inherit

        個々のプロパティを参照

         

        no

         

        visual, interactive
      'overflow'

        visible | hidden | scroll | auto | inherit

        visible

        ブロックコンテナ

        no

         

        visual
      'padding-top' 'padding-right' 'padding-bottom' 'padding-left'

        <padding-width> | inherit

        0

        table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-columnを除くすべての要素

        no

        包含ブロックを含む幅を参照

        visual
      'padding'

        <padding-width>{1,4} | inherit

        個々のプロパティを参照

        table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-columnを除くすべての要素

        no

        包含ブロックを含む幅を参照

        visual
      'page-break-after'

        auto | always | avoid | left | right | inherit

        auto

        ブロックレベル要素（ただしテキスト参照）

        no

         

        visual, paged
      'page-break-before'

        auto | always | avoid | left | right | inherit

        auto

        ブロックレベル要素（ただしテキスト参照）

        no

         

        visual, paged
      'page-break-inside'

        avoid | auto | inherit

        auto

        ブロックレベル要素（ただしテキスト参照）

        no

         

        visual, paged
      'pause-after'

        <time> | <percentage> | inherit

        0

         

        no

        文を参照

        aural
      'pause-before'

        <time> | <percentage> | inherit

        0

         

        no

        文を参照

        aural
      'pause'

        [ [<time> | <percentage>]{1,2} ] | inherit

        個々のプロパティを参照

         

        no

        'pause-before'および'pause-after'の記述を参照

        aural
      'pitch-range'

        <number> | inherit

        50

         

        yes

         

        aural
      'pitch'

        <frequency> | x-low | low | medium | high | x-high | inherit

        medium

         

        yes

         

        aural
      'play-during'

        <uri> [ mix || repeat ]? | auto | none | inherit

        auto

         

        no

         

        aural
      'position'

        static | relative | absolute | fixed | inherit

        static

         

        no

         

        visual
      'quotes'

        [<string> <string>]+ | none | inherit

        ユーザーエージェントに依存

         

        yes

         

        visual
      'richness'

        <number> | inherit

        50

         

        yes

         

        aural
      'right'

        <length> | <percentage> | auto | inherit

        auto

        位置指定された要素

        no

        包含ブロックを含む幅を参照

        visual
      'speak-header'

        once | always | inherit

        once

        テーブルヘッダ情報を持つ要素

        yes

         

        aural
      'speak-numeral'

        digits | continuous | inherit

        continuous

         

        yes

         

        aural
      'speak-punctuation'

        code | none | inherit

        none

         

        yes

         

        aural
      'speak'

        normal | none | spell-out | inherit

        normal

         

        yes

         

        aural
      'speech-rate'

        <number> | x-slow | slow | medium | fast | x-fast | faster | slower | inherit

        medium

         

        yes

         

        aural
      'stress'

        <number> | inherit

        50

         

        yes

         

        aural
      'table-layout'

        auto | fixed | inherit

        auto

        'table'および'inline-table'要素

        no

         

        visual
      'text-align'

        left | right | center | justify | inherit

        匿名値は'direction'が'ltr'の場合は'left'として、'direction'が'rtl'の場合は'right'として振る舞う。

        ブロックコンテナ

        yes

         

        visual
      'text-decoration'

        none | [ underline || overline || line-through || blink ] | inherit

        none

         

        なし（文参照）

         

        visual
      'text-indent'

        <length> | <percentage> | inherit

        0

        ブロックコンテナ

        yes

        包含ブロックを含む幅を参照

        visual
      'text-transform'

        capitalize | uppercase | lowercase | none | inherit

        none

         

        yes

         

        visual
      'top'

        <length> | <percentage> | auto | inherit

        auto

        位置指定された要素

        no

        内容ブロックの高さを参照

        visual
      'unicode-bidi'

        normal | embed | bidi-override | inherit

        normal

        すべての要素、ただし文を参照のこと。

        no

         

        visual
      'vertical-align'

        baseline | sub | super | top | text-top | middle | bottom | text-bottom | <percentage> | <length> | inherit

        baseline

        インラインレベルとテーブルセル要素

        no

        要素自身の'line-height'を参照

        visual
      'visibility'

        visible | hidden | collapse | inherit

        visible

         

        yes

         

        visual
      'voice-family'

        [[<specific-voice> | <generic-voice> ],]* [<specific-voice> | <generic-voice> ] | inherit

        ユーザーエージェントに依存

         

        yes

         

        aural
      'volume'

        <number> | <percentage> | silent | x-soft | soft | medium | loud | x-loud | inherit

        medium

         

        yes

        継承値を参照

        aural
      'white-space'

        normal | pre | nowrap | pre-wrap | pre-line | inherit

        normal

         

        yes

         

        visual
      'widows'

        <integer> | inherit

        2

        ブロックコンテナ要素

        yes

         

        visual, paged
      'width'

        <length> | <percentage> | auto | inherit

        auto

        非置換インライン要素、テーブル列と列グループを除く全要素

        no

        包含ブロックを含む幅を参照

        visual
      'word-spacing'

        normal | <length> | inherit

        normal

         

        yes

         

        visual
      'z-index'

        auto | <integer> | inherit

        auto

        位置指定された要素

        no

         

        visual
      
  付録 G. CSS2.1の文法

  
    目次

    G.1 文法

      G.2 語彙スキャナ

      G.3 CSS2.1とCSS1のトークン化の比較

      G.4 実装ノート
    

  この付録は非規範的である。

  以下の文法は、CSS 2.1の構文を定義する。しかし、この文法はある意味でCSS 2.1のスーパーセットであり、この仕様書で文法で表現されていない追加の意味制約を課している。適合ユーザーエージェントは、また、 前方互換の構文解析規則、セレクタ記法、プロパティと値の表記、単位表記に準拠しなければならない。ただし、文書言語はCSSに含まれない制限を課すかもしれないので、すべての構文的に正しいCSSは効果を取ることができる。たとえば、HTMLは "class"属性の取りうる値に制限を課している。

  G.1 文法

  以下の文法は、LALR(1)である（これは、CSS 2.1構文のみを解析規則を表現したものにすぎないため、ほとんどのユーザーエージェントは、直接使用すべきでないことに注意する）。生成規則の形式は、人間の使い勝手に最適化され、Yacc（[YACC]）を超えた一部の簡略表記法が使用される。

  *: 0回以上の繰り返し

    +: 1回以上の繰り返し

    ?: 0または1回

    |: 選択肢の区切り

    [ ]: グループ化
  生成規則は以下の通り:
  
stylesheet
  : [ CHARSET_SYM STRING ';' ]?    [S|CDO|CDC]* [ import [ CDO S* | CDC S* ]* ]*
    [ [ ruleset | media | page ] [ CDO S* | CDC S* ]* ]*
  ;
import
  : IMPORT_SYM S*
    [STRING|URI] S* media_list?';' S*
  ;
media
  : MEDIA_SYM S* media_list '{' S* ruleset* '}' S*
  ;
media_list
  : medium [ COMMA S* medium]*
  ;
medium
  : IDENT S*
  ;
page
  : PAGE_SYM S* pseudo_page?    '{' S* declaration?[ ';' S* declaration?]* '}' S*
  ;
pseudo_page
  : ':' IDENT S*
  ;
operator
  : '/' S* | ',' S*
  ;
combinator
  : '+' S*
  | '>' S*
  ;
unary_operator
  : '-' | '+'
  ;
property
  : IDENT S*
  ;
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration?[ ';' S* declaration?]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator?selector ]?]?  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ]?']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*]?')' ]
  ;
declaration
  : property ':' S* expr prio?  ;
prio
  : IMPORTANT_SYM S*
  ;
expr
  : term [ operator?term ]*
  ;
term
  : unary_operator?    [ NUMBER S* | PERCENTAGE S* | LENGTH S* | EMS S* | EXS S* | ANGLE S* |
      TIME S* | FREQ S* ]
  | STRING S* | IDENT S* | URI S* | hexcolor | function
  ;
function
  : FUNCTION S* expr ')' S*
  ;
/*
 * There is a constraint on the color that it must
 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
 */
hexcolor
  : HASH S*
  ;


  G.2 語彙スキャナ

  以下は、Flex記法（[FLEX]参照）で書かれた、トークナイザである。トークナイザは大文字と小文字を区別しない。

  "\377"は、Flexの最新版（10進の255）で処理できる文字コードの最大値を表す。これはUnicode/ISO-10646の最大コードポイントである、"\4177777"（10進1114111）として読まれるべきである。
  
%option case-insensitive

h               [0-9a-f]
nonascii        [\240-\377]
unicode         \\{h}{1,6}(\r\n|[ \t\r\n\f])?
escape          {unicode}|\\[^\r\n\f0-9a-f]
nmstart         [_a-z]|{nonascii}|{escape}
nmchar          [_a-z0-9-]|{nonascii}|{escape}
string1         \"([^\n\r\f\\"]|\\{nl}|{escape})*\"
string2         \'([^\n\r\f\\']|\\{nl}|{escape})*\'
badstring1      \"([^\n\r\f\\"]|\\{nl}|{escape})*\\?
badstring2      \'([^\n\r\f\\']|\\{nl}|{escape})*\\?
badcomment1     \/\*[^*]*\*+([^/*][^*]*\*+)*
badcomment2     \/\*[^*]*(\*+[^/*][^*]*)*
baduri1         url\({w}([!#$%&*-\[\]-~]|{nonascii}|{escape})*{w}
baduri2         url\({w}{string}{w}
baduri3         url\({w}{badstring}
comment         \/\*[^*]*\*+([^/*][^*]*\*+)*\/
ident           -?{nmstart}{nmchar}*
name            {nmchar}+
num             [0-9]+|[0-9]*"."[0-9]+
string          {string1}|{string2}
badstring       {badstring1}|{badstring2}
badcomment      {badcomment1}|{badcomment2}
baduri          {baduri1}|{baduri2}|{baduri3}
url             ([!#$%&*-~]|{nonascii}|{escape})*
s               [ \t\r\n\f]+
w               {s}?
nl              \n|\r\n|\r|\f

A               a|\\0{0,4}(41|61)(\r\n|[ \t\r\n\f])?
C               c|\\0{0,4}(43|63)(\r\n|[ \t\r\n\f])?
D               d|\\0{0,4}(44|64)(\r\n|[ \t\r\n\f])?
E               e|\\0{0,4}(45|65)(\r\n|[ \t\r\n\f])?
G               g|\\0{0,4}(47|67)(\r\n|[ \t\r\n\f])?|\\g
H               h|\\0{0,4}(48|68)(\r\n|[ \t\r\n\f])?|\\h
I               i|\\0{0,4}(49|69)(\r\n|[ \t\r\n\f])?|\\i
K               k|\\0{0,4}(4b|6b)(\r\n|[ \t\r\n\f])?|\\k
L               l|\\0{0,4}(4c|6c)(\r\n|[ \t\r\n\f])?|\\l
M               m|\\0{0,4}(4d|6d)(\r\n|[ \t\r\n\f])?|\\m
N               n|\\0{0,4}(4e|6e)(\r\n|[ \t\r\n\f])?|\\n
O               o|\\0{0,4}(4f|6f)(\r\n|[ \t\r\n\f])?|\\o
P               p|\\0{0,4}(50|70)(\r\n|[ \t\r\n\f])?|\\p
R               r|\\0{0,4}(52|72)(\r\n|[ \t\r\n\f])?|\\r
S               s|\\0{0,4}(53|73)(\r\n|[ \t\r\n\f])?|\\s
T               t|\\0{0,4}(54|74)(\r\n|[ \t\r\n\f])?|\\t
U               u|\\0{0,4}(55|75)(\r\n|[ \t\r\n\f])?|\\u
X               x|\\0{0,4}(58|78)(\r\n|[ \t\r\n\f])?|\\x
Z               z|\\0{0,4}(5a|7a)(\r\n|[ \t\r\n\f])?|\\z

%%

{s}                     {return S;}

\/\*[^*]*\*+([^/*][^*]*\*+)*\/          /* ignore comments */
{badcomment}                         /* unclosed comment at EOF */

"<!--"               {return CDO;}
"-->"                        {return CDC;}
"~="                    {return INCLUDES;}
"|="                    {return DASHMATCH;}

{string}                {return STRING;}
{badstring}             {return BAD_STRING;}

{ident}                 {return IDENT;}

"#"{name}               {return HASH;}

@{I}{M}{P}{O}{R}{T}     {return IMPORT_SYM;}
@{P}{A}{G}{E}           {return PAGE_SYM;}
@{M}{E}{D}{I}{A}        {return MEDIA_SYM;}
"@charset "             {return CHARSET_SYM;}

"!"({w}|{comment})*{I}{M}{P}{O}{R}{T}{A}{N}{T}  {return IMPORTANT_SYM;}

{num}{E}{M}             {return EMS;}
{num}{E}{X}             {return EXS;}
{num}{P}{X}             {return LENGTH;}
{num}{C}{M}             {return LENGTH;}
{num}{M}{M}             {return LENGTH;}
{num}{I}{N}             {return LENGTH;}
{num}{P}{T}             {return LENGTH;}
{num}{P}{C}             {return LENGTH;}
{num}{D}{E}{G}          {return ANGLE;}
{num}{R}{A}{D}          {return ANGLE;}
{num}{G}{R}{A}{D}       {return ANGLE;}
{num}{M}{S}             {return TIME;}
{num}{S}                {return TIME;}
{num}{H}{Z}             {return FREQ;}
{num}{K}{H}{Z}          {return FREQ;}
{num}{ident}            {return DIMENSION;}

{num}%                  {return PERCENTAGE;}
{num}                   {return NUMBER;}

"url("{w}{string}{w}")" {return URI;}
"url("{w}{url}{w}")"    {return URI;}
{baduri}                {return BAD_URI;}

{ident}"("              {return FUNCTION;}

.                       {return *yytext;}


  G.3 CSS2.1とCSS1のトークン化の比較

  CSS1勧告（[CSS1]）で規定された構文と上記の構文は、多少の相違点が存在する。相違点のほとんどは、CSS1に存在しなかったCSS2の新しいトークンによるものである。その他は文法が読みやすくなるように書き直されているためである。しかし、CSS1の構文でエラーであると感じた一部の互換性のない変更が存在する。これら変更点を以下で説明する。

  CSS1スタイルシートは、ASCIIやISO-8859-1といった1バイト文字エンコーディングのみが可能であった。CSS 2.1はそのような制限はありません。実際には、CSS1トークナイザを外挿することはまったく困難ではなく、一部のユーザーエージェントは2バイトエンコーディングを受け入れている。

    CSS1はUnicode文字を参照するためにバックスラッシュ（\）の後に4桁の16進数のみ許可されたが、CSS2は6桁が許可される。また、CSS2は空白文字がエスケープシーケンスを区切ることができる。たとえば、CSS1に従うと、文字列"\abcdef"は3文字（\ABCD、E、F）を持つが、CSS2に従うと、1つだけ（\ABCDEF）を持つ。

    タブ文字（ASCII 9）は文字列に許可されなかった。しかし、CSS1の文字列はフォント名とURLのためにのみ使用されたので、CSS1とCSS2との間の非互換性につながるとすれば、スタイルシートがその名前の中にタブを持っているフォントファミリが含まれている場合に限られる。

    同様に、（バックスラッシュでエスケープされた）改行はCSS1の文字列で許可されていなかった。

    CSS2は、数字の直後に続く識別子はDIMENSIONトークンとして解析する（すなわち、未知の単位）が、CSS1は数字と識別子として解析された。CSS1では、宣言'font: 10pt/1.2serif'が、'10pt/12pt serif'として正しく解析されたが、CSS2では、"serif"の前にスペースが要求される。（一部のユーザーエージェントは、最初の例を受け入れたが、2番目を受け入れなかった。）

    CSS1では、寸法でない限り（".55in"）、クラス名は数字で開始可能であった（".55ft"）。CSS2では、このようなクラスは未知の次元として解析される（将来の新しい単位の追加を可能にするために）。".55ft"を妥当なクラスにするために、CSS2は最初の数字のエスケープを要求する（ "\35 5ft"）。
  G.4 実装ノート

  4.1.1節でCSSのコア構文の語彙スキャナは、バックアップせずにスキャナとして実装可能である。Lexの表記では、以下のパターンの追加を必要する（スキャナの効率のみを考え、返されたトークンを変更しない）:
  
{ident}/\\          return IDENT;
#{name}/\\          return HASH;
@{ident}/\\         return ATKEYWORD;
#/\\                return DELIM;
@/\\                return DELIM;
@/-                 return DELIM;
@/-\\               return DELIM;
-/\\                return DELIM;
-/-                 return DELIM;
\</!                return DELIM;
\</!-               return DELIM;
{num}{ident}/\\     return DIMENSION;
{num}/\\            return NUMBER;
{num}/-             return NUMBER;
{num}/-\\           return NUMBER;
[0-9]+/\.           return NUMBER;
u/\+                return IDENT;
u\+[0-9a-f?]{1,6}/- return UNICODE_RANGE;


  付録 H: 意図的に残されている空白

  付録 I. 索引

  この付録は参考情報で、規範的ではない。

  
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
  

  
    

    :active, 2

      :after, 1, 2

      :before, 1, 2

      :first, 1

      :first-child, 1

      :first-letter, 1

      :first-line, 1

      :focus, 1

      :hover, 1

      :lang, 1

      :left, 1

      :link, 1

      :right, 1

      :visited, 1

      =, 1

      ~=, 1

      |=, 1
     

    @charset, 1, 2, 3

      "@charset", 1

      @import, 1, 2, 3

      @media, 1, 2

      @page, 1
     

    absolute length, 1

      absolutely positioned element, 1

      active (pseudo-class), 1

      actual value, 1

      adjoining margins, 1

      after, 1

      'all' media group, 1

      ancestor, 1

      <angle>, 1, 2

        definition of, 1
        

      anonymous, 1

      anonymous boxes., 1

      anonymous inline boxes, 1

      armenian, 1

      at-rule, 1

      at-rules, 1

      atomic inline-level box, 1

      attr(), 1

      attribute, 1

      'audio' media group, 1

      auditory icon, 1

      Author, 1

      authoring tool, 1

      automatic numbering, 1

      'azimuth', 1
     

    'background', 1

      'background-attachment', 1

      'background-color', 1

      'background-image', 1

      'background-position', 1

      'background-repeat', 1

      backslash escapes, 1

      before, 1

      bidirectionality (bidi), 1

      'bitmap' media group, 1

      block, 1

      block box, 1

      block container box, 1

      'block', definition of, 1

      block-level box, 1

      block-level element, 1

      BOM, 1

      border box, 1

      border edge, 1

      'border', 1

      'border-bottom', 1

      'border-bottom-color', 1

      'border-bottom-style', 1

      'border-bottom-width', 1

      'border-collapse', 1

      'border-color', 1

      'border-left', 1

      'border-left-color', 1

      'border-left-style', 1

      'border-left-width', 1

      'border-right', 1

      'border-right-color', 1

      'border-right-style', 1

      'border-right-width', 1

      'border-spacing', 1

      <border-style>, 1

      <border-style>, definition of, 1

      'border-style', 1

      'border-top', 1

      'border-top-color', 1

      'border-top-style', 1

      'border-top-width', 1

      <border-width>

        definition of, 1
        

      'border-width', 1

      border

        of a box, 1
        

      <bottom>

        definition of, 1
        

      'bottom', 1

      box

        border, 1

          content, 1

          content height, 1

          content width, 1

          margin, 1

          overflow, 1

          padding, 1
        
     

    canvas, 1, 2

      'caption-side', 1

      cascade, 1

      case sensitivity, 1

      character encoding, 1

        default, 1

          user agent's determination of, 1
        

      child, 1

      child selector, 1

      circle, 1

      'clear', 1

      clearance, 1

      'clip', 1

      clipping region, 1

      close-quote, 1, 2

      collapse, 1

      collapse through, 1

      collapsing margin, 1

      color, 1

      <color>, 1, 2

        definition of, 1
        

      'color', 1

      combinator, 1

      comments, 1

      computed value, 1

      conditional import, 1

      conformance, 1, 2

      consecutive, 1

      containing block, 1, 2, 3

        initial, 1
        

      content, 1

      content box, 1

      content edge, 1

      'content', 1

      content

        of a box, 1

          rendered, 1
        

      'continuous' media group, 1

      <counter>, 1

      <counter>, definition of, 1

      counter(), 1

      'counter-increment', 1

      'counter-reset', 1

      counters, 1

      'cue', 1

      'cue-after', 1

      'cue-before', 1

      cursive, definition of, 1

      'cursor', 1
     

    'dashed', 1, 2

      decimal, 1

      decimal-leading-zero, 1

      declaration, 1

      declaration block, 1

      default style sheet, 1

      default

        character encoding, 1
        

      descendant, 1

      descendant-selectors, 1

      'direction', 1

      disc, 1

      'display', 1

      document language, 1

      document tree, 1

      'dotted', 1, 2

      'double', 1, 2

      drop caps, 1

      DTD, 1, 2
     

    element, 1

        following, 1

          preceding, 1
        

      'elevation', 1

      em (unit), 1

      empty, 1

      'empty-cells', 1

      ex (unit), 1

      exact matching, 1
     

    fantasy, definition of, 1

      fictional tag sequence, 1, 2, 3

      first-child, 1

      first-letter, 1

      first-line, 1

      float rules, 1

      'float', 1

      flow of an element, 1

      focus, 1

      focus (pseudo-class), 1

      following element, 1

      'font', 1

      'font-family', 1

      'font-size', 1

      'font-style', 1

      'font-variant', 1

      'font-weight', 1

      formatting context, 1

      formatting structure, 1

      forward-compatible parsing, 1

      <frequency>, 1

        definition of, 1
        
     

    generated content, 1

      <generic-voice>, definition of, 1

      georgian, 1

      'grid' media group, 1

      'groove', 1, 2
     

    'height', 1

      'hidden, 1

      'hidden', 1

      hover (pseudo-class), 1

      hyphen-separated matching, 1
     

    identifier, 1

      identifier, definition of, 1

      ignore, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17

      in-flow, 1

      inherit, definition of, 1

      initial caps, 1

      initial containing block, 1

      initial value, 1

      inline box, 1

      'inline', definition of, 1

      'inline-block', definition of, 1

      inline-level box, 1

      inline-level element, 1

      inline-table, 1

      inner edge, 1

      'inset', 1, 2

      <integer>, 1

        definition of, 1
        

      'interactive media group, 1

      internal table box, 1

      internal table element, 1

      intrinsic dimensions, 1

      invert, 1

      iso-10646, 1
       

    LALR(1), 1

      lang (pseudo-class), 1

      language (human), 1

      language code, 1

      <left>

        definition of, 1
        

      'left', 1

      <length>, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

        definition of, 1
        

      'letter-spacing', 1

      ligatures, 1

      line box, 1

      line-box, 1

      'line-height', 1

      link (pseudo-class), 1

      list properties, 1

      'list-item', definition of, 1

      'list-style', 1

      'list-style-image', 1

      'list-style-position', 1

      'list-style-type', 1

      lower-greek, 1

      lower-latin, 1

      lower-roman, 1
     

    mapping elements to table parts, 1

      margin box, 1

      margin edge, 1

      'margin', 1

      'margin-bottom', 1

      'margin-left', 1

      'margin-right', 1

      'margin-top', 1

      <margin-width>

        definition of, 1
        

      margin

        of a box, 1
        

      match, 1

      'max-height', 1

      'max-width', 1

      MAY, 1

      media, 1

      media group, 1

      media-dependent import, 1

      message entity, 1

      'min-height', 1

      'min-width', 1

      monospace, definition of, 1

      multiple declarations, 1

      MUST, 1

      MUST NOT, 1
     

    newline, 1

      no-close-quote, 1, 2

      no-open-quote, 1, 2

      none, 1

      'none'

        as border style, 1, 2

          as display value, 1
        

      normal, 1

      <number>, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11

        definition of, 1
        
     

    open-quote, 1, 2

      OPTIONAL, 1

      'orphans', 1

      out of flow, 1

      outer edge, 1

      outline, 1

      'outline', 1

      'outline-color', 1

      'outline-style', 1

      'outline-width', 1

      'outset', 1, 2

      overflow, 1

      'overflow', 1
     

    padding box, 1

      padding edge, 1

      'padding', 1

      'padding-bottom', 1

      'padding-left', 1

      'padding-right', 1

      'padding-top', 1

      <padding-width>

        definition of, 1
        

      padding

        of a box, 1
        

      page area, 1

      page box, 1

      page selector, 1

      'page-break-after', 1

      'page-break-before', 1

      'page-break-inside', 1

      page-context, 1

      'paged' media group, 1

      parent, 1

      'pause', 1

      'pause-after', 1

      'pause-before', 1

      <percentage>, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

        definition of, 1
        

      'pitch', 1

      'pitch-range', 1

      pixel, 1

      'play-during', 1

      'position', 1

      positioned element/box, 1

      positioning scheme, 1

      preceding element, 1

      principal block-level box, 1

      proper table child, 1

      proper table row parent, 1

      Property, 1

      property, 1

      'property-name', 1

      pseudo-class

        :first, 1

          :left, 1

          :right, 1
        

      pseudo-classes, 1

        :active, 1

          :focus, 1

          :hover, 1

          :lang, 1

          :link, 1

          :visited, 1
        

      pseudo-elements, 1

        :after, 1, 2

          :before, 1, 2

          :first-letter, 1

          :first-line, 1, 2
        
     

    quad width, 1

      'quotes', 1
     

    RECOMMENDED, 1

      reference pixel, 1

      relative positioning, 1

      relative units, 1

      rendered content, 1

      replaced element, 1

      REQUIRED, 1

      'richness', 1

      'ridge', 1, 2

      <right>

        definition of, 1
        

      'right', 1

      root, 1

      row group box, 1

      row groups, 1

      rule sets, 1

      run-in, 1
     

    sans-serif, definition of, 1

      scope, 1

      screen reader, 1

      selector, 1, 2, 3, 4

        match, 1

          subject of, 1
        

      separated borders, 1

      serif, definition of, 1

      SHALL, 1

      SHALL NOT, 1

      <shape>

        definition of, 1
        

      sheet, 1

      shorthand property, 1, 2, 3

      SHOULD, 1

      SHOULD NOT, 1

      sibling, 1

      simple selector, 1

      'solid', 1, 2

      source document, 1

      space-separated matching, 1

      'speak', 1

      'speak-header', 1

      'speak-numeral', 1

      'speak-punctuation', 1

      <specific-voice>

        definition of, 1
        

      specified value, 1

      'speech' media group, 1

      'speech-rate', 1

      square, 1

      stack level, 1

      stacking context, 1

      statements, 1

      'static' media group, 1

      'stress', 1

      string, 1

      <string>, 1, 2, 3

      <string>, definition of, 1

      illegal, 1

      style sheet, 1

      subject (of selector), 1

      system fonts, 1
     

    table, 1

      table element, 1

        internal, 1
        

      table-caption, 1

      table-cell, 1

      table-column, 1

      table-column-group, 1

      table-footer-group, 1

      table-header-group, 1

      'table-layout', 1

      table-row, 1

      table-row-group, 1

      tables, 1

      tabular container, 1

      'tactile' media group, 1

      'text-align', 1

      'text-decoration', 1

      'text-indent', 1

      'text-transform', 1

      text/css, 1

      <time>, 1

        definition of, 1
        

      tokenizer, 1

      <top>

        definition of, 1
        

      'top', 1

      type selector, 1
     

    UA, 1

      unicode, 1

      'unicode-bidi', 1

      universal selector, 1

      upper-latin, 1

      upper-roman, 1

      <uri>, 1, 2, 3, 4, 5, 6, 7

        definition of, 1
        

      used value, 1

      User, 1

      user agent, 1

      User agent (UA), 1

      UTF-8, 1
     

    valid style sheet, 1

      validity, 1

      value, 1

      'vertical-align', 1

      viewport, 1

      'visibility', 1

      visited (pseudo-class), 1

      visual formatting model, 1

      'visual' media group, 1

      'voice-family', 1

      volume, 1

      'volume', 1
     

    'white-space', 1

      'widows', 1

      'width', 1

      'word-spacing', 1
     

    x-height, 1
      

    'z-index', 1
    
